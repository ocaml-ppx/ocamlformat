--- parser-standard/ast_helper.ml
+++ parser-extended/ast_helper.ml
@@@@
 
 let with_default_loc l f =
   Misc.protect_refs [Misc.R (default_loc, l)] f
 
 module Const = struct
-  let integer ?suffix i = Pconst_integer (i, suffix)
-  let int ?suffix i = integer ?suffix (Int.to_string i)
-  let int32 ?(suffix='l') i = integer ~suffix (Int32.to_string i)
-  let int64 ?(suffix='L') i = integer ~suffix (Int64.to_string i)
-  let nativeint ?(suffix='n') i = integer ~suffix (Nativeint.to_string i)
-  let float ?suffix f = Pconst_float (f, suffix)
-  let char c = Pconst_char c
+  let mk ?(loc = !default_loc) d =
+    {pconst_desc = d;
+     pconst_loc = loc}
+
+  let integer ?loc ?suffix i = mk ?loc (Pconst_integer (i, suffix))
+  let int ?loc ?suffix i = integer ?loc ?suffix (Int.to_string i)
+  let int32 ?loc ?(suffix='l') i = integer ?loc ~suffix (Int32.to_string i)
+  let int64 ?loc ?(suffix='L') i = integer ?loc ~suffix (Int64.to_string i)
+  let nativeint ?loc ?(suffix='n') i =
+    integer ?loc ~suffix (Nativeint.to_string i)
+  let float ?loc ?suffix f = mk ?loc (Pconst_float (f, suffix))
+  let char ?loc c = mk ?loc (Pconst_char c)
   let string ?quotation_delimiter ?(loc= !default_loc) s =
-    Pconst_string (s, loc, quotation_delimiter)
+    mk ~loc (Pconst_string (s, loc, quotation_delimiter))
 end
 
 module Attr = struct
   let mk ?(loc= !default_loc) name payload =
     { attr_name = name;
@@@@
 
   let attr d a = {d with ptyp_attributes = d.ptyp_attributes @ [a]}
 
   let any ?loc ?attrs () = mk ?loc ?attrs Ptyp_any
   let var ?loc ?attrs a = mk ?loc ?attrs (Ptyp_var a)
-  let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_arrow (a, b, c))
+  let arrow ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_arrow (a, b))
   let tuple ?loc ?attrs a = mk ?loc ?attrs (Ptyp_tuple a)
   let constr ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_constr (a, b))
   let object_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_object (a, b))
   let class_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_class (a, b))
   let alias ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_alias (a, b))
@@@@
         match t.ptyp_desc with
         | Ptyp_any -> Ptyp_any
         | Ptyp_var x ->
             check_variable var_names t.ptyp_loc x;
             Ptyp_var x
-        | Ptyp_arrow (label,core_type,core_type') ->
-            Ptyp_arrow(label, loop core_type, loop core_type')
+        | Ptyp_arrow (params, core_type') ->
+            let params = List.map (fun {pap_label; pap_loc; pap_type} ->
+                {pap_label; pap_loc; pap_type= loop pap_type}) params in
+            Ptyp_arrow (params, loop core_type')
         | Ptyp_tuple lst -> Ptyp_tuple (List.map loop lst)
         | Ptyp_constr( { txt = Longident.Lident s }, [])
           when List.mem s var_names ->
             Ptyp_var s
         | Ptyp_constr(longident, lst) ->
@@@@
   let tuple ?loc ?attrs a = mk ?loc ?attrs (Ppat_tuple a)
   let construct ?loc ?attrs a b = mk ?loc ?attrs (Ppat_construct (a, b))
   let variant ?loc ?attrs a b = mk ?loc ?attrs (Ppat_variant (a, b))
   let record ?loc ?attrs a b = mk ?loc ?attrs (Ppat_record (a, b))
   let array ?loc ?attrs a = mk ?loc ?attrs (Ppat_array a)
+  let list ?loc ?attrs a = mk ?loc ?attrs (Ppat_list a)
   let or_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_or (a, b))
   let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_constraint (a, b))
   let type_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_type a)
   let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_lazy a)
   let unpack ?loc ?attrs a = mk ?loc ?attrs (Ppat_unpack a)
   let open_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_open (a, b))
   let exception_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_exception a)
   let extension ?loc ?attrs a = mk ?loc ?attrs (Ppat_extension a)
+  let cons ?loc ?attrs a = mk ?loc ?attrs (Ppat_cons a)
 end
 
 module Exp = struct
   let mk ?(loc = !default_loc) ?(attrs = []) d =
     {pexp_desc = d;
@@@@
   let variant ?loc ?attrs a b = mk ?loc ?attrs (Pexp_variant (a, b))
   let record ?loc ?attrs a b = mk ?loc ?attrs (Pexp_record (a, b))
   let field ?loc ?attrs a b = mk ?loc ?attrs (Pexp_field (a, b))
   let setfield ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_setfield (a, b, c))
   let array ?loc ?attrs a = mk ?loc ?attrs (Pexp_array a)
+  let list ?loc ?attrs a = mk ?loc ?attrs (Pexp_list a)
   let ifthenelse ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_ifthenelse (a, b, c))
   let sequence ?loc ?attrs a b = mk ?loc ?attrs (Pexp_sequence (a, b))
   let while_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_while (a, b))
   let for_ ?loc ?attrs a b c d e = mk ?loc ?attrs (Pexp_for (a, b, c, d, e))
   let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_constraint (a, b))
@@@@
   let poly ?loc ?attrs a b = mk ?loc ?attrs (Pexp_poly (a, b))
   let object_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_object a)
   let newtype ?loc ?attrs a b = mk ?loc ?attrs (Pexp_newtype (a, b))
   let pack ?loc ?attrs a = mk ?loc ?attrs (Pexp_pack a)
   let open_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_open (a, b))
+  let letopen ?loc ?attrs a b = mk ?loc ?attrs (Pexp_letopen (a, b))
   let letop ?loc ?attrs let_ ands body =
     mk ?loc ?attrs (Pexp_letop {let_; ands; body})
   let extension ?loc ?attrs a = mk ?loc ?attrs (Pexp_extension a)
   let unreachable ?loc ?attrs () = mk ?loc ?attrs Pexp_unreachable
   let hole  ?loc ?attrs () = mk ?loc ?attrs Pexp_hole
+  let beginend ?loc ?attrs a = mk ?loc ?attrs (Pexp_beginend a)
+  let cons ?loc ?attrs a = mk ?loc ?attrs (Pexp_cons a)
 
   let case lhs ?guard rhs =
     {
      pc_lhs = lhs;
      pc_guard = guard;
@@@@
     }
   let attr d a = {d with pcty_attributes = d.pcty_attributes @ [a]}
 
   let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcty_constr (a, b))
   let signature ?loc ?attrs a = mk ?loc ?attrs (Pcty_signature a)
-  let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Pcty_arrow (a, b, c))
+  let arrow ?loc ?attrs a b = mk ?loc ?attrs (Pcty_arrow (a, b))
   let extension ?loc ?attrs a = mk ?loc ?attrs (Pcty_extension a)
   let open_ ?loc ?attrs a b = mk ?loc ?attrs (Pcty_open (a, b))
 end
 
 module Ctf = struct
@@@@
      pctf_loc = loc;
      pctf_attributes = add_docs_attrs docs attrs;
     }
 
   let inherit_ ?loc ?attrs a = mk ?loc ?attrs (Pctf_inherit a)
-  let val_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_val (a, b, c, d))
-  let method_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_method (a, b, c, d))
+  let val_ ?loc ?attrs a b c = mk ?loc ?attrs (Pctf_val (a, b, c))
+  let method_ ?loc ?attrs a b c = mk ?loc ?attrs (Pctf_method (a, b, c))
   let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pctf_constraint (a, b))
   let extension ?loc ?attrs a = mk ?loc ?attrs (Pctf_extension a)
   let attribute ?loc a = mk ?loc (Pctf_attribute a)
   let text txt =
    let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
--- parser-standard/ast_helper.mli
+++ parser-extended/ast_helper.mli
@@@@
         of the provided function. *)
 
 (** {1 Constants} *)
 
 module Const : sig
-  val char : char -> constant
+  val mk: ?loc:loc -> constant_desc -> constant
+
+  val char : ?loc:loc -> char -> constant
   val string :
     ?quotation_delimiter:string -> ?loc:Location.t -> string -> constant
-  val integer : ?suffix:char -> string -> constant
-  val int : ?suffix:char -> int -> constant
-  val int32 : ?suffix:char -> int32 -> constant
-  val int64 : ?suffix:char -> int64 -> constant
-  val nativeint : ?suffix:char -> nativeint -> constant
-  val float : ?suffix:char -> string -> constant
+  val integer : ?loc:loc -> ?suffix:char -> string -> constant
+  val int : ?loc:loc -> ?suffix:char -> int -> constant
+  val int32 : ?loc:loc -> ?suffix:char -> int32 -> constant
+  val int64 : ?loc:loc -> ?suffix:char -> int64 -> constant
+  val nativeint : ?loc:loc -> ?suffix:char -> nativeint -> constant
+  val float : ?loc:loc -> ?suffix:char -> string -> constant
 end
 
 (** {1 Attributes} *)
 module Attr : sig
   val mk: ?loc:loc -> str -> payload -> attribute
@@@@
     val mk: ?loc:loc -> ?attrs:attrs -> core_type_desc -> core_type
     val attr: core_type -> attribute -> core_type
 
     val any: ?loc:loc -> ?attrs:attrs -> unit -> core_type
     val var: ?loc:loc -> ?attrs:attrs -> string -> core_type
-    val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type -> core_type
+    val arrow: ?loc:loc -> ?attrs:attrs -> arrow_param list -> core_type
                -> core_type
     val tuple: ?loc:loc -> ?attrs:attrs -> core_type list -> core_type
     val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
     val object_: ?loc:loc -> ?attrs:attrs -> object_field list
-                   -> closed_flag -> core_type
+                   -> obj_closed_flag -> core_type
     val class_: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
     val alias: ?loc:loc -> ?attrs:attrs -> core_type -> string -> core_type
     val variant: ?loc:loc -> ?attrs:attrs -> row_field list -> closed_flag
                  -> label list option -> core_type
     val poly: ?loc:loc -> ?attrs:attrs -> str list -> core_type -> core_type
@@@@
     val interval: ?loc:loc -> ?attrs:attrs -> constant -> constant -> pattern
     val tuple: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
     val construct: ?loc:loc -> ?attrs:attrs ->
       lid -> (str list * pattern) option -> pattern
     val variant: ?loc:loc -> ?attrs:attrs -> label -> pattern option -> pattern
-    val record: ?loc:loc -> ?attrs:attrs -> (lid * pattern) list -> closed_flag
-                -> pattern
+    val record: ?loc:loc -> ?attrs:attrs -> (lid * pattern) list
+                -> obj_closed_flag -> pattern
     val array: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
+    val list: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
     val or_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern -> pattern
     val constraint_: ?loc:loc -> ?attrs:attrs -> pattern -> core_type -> pattern
     val type_: ?loc:loc -> ?attrs:attrs -> lid -> pattern
     val lazy_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
     val unpack: ?loc:loc -> ?attrs:attrs -> str_opt -> pattern
     val open_: ?loc:loc -> ?attrs:attrs  -> lid -> pattern -> pattern
     val exception_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
     val extension: ?loc:loc -> ?attrs:attrs -> extension -> pattern
+    val cons: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
   end
 
 (** Expressions *)
 module Exp:
   sig
@@@@
                 -> expression option -> expression
     val field: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
     val setfield: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
                   -> expression
     val array: ?loc:loc -> ?attrs:attrs -> expression list -> expression
+    val list: ?loc:loc -> ?attrs:attrs -> expression list -> expression
     val ifthenelse: ?loc:loc -> ?attrs:attrs -> expression -> expression
                     -> expression option -> expression
     val sequence: ?loc:loc -> ?attrs:attrs -> expression -> expression
                   -> expression
     val while_: ?loc:loc -> ?attrs:attrs -> expression -> expression
@@@@
     val poly: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
               -> expression
     val object_: ?loc:loc -> ?attrs:attrs -> class_structure -> expression
     val newtype: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression
     val pack: ?loc:loc -> ?attrs:attrs -> module_expr -> expression
-    val open_: ?loc:loc -> ?attrs:attrs -> open_declaration -> expression
+    val open_: ?loc:loc -> ?attrs:attrs -> lid -> expression -> expression
+    val letopen: ?loc:loc -> ?attrs:attrs -> open_declaration -> expression
                -> expression
     val letop: ?loc:loc -> ?attrs:attrs -> binding_op
                -> binding_op list -> expression -> expression
     val extension: ?loc:loc -> ?attrs:attrs -> extension -> expression
     val unreachable: ?loc:loc -> ?attrs:attrs -> unit -> expression
 
     val case: pattern -> ?guard:expression -> expression -> case
     val binding_op: str -> pattern -> expression -> loc -> binding_op
     val hole: ?loc:loc -> ?attrs:attrs -> unit -> expression
+    val beginend: ?loc:loc -> ?attrs:attrs -> expression -> expression
+    val cons: ?loc:loc -> ?attrs:attrs -> expression list -> expression
   end
 
 (** Value declarations *)
 module Val:
   sig
@@@@
 
 (** Type declarations *)
 module Type:
   sig
     val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
-      ?params:(core_type * (variance * injectivity)) list ->
+      ?params:(core_type * variance_and_injectivity) list ->
       ?cstrs:(core_type * core_type * loc) list ->
       ?kind:type_kind -> ?priv:private_flag -> ?manifest:core_type -> str ->
       type_declaration
 
     val constructor: ?loc:loc -> ?attrs:attrs -> ?info:info ->
@@@@
 
 (** Type extensions *)
 module Te:
   sig
     val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
-      ?params:(core_type * (variance * injectivity)) list ->
+      ?params:(core_type * variance_and_injectivity) list ->
       ?priv:private_flag -> lid -> extension_constructor list -> type_extension
 
     val mk_exception: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
       extension_constructor -> type_exception
 
@@@@
     val mk: ?loc:loc -> ?attrs:attrs -> class_type_desc -> class_type
     val attr: class_type -> attribute -> class_type
 
     val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_type
     val signature: ?loc:loc -> ?attrs:attrs -> class_signature -> class_type
-    val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type ->
+    val arrow: ?loc:loc -> ?attrs:attrs -> arrow_param list ->
       class_type -> class_type
     val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type
     val open_: ?loc:loc -> ?attrs:attrs -> open_description -> class_type
                -> class_type
   end
@@@@
     val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
       class_type_field_desc -> class_type_field
     val attr: class_type_field -> attribute -> class_type_field
 
     val inherit_: ?loc:loc -> ?attrs:attrs -> class_type -> class_type_field
-    val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag ->
-      virtual_flag -> core_type -> class_type_field
-    val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag ->
-      virtual_flag -> core_type -> class_type_field
+    val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_virtual ->
+      core_type -> class_type_field
+    val method_: ?loc:loc -> ?attrs:attrs -> str -> private_virtual ->
+      core_type -> class_type_field
     val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->
       class_type_field
     val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type_field
     val attribute: ?loc:loc -> attribute -> class_type_field
     val text: text -> class_type_field list
@@@@
       class_field
     val attr: class_field -> attribute -> class_field
 
     val inherit_: ?loc:loc -> ?attrs:attrs -> override_flag -> class_expr ->
       str option -> class_field
-    val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag ->
+    val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_virtual ->
       class_field_kind -> class_field
-    val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag ->
+    val method_: ?loc:loc -> ?attrs:attrs -> str -> private_virtual ->
       class_field_kind -> class_field
     val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->
       class_field
     val initializer_: ?loc:loc -> ?attrs:attrs -> expression -> class_field
     val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_field
@@@@
 (** Classes *)
 module Ci:
   sig
     val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
       ?virt:virtual_flag ->
-      ?params:(core_type * (variance * injectivity)) list ->
+      ?params:(core_type * variance_and_injectivity) list ->
       str -> 'a -> 'a class_infos
   end
 
 (** Class signatures *)
 module Csig:
--- parser-standard/ast_mapper.ml
+++ parser-extended/ast_mapper.ml
@@@@
   value_description: mapper -> value_description -> value_description;
   with_constraint: mapper -> with_constraint -> with_constraint;
   directive_argument: mapper -> directive_argument -> directive_argument;
   toplevel_directive: mapper -> toplevel_directive -> toplevel_directive;
   toplevel_phrase: mapper -> toplevel_phrase -> toplevel_phrase;
+  repl_phrase: mapper -> repl_phrase -> repl_phrase;
 }
 
 let map_fst f (x, y) = (f x, y)
 let map_snd f (x, y) = (x, f y)
 let map_tuple f1 f2 (x, y) = (f1 x, f2 y)
 let map_tuple3 f1 f2 f3 (x, y, z) = (f1 x, f2 y, f3 z)
 let map_opt f = function None -> None | Some x -> Some (f x)
 
 let map_loc sub {loc; txt} = {loc = sub.location sub loc; txt}
 
+module Flag = struct
+  open Asttypes
+
+  let map_obj_closed sub = function
+    | OClosed -> OClosed
+    | OOpen loc -> OOpen (sub.location sub loc)
+
+  let map_private sub = function
+    | Private loc -> Private (sub.location sub loc)
+    | Public -> Public
+
+  let map_mutable sub = function
+    | Mutable loc -> Mutable (sub.location sub loc)
+    | Immutable -> Immutable
+
+  let map_virtual sub = function
+    | Virtual loc -> Virtual (sub.location sub loc)
+    | Concrete -> Concrete
+
+  let map_private_virtual sub { pv_priv; pv_virt } =
+    let pv_priv = map_opt (sub.location sub) pv_priv in
+    let pv_virt = map_opt (sub.location sub) pv_virt in
+    { pv_priv; pv_virt }
+
+  let map_mutable_virtual sub { mv_mut; mv_virt } =
+    let mv_mut = map_opt (sub.location sub) mv_mut in
+    let mv_virt = map_opt (sub.location sub) mv_virt in
+    { mv_mut; mv_virt }
+end
+
 module C = struct
   (* Constants *)
 
-  let map sub c = match c with
-    | Pconst_integer _
-    | Pconst_char _
-    | Pconst_float _
-      -> c
-    | Pconst_string (s, loc, quotation_delimiter) ->
-        let loc = sub.location sub loc in
-        Const.string ~loc ?quotation_delimiter s
+  let map sub { pconst_desc; pconst_loc } =
+    let loc = sub.location sub pconst_loc in
+    let desc =
+      match pconst_desc with
+      | Pconst_integer _
+      | Pconst_char _
+      | Pconst_float _ ->
+          pconst_desc
+      | Pconst_string (s, loc, quotation_delimiter) ->
+          Pconst_string (s, sub.location sub loc, quotation_delimiter)
+    in
+    Const.mk ~loc desc
 end
 
 module T = struct
   (* Type expressions for the core language *)
 
@@@@
       | Otag (l, t) -> Otag (map_loc sub l, sub.typ sub t)
       | Oinherit t -> Oinherit (sub.typ sub t)
     in
     Of.mk ~loc ~attrs desc
 
+  let map_arrow_param sub {pap_label; pap_loc; pap_type} =
+    let pap_loc = sub.location sub pap_loc in
+    let pap_type = sub.typ sub pap_type in
+    {pap_label; pap_loc; pap_type}
+
   let map sub {ptyp_desc = desc; ptyp_loc = loc; ptyp_attributes = attrs} =
     let open Typ in
     let loc = sub.location sub loc in
     let attrs = sub.attributes sub attrs in
     match desc with
     | Ptyp_any -> any ~loc ~attrs ()
     | Ptyp_var s -> var ~loc ~attrs s
-    | Ptyp_arrow (lab, t1, t2) ->
-        arrow ~loc ~attrs lab (sub.typ sub t1) (sub.typ sub t2)
+    | Ptyp_arrow (params, t2) ->
+        arrow ~loc ~attrs (List.map (map_arrow_param sub) params)
+          (sub.typ sub t2)
     | Ptyp_tuple tyl -> tuple ~loc ~attrs (List.map (sub.typ sub) tyl)
     | Ptyp_constr (lid, tl) ->
         constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
     | Ptyp_object (l, o) ->
-        object_ ~loc ~attrs (List.map (object_field sub) l) o
+        object_ ~loc ~attrs (List.map (object_field sub) l)
+          (Flag.map_obj_closed sub o)
     | Ptyp_class (lid, tl) ->
         class_ ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
     | Ptyp_alias (t, s) -> alias ~loc ~attrs (sub.typ sub t) s
     | Ptyp_variant (rl, b, ll) ->
         variant ~loc ~attrs (List.map (row_field sub) rl) b ll
@@@@
        ptype_loc} =
     let loc = sub.location sub ptype_loc in
     let attrs = sub.attributes sub ptype_attributes in
     Type.mk ~loc ~attrs (map_loc sub ptype_name)
       ~params:(List.map (map_fst (sub.typ sub)) ptype_params)
-      ~priv:ptype_private
+      ~priv:(Flag.map_private sub ptype_private)
       ~cstrs:(List.map
                 (map_tuple3 (sub.typ sub) (sub.typ sub) (sub.location sub))
                 ptype_cstrs)
       ~kind:(sub.type_kind sub ptype_kind)
       ?manifest:(map_opt (sub.typ sub) ptype_manifest)
@@@@
     let attrs = sub.attributes sub ptyext_attributes in
     Te.mk ~loc ~attrs
       (map_loc sub ptyext_path)
       (List.map (sub.extension_constructor sub) ptyext_constructors)
       ~params:(List.map (map_fst (sub.typ sub)) ptyext_params)
-      ~priv:ptyext_private
+      ~priv:(Flag.map_private sub ptyext_private)
 
   let map_type_exception sub
       {ptyexn_constructor; ptyexn_loc; ptyexn_attributes} =
     let loc = sub.location sub ptyexn_loc in
     let attrs = sub.attributes sub ptyexn_attributes in
@@@@
     let attrs = sub.attributes sub attrs in
     match desc with
     | Pcty_constr (lid, tys) ->
         constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
     | Pcty_signature x -> signature ~loc ~attrs (sub.class_signature sub x)
-    | Pcty_arrow (lab, t, ct) ->
-        arrow ~loc ~attrs lab (sub.typ sub t) (sub.class_type sub ct)
+    | Pcty_arrow (params, ct) ->
+        arrow ~loc ~attrs (List.map (T.map_arrow_param sub) params)
+          (sub.class_type sub ct)
     | Pcty_extension x -> extension ~loc ~attrs (sub.extension sub x)
     | Pcty_open (o, ct) ->
         open_ ~loc ~attrs (sub.open_description sub o) (sub.class_type sub ct)
 
   let map_field sub {pctf_desc = desc; pctf_loc = loc; pctf_attributes = attrs}
@@@@
     let open Ctf in
     let loc = sub.location sub loc in
     let attrs = sub.attributes sub attrs in
     match desc with
     | Pctf_inherit ct -> inherit_ ~loc ~attrs (sub.class_type sub ct)
-    | Pctf_val (s, m, v, t) ->
-        val_ ~loc ~attrs (map_loc sub s) m v (sub.typ sub t)
-    | Pctf_method (s, p, v, t) ->
-        method_ ~loc ~attrs (map_loc sub s) p v (sub.typ sub t)
+    | Pctf_val (s, mv, t) ->
+        val_ ~loc ~attrs (map_loc sub s) (Flag.map_mutable_virtual sub mv)
+          (sub.typ sub t)
+    | Pctf_method (s, pv, t) ->
+        method_ ~loc ~attrs (map_loc sub s) (Flag.map_private_virtual sub pv)
+          (sub.typ sub t)
     | Pctf_constraint (t1, t2) ->
         constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
     | Pctf_attribute x -> attribute ~loc (sub.attribute sub x)
     | Pctf_extension x -> extension ~loc ~attrs (sub.extension sub x)
 
@@@@
         field ~loc ~attrs (sub.expr sub e) (map_loc sub lid)
     | Pexp_setfield (e1, lid, e2) ->
         setfield ~loc ~attrs (sub.expr sub e1) (map_loc sub lid)
           (sub.expr sub e2)
     | Pexp_array el -> array ~loc ~attrs (List.map (sub.expr sub) el)
+    | Pexp_list el -> list ~loc ~attrs (List.map (sub.expr sub) el)
     | Pexp_ifthenelse (e1, e2, e3) ->
         ifthenelse ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
           (map_opt (sub.expr sub) e3)
     | Pexp_sequence (e1, e2) ->
         sequence ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
@@@@
         poly ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t)
     | Pexp_object cls -> object_ ~loc ~attrs (sub.class_structure sub cls)
     | Pexp_newtype (s, e) ->
         newtype ~loc ~attrs (map_loc sub s) (sub.expr sub e)
     | Pexp_pack me -> pack ~loc ~attrs (sub.module_expr sub me)
-    | Pexp_open (o, e) ->
-        open_ ~loc ~attrs (sub.open_declaration sub o) (sub.expr sub e)
+    | Pexp_open (o, e) -> open_ ~loc ~attrs (map_loc sub o) (sub.expr sub e)
+    | Pexp_letopen (o, e) ->
+        letopen ~loc ~attrs (sub.open_declaration sub o) (sub.expr sub e)
     | Pexp_letop {let_; ands; body} ->
         letop ~loc ~attrs (sub.binding_op sub let_)
           (List.map (sub.binding_op sub) ands) (sub.expr sub body)
     | Pexp_extension x -> extension ~loc ~attrs (sub.extension sub x)
     | Pexp_unreachable -> unreachable ~loc ~attrs ()
     | Pexp_hole -> hole ~loc ~attrs ()
+    | Pexp_beginend e -> beginend ~loc ~attrs (sub.expr sub e)
+    | Pexp_cons l -> cons ~loc ~attrs (List.map (sub.expr sub) l)
 
   let map_binding_op sub {pbop_op; pbop_pat; pbop_exp; pbop_loc} =
     let open Exp in
     let op = map_loc sub pbop_op in
     let pat = sub.pat sub pbop_pat in
@@@@
              (fun (vl, p) -> List.map (map_loc sub) vl, sub.pat sub p)
              p)
     | Ppat_variant (l, p) -> variant ~loc ~attrs l (map_opt (sub.pat sub) p)
     | Ppat_record (lpl, cf) ->
         record ~loc ~attrs
-               (List.map (map_tuple (map_loc sub) (sub.pat sub)) lpl) cf
+               (List.map (map_tuple (map_loc sub) (sub.pat sub)) lpl)
+               (Flag.map_obj_closed sub cf)
     | Ppat_array pl -> array ~loc ~attrs (List.map (sub.pat sub) pl)
+    | Ppat_list pl -> list ~loc ~attrs (List.map (sub.pat sub) pl)
     | Ppat_or (p1, p2) -> or_ ~loc ~attrs (sub.pat sub p1) (sub.pat sub p2)
     | Ppat_constraint (p, t) ->
         constraint_ ~loc ~attrs (sub.pat sub p) (sub.typ sub t)
     | Ppat_type s -> type_ ~loc ~attrs (map_loc sub s)
     | Ppat_lazy p -> lazy_ ~loc ~attrs (sub.pat sub p)
     | Ppat_unpack s -> unpack ~loc ~attrs (map_loc sub s)
     | Ppat_open (lid,p) -> open_ ~loc ~attrs (map_loc sub lid) (sub.pat sub p)
     | Ppat_exception p -> exception_ ~loc ~attrs (sub.pat sub p)
     | Ppat_extension x -> extension ~loc ~attrs (sub.extension sub x)
+    | Ppat_cons pl -> cons ~loc ~attrs (List.map (sub.pat sub) pl)
 end
 
 module CE = struct
   (* Value expressions for the class language *)
 
@@@@
     let attrs = sub.attributes sub attrs in
     match desc with
     | Pcf_inherit (o, ce, s) ->
         inherit_ ~loc ~attrs o (sub.class_expr sub ce)
           (map_opt (map_loc sub) s)
-    | Pcf_val (s, m, k) -> val_ ~loc ~attrs (map_loc sub s) m (map_kind sub k)
-    | Pcf_method (s, p, k) ->
-        method_ ~loc ~attrs (map_loc sub s) p (map_kind sub k)
+    | Pcf_val (s, mv, k) ->
+        val_ ~loc ~attrs (map_loc sub s) (Flag.map_mutable_virtual sub mv)
+          (map_kind sub k)
+    | Pcf_method (s, pv, k) ->
+        method_ ~loc ~attrs (map_loc sub s) (Flag.map_private_virtual sub pv)
+          (map_kind sub k)
     | Pcf_constraint (t1, t2) ->
         constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
     | Pcf_initializer e -> initializer_ ~loc ~attrs (sub.expr sub e)
     | Pcf_attribute x -> attribute ~loc (sub.attribute sub x)
     | Pcf_extension x -> extension ~loc ~attrs (sub.extension sub x)
@@@@
   let class_infos sub f {pci_virt; pci_params = pl; pci_name; pci_expr;
                          pci_loc; pci_attributes} =
     let loc = sub.location sub pci_loc in
     let attrs = sub.attributes sub pci_attributes in
     Ci.mk ~loc ~attrs
-     ~virt:pci_virt
+     ~virt:(Flag.map_virtual sub pci_virt)
      ~params:(List.map (map_fst (sub.typ sub)) pl)
       (map_loc sub pci_name)
       (f pci_expr)
 end
 
@@@@
     label_declaration =
       (fun this {pld_name; pld_type; pld_loc; pld_mutable; pld_attributes} ->
          Type.field
            (map_loc this pld_name)
            (this.typ this pld_type)
-           ~mut:pld_mutable
+           ~mut:(Flag.map_mutable this pld_mutable)
            ~loc:(this.location this pld_loc)
            ~attrs:(this.attributes this pld_attributes)
       );
 
     cases = (fun this l -> List.map (this.case this) l);
@@@@
 
     toplevel_phrase =
       (fun this -> function
          | Ptop_def s -> Ptop_def (this.structure this s)
          | Ptop_dir d -> Ptop_dir (this.toplevel_directive this d) );
-  }
-
-let extension_of_error {kind; main; sub} =
-  if kind <> Location.Report_error then
-    raise (Invalid_argument "extension_of_error: expected kind Report_error");
-  let str_of_pp pp_msg = Format.asprintf "%t" pp_msg in
-  let extension_of_sub sub =
-    { loc = sub.loc; txt = "ocaml.error" },
-    PStr ([Str.eval (Exp.constant
-                       (Pconst_string (str_of_pp sub.txt, sub.loc, None)))])
-  in
-  { loc = main.loc; txt = "ocaml.error" },
-  PStr (Str.eval (Exp.constant
-                    (Pconst_string (str_of_pp main.txt, main.loc, None))) ::
-        List.map (fun msg -> Str.extension (extension_of_sub msg)) sub)
-
-let attribute_of_warning loc s =
-  Attr.mk
-    {loc; txt = "ocaml.ppwarning" }
-    (PStr ([Str.eval ~loc (Exp.constant (Pconst_string (s, loc, None)))]))
-
-let cookies = ref String.Map.empty
-
-let get_cookie k =
-  try Some (String.Map.find k !cookies)
-  with Not_found -> None
-
-let set_cookie k v =
-  cookies := String.Map.add k v !cookies
-
-let tool_name_ref = ref "_none_"
-
-let tool_name () = !tool_name_ref
-
-
-module PpxContext = struct
-  open Longident
-  open Asttypes
-  open Ast_helper
-
-  let lid name = { txt = Lident name; loc = Location.none }
-
-  let make_string s = Exp.constant (Const.string s)
-
-  let make_bool x =
-    if x
-    then Exp.construct (lid "true") None
-    else Exp.construct (lid "false") None
-
-  let rec make_list f lst =
-    match lst with
-    | x :: rest ->
-      Exp.construct (lid "::") (Some (Exp.tuple [f x; make_list f rest]))
-    | [] ->
-      Exp.construct (lid "[]") None
-
-  let make_pair f1 f2 (x1, x2) =
-    Exp.tuple [f1 x1; f2 x2]
-
-  let make_option f opt =
-    match opt with
-    | Some x -> Exp.construct (lid "Some") (Some (f x))
-    | None   -> Exp.construct (lid "None") None
-
-  let get_cookies () =
-    lid "cookies",
-    make_list (make_pair make_string (fun x -> x))
-      (String.Map.bindings !cookies)
 
-  let mk fields =
-    {
-      attr_name = { txt = "ocaml.ppx.context"; loc = Location.none };
-      attr_payload = Parsetree.PStr [Str.eval (Exp.record fields None)];
-      attr_loc = Location.none
-    }
-
-  let make ~tool_name () =
-    let fields =
-      [
-        lid "tool_name",    make_string tool_name;
-        lid "include_dirs", make_list make_string !Clflags.include_dirs;
-        lid "load_path",    make_list make_string (Load_path.get_paths ());
-        lid "open_modules", make_list make_string !Clflags.open_modules;
-        lid "for_package",  make_option make_string !Clflags.for_package;
-        lid "debug",        make_bool !Clflags.debug;
-        lid "use_threads",  make_bool !Clflags.use_threads;
-        lid "use_vmthreads", make_bool false;
-        lid "recursive_types", make_bool !Clflags.recursive_types;
-        lid "principal", make_bool !Clflags.principal;
-        lid "transparent_modules", make_bool !Clflags.transparent_modules;
-        lid "unboxed_types", make_bool !Clflags.unboxed_types;
-        lid "unsafe_string", make_bool false; (* kept for compatibility *)
-        get_cookies ()
-      ]
-    in
-    mk fields
-
-  let get_fields = function
-    | PStr [{pstr_desc = Pstr_eval
-                 ({ pexp_desc = Pexp_record (fields, None) }, [])}] ->
-        fields
-    | _ ->
-        raise_errorf "Internal error: invalid [@@@ocaml.ppx.context] syntax"
-
-  let restore fields =
-    let field name payload =
-      let rec get_string = function
-        | { pexp_desc = Pexp_constant (Pconst_string (str, _, None)) } -> str
-        | _ -> raise_errorf "Internal error: invalid [@@@ocaml.ppx.context \
-                             { %s }] string syntax" name
-      and get_bool pexp =
-        match pexp with
-        | {pexp_desc = Pexp_construct ({txt = Longident.Lident "true"},
-                                       None)} ->
-            true
-        | {pexp_desc = Pexp_construct ({txt = Longident.Lident "false"},
-                                       None)} ->
-            false
-        | _ -> raise_errorf "Internal error: invalid [@@@ocaml.ppx.context \
-                             { %s }] bool syntax" name
-      and get_list elem = function
-        | {pexp_desc =
-             Pexp_construct ({txt = Longident.Lident "::"},
-                             Some {pexp_desc = Pexp_tuple [exp; rest]}) } ->
-            elem exp :: get_list elem rest
-        | {pexp_desc =
-             Pexp_construct ({txt = Longident.Lident "[]"}, None)} ->
-            []
-        | _ -> raise_errorf "Internal error: invalid [@@@ocaml.ppx.context \
-                             { %s }] list syntax" name
-      and get_pair f1 f2 = function
-        | {pexp_desc = Pexp_tuple [e1; e2]} ->
-            (f1 e1, f2 e2)
-        | _ -> raise_errorf "Internal error: invalid [@@@ocaml.ppx.context \
-                             { %s }] pair syntax" name
-      and get_option elem = function
-        | { pexp_desc =
-              Pexp_construct ({ txt = Longident.Lident "Some" }, Some exp) } ->
-            Some (elem exp)
-        | { pexp_desc =
-              Pexp_construct ({ txt = Longident.Lident "None" }, None) } ->
-            None
-        | _ -> raise_errorf "Internal error: invalid [@@@ocaml.ppx.context \
-                             { %s }] option syntax" name
-      in
-      match name with
-      | "tool_name" ->
-          tool_name_ref := get_string payload
-      | "include_dirs" ->
-          Clflags.include_dirs := get_list get_string payload
-      | "load_path" ->
-          ()
-      | "open_modules" ->
-          Clflags.open_modules := get_list get_string payload
-      | "for_package" ->
-          Clflags.for_package := get_option get_string payload
-      | "debug" ->
-          Clflags.debug := get_bool payload
-      | "use_threads" ->
-          Clflags.use_threads := get_bool payload
-      | "use_vmthreads" ->
-          if get_bool payload then
-            raise_errorf "Internal error: vmthreads not supported after 4.09.0"
-      | "recursive_types" ->
-          Clflags.recursive_types := get_bool payload
-      | "principal" ->
-          Clflags.principal := get_bool payload
-      | "transparent_modules" ->
-          Clflags.transparent_modules := get_bool payload
-      | "unboxed_types" ->
-          Clflags.unboxed_types := get_bool payload
-      | "cookies" ->
-          let l = get_list (get_pair get_string (fun x -> x)) payload in
-          cookies :=
-            List.fold_left
-              (fun s (k, v) -> String.Map.add k v s) String.Map.empty
-              l
-      | _ ->
-          ()
-    in
-    List.iter (function ({txt=Lident name}, x) -> field name x | _ -> ()) fields
-
-  let update_cookies fields =
-    let fields =
-      List.filter
-        (function ({txt=Lident "cookies"}, _) -> false | _ -> true)
-        fields
-    in
-    fields @ [get_cookies ()]
-end
-
-let ppx_context = PpxContext.make
-
-let extension_of_exn exn =
-  match error_of_exn exn with
-  | Some (`Ok error) -> extension_of_error error
-  | Some `Already_displayed ->
-      { loc = Location.none; txt = "ocaml.error" }, PStr []
-  | None -> raise exn
-
-
-let apply_lazy ~source ~target mapper =
-  let implem ast =
-    let fields, ast =
-      match ast with
-      | {pstr_desc = Pstr_attribute ({attr_name = {txt = "ocaml.ppx.context"};
-                                      attr_payload = x})} :: l ->
-          PpxContext.get_fields x, l
-      | _ -> [], ast
-    in
-    PpxContext.restore fields;
-    let ast =
-      try
-        let mapper = mapper () in
-        mapper.structure mapper ast
-      with exn ->
-        [{pstr_desc = Pstr_extension (extension_of_exn exn, []);
-          pstr_loc  = Location.none}]
-    in
-    let fields = PpxContext.update_cookies fields in
-    Str.attribute (PpxContext.mk fields) :: ast
-  in
-  let iface ast =
-    let fields, ast =
-      match ast with
-      | {psig_desc = Psig_attribute ({attr_name = {txt = "ocaml.ppx.context"};
-                                      attr_payload = x;
-                                      attr_loc = _})} :: l ->
-          PpxContext.get_fields x, l
-      | _ -> [], ast
-    in
-    PpxContext.restore fields;
-    let ast =
-      try
-        let mapper = mapper () in
-        mapper.signature mapper ast
-      with exn ->
-        [{psig_desc = Psig_extension (extension_of_exn exn, []);
-          psig_loc  = Location.none}]
-    in
-    let fields = PpxContext.update_cookies fields in
-    Sig.attribute (PpxContext.mk fields) :: ast
-  in
-
-  let ic = open_in_bin source in
-  let magic =
-    really_input_string ic (String.length Config.ast_impl_magic_number)
-  in
-
-  let rewrite transform =
-    Location.input_name := input_value ic;
-    let ast = input_value ic in
-    close_in ic;
-    let ast = transform ast in
-    let oc = open_out_bin target in
-    output_string oc magic;
-    output_value oc !Location.input_name;
-    output_value oc ast;
-    close_out oc
-  and fail () =
-    close_in ic;
-    failwith "Ast_mapper: OCaml version mismatch or malformed input";
-  in
-
-  if magic = Config.ast_impl_magic_number then
-    rewrite (implem : structure -> structure)
-  else if magic = Config.ast_intf_magic_number then
-    rewrite (iface : signature -> signature)
-  else fail ()
-
-let drop_ppx_context_str ~restore = function
-  | {pstr_desc = Pstr_attribute
-                   {attr_name = {Location.txt = "ocaml.ppx.context"};
-                    attr_payload = a;
-                    attr_loc = _}}
-    :: items ->
-      if restore then
-        PpxContext.restore (PpxContext.get_fields a);
-      items
-  | items -> items
-
-let drop_ppx_context_sig ~restore = function
-  | {psig_desc = Psig_attribute
-                   {attr_name = {Location.txt = "ocaml.ppx.context"};
-                    attr_payload = a;
-                    attr_loc = _}}
-    :: items ->
-      if restore then
-        PpxContext.restore (PpxContext.get_fields a);
-      items
-  | items -> items
-
-let add_ppx_context_str ~tool_name ast =
-  Ast_helper.Str.attribute (ppx_context ~tool_name ()) :: ast
-
-let add_ppx_context_sig ~tool_name ast =
-  Ast_helper.Sig.attribute (ppx_context ~tool_name ()) :: ast
-
-
-let apply ~source ~target mapper =
-  apply_lazy ~source ~target (fun () -> mapper)
-
-let run_main mapper =
-  try
-    let a = Sys.argv in
-    let n = Array.length a in
-    if n > 2 then
-      let mapper () =
-        try mapper (Array.to_list (Array.sub a 1 (n - 3)))
-        with exn ->
-          (* PR#6463 *)
-          let f _ _ = raise exn in
-          {default_mapper with structure = f; signature = f}
-      in
-      apply_lazy ~source:a.(n - 2) ~target:a.(n - 1) mapper
-    else begin
-      Printf.eprintf "Usage: %s [extra_args] <infile> <outfile>\n%!"
-                     Sys.executable_name;
-      exit 2
-    end
-  with exn ->
-    prerr_endline (Printexc.to_string exn);
-    exit 2
-
-let register_function = ref (fun _name f -> run_main f)
-let register name f = !register_function name f
+    repl_phrase =
+      (fun this p ->
+         { prepl_phrase= this.toplevel_phrase this p.prepl_phrase
+         ; prepl_output= p.prepl_output } );
+  }
--- parser-standard/ast_mapper.mli
+++ parser-extended/ast_mapper.mli
@@@@
   value_description: mapper -> value_description -> value_description;
   with_constraint: mapper -> with_constraint -> with_constraint;
   directive_argument: mapper -> directive_argument -> directive_argument;
   toplevel_directive: mapper -> toplevel_directive -> toplevel_directive;
   toplevel_phrase: mapper -> toplevel_phrase -> toplevel_phrase;
+  repl_phrase: mapper -> repl_phrase -> repl_phrase;
 }
 (** A mapper record implements one "method" per syntactic category,
     using an open recursion style: each method takes as its first
     argument the mapper to be applied to children in the syntax
     tree. *)
 
 val default_mapper: mapper
 (** A default mapper, which implements a "deep identity" mapping. *)
-
-(** {1 Apply mappers to compilation units} *)
-
-val tool_name: unit -> string
-(** Can be used within a ppx preprocessor to know which tool is
-    calling it ["ocamlc"], ["ocamlopt"], ["ocamldoc"], ["ocamldep"],
-    ["ocaml"], ...  Some global variables that reflect command-line
-    options are automatically synchronized between the calling tool
-    and the ppx preprocessor: {!Clflags.include_dirs},
-    {!Load_path}, {!Clflags.open_modules}, {!Clflags.for_package},
-    {!Clflags.debug}. *)
-
-
-val apply: source:string -> target:string -> mapper -> unit
-(** Apply a mapper (parametrized by the unit name) to a dumped
-    parsetree found in the [source] file and put the result in the
-    [target] file. The [structure] or [signature] field of the mapper
-    is applied to the implementation or interface.  *)
-
-val run_main: (string list -> mapper) -> unit
-(** Entry point to call to implement a standalone -ppx rewriter from a
-    mapper, parametrized by the command line arguments.  The current
-    unit name can be obtained from {!Location.input_name}.  This
-    function implements proper error reporting for uncaught
-    exceptions. *)
-
-(** {1 Registration API} *)
-
-val register_function: (string -> (string list -> mapper) -> unit) ref
-
-val register: string -> (string list -> mapper) -> unit
-(** Apply the [register_function].  The default behavior is to run the
-    mapper immediately, taking arguments from the process command
-    line.  This is to support a scenario where a mapper is linked as a
-    stand-alone executable.
-
-    It is possible to overwrite the [register_function] to define
-    "-ppx drivers", which combine several mappers in a single process.
-    Typically, a driver starts by defining [register_function] to a
-    custom implementation, then lets ppx rewriters (linked statically
-    or dynamically) register themselves, and then run all or some of
-    them.  It is also possible to have -ppx drivers apply rewriters to
-    only specific parts of an AST.
-
-    The first argument to [register] is a symbolic name to be used by
-    the ppx driver.  *)
-
-
-(** {1 Convenience functions to write mappers} *)
-
-val map_opt: ('a -> 'b) -> 'a option -> 'b option
-
-val extension_of_error: Location.error -> extension
-(** Encode an error into an 'ocaml.error' extension node which can be
-    inserted in a generated Parsetree.  The compiler will be
-    responsible for reporting the error. *)
-
-val attribute_of_warning: Location.t -> string -> attribute
-(** Encode a warning message into an 'ocaml.ppwarning' attribute which can be
-    inserted in a generated Parsetree.  The compiler will be
-    responsible for reporting the warning. *)
-
-(** {1 Helper functions to call external mappers} *)
-
-val add_ppx_context_str:
-    tool_name:string -> Parsetree.structure -> Parsetree.structure
-(** Extract information from the current environment and encode it
-    into an attribute which is prepended to the list of structure
-    items in order to pass the information to an external
-    processor. *)
-
-val add_ppx_context_sig:
-    tool_name:string -> Parsetree.signature -> Parsetree.signature
-(** Same as [add_ppx_context_str], but for signatures. *)
-
-val drop_ppx_context_str:
-    restore:bool -> Parsetree.structure -> Parsetree.structure
-(** Drop the ocaml.ppx.context attribute from a structure.  If
-    [restore] is true, also restore the associated data in the current
-    process. *)
-
-val drop_ppx_context_sig:
-    restore:bool -> Parsetree.signature -> Parsetree.signature
-(** Same as [drop_ppx_context_str], but for signatures. *)
-
-(** {1 Cookies} *)
-
-(** Cookies are used to pass information from a ppx processor to
-    a further invocation of itself, when called from the OCaml
-    toplevel (or other tools that support cookies). *)
-
-val set_cookie: string -> Parsetree.expression -> unit
-val get_cookie: string -> Parsetree.expression option
--- parser-standard/asttypes.mli
+++ parser-extended/asttypes.mli
@@@@
 type rec_flag = Nonrecursive | Recursive
 
 type direction_flag = Upto | Downto
 
 (* Order matters, used in polymorphic comparison *)
-type private_flag = Private | Public
+type private_flag = Private of Location.t | Public
 
-type mutable_flag = Immutable | Mutable
+type mutable_flag = Immutable | Mutable of Location.t
 
-type virtual_flag = Virtual | Concrete
+type virtual_flag = Virtual of Location.t | Concrete
+
+type private_virtual = {pv_priv: Location.t option; pv_virt: Location.t option}
+
+type mutable_virtual = {mv_mut: Location.t option; mv_virt: Location.t option}
 
 type override_flag = Override | Fresh
 
 type closed_flag = Closed | Open
 
+type obj_closed_flag =
+  | OClosed
+  | OOpen of Location.t
+
 type label = string
 
 type arg_label =
     Nolabel
   | Labelled of string (** [label:T -> ...] *)
@@@@
 type 'a loc = 'a Location.loc = {
   txt : 'a;
   loc : Location.t;
 }
 
-
-type variance =
-  | Covariant
-  | Contravariant
-  | NoVariance
-
-type injectivity =
-  | Injective
-  | NoInjectivity
+type variance_and_injectivity = string loc list
--- parser-standard/docstrings.ml
+++ parser-extended/docstrings.ml
@@@@
 
 let docs_attr ds =
   let open Parsetree in
   let body = ds.ds_body in
   let loc = ds.ds_loc in
+  let const = { pconst_desc= Pconst_string(body,loc,None); pconst_loc= loc } in
   let exp =
-    { pexp_desc = Pexp_constant (Pconst_string(body, loc, None));
+    { pexp_desc = Pexp_constant const;
       pexp_loc = loc;
       pexp_loc_stack = [];
       pexp_attributes = []; }
   in
   let item =
@@@@
 
 let text_attr ds =
   let open Parsetree in
   let body = ds.ds_body in
   let loc = ds.ds_loc in
+  let const = { pconst_desc= Pconst_string(body,loc,None); pconst_loc= loc } in
   let exp =
-    { pexp_desc = Pexp_constant (Pconst_string(body, loc, None));
+    { pexp_desc = Pexp_constant const;
       pexp_loc = loc;
       pexp_loc_stack = [];
       pexp_attributes = []; }
   in
   let item =
--- parser-standard/parser.mly
+++ parser-extended/parser.mly
@@@@
   Location.loc_start = startpos;
   Location.loc_end = endpos;
   Location.loc_ghost = true;
 }
 
+let mk_mv ?mut ?virt () = { mv_mut= mut; mv_virt= virt }
+let mk_pv ?priv ?virt () = { pv_priv= priv; pv_virt= virt }
+
+let mv_of_mut = function
+  | Immutable -> mk_mv ()
+  | Mutable mut -> mk_mv ~mut ()
+
+let pv_of_priv = function
+  | Public -> mk_pv ()
+  | Private priv -> mk_pv ~priv ()
+
+let mkvarinj s l = mkloc s (make_loc l)
 let mktyp ~loc ?attrs d = Typ.mk ~loc:(make_loc loc) ?attrs d
 let mkpat ~loc d = Pat.mk ~loc:(make_loc loc) d
 let mkexp ~loc d = Exp.mk ~loc:(make_loc loc) d
 let mkmty ~loc ?attrs d = Mty.mk ~loc:(make_loc loc) ?attrs d
 let mksig ~loc d = Sig.mk ~loc:(make_loc loc) d
 let mkmod ~loc ?attrs d = Mod.mk ~loc:(make_loc loc) ?attrs d
 let mkstr ~loc d = Str.mk ~loc:(make_loc loc) d
 let mkclass ~loc ?attrs d = Cl.mk ~loc:(make_loc loc) ?attrs d
 let mkcty ~loc ?attrs d = Cty.mk ~loc:(make_loc loc) ?attrs d
+let mkconst ~loc c = Const.mk ~loc:(make_loc loc) c
 
 let pstr_typext (te, ext) =
   (Pstr_typext te, ext)
 let pstr_primitive (vd, ext) =
   (Pstr_primitive vd, ext)
@@@@
   Ctf.mk ~loc:(make_loc loc) ?attrs ?docs d
 let mkcf ~loc ?attrs ?docs d =
   Cf.mk ~loc:(make_loc loc) ?attrs ?docs d
 
 let mkrhs rhs loc = mkloc rhs (make_loc loc)
-let ghrhs rhs loc = mkloc rhs (ghost_loc loc)
 
 let push_loc x acc =
   if x.Location.loc_ghost
   then acc
   else x :: acc
@@@@
   then String.sub f 1 (String.length f - 1)
   else "-" ^ f
 
 let mkuminus ~oploc name arg =
   match name, arg.pexp_desc with
-  | "-", Pexp_constant(Pconst_integer (n,m)) ->
-      Pexp_constant(Pconst_integer(neg_string n,m))
-  | ("-" | "-."), Pexp_constant(Pconst_float (f, m)) ->
-      Pexp_constant(Pconst_float(neg_string f, m))
+  | "-", Pexp_constant({pconst_desc= Pconst_integer (n,m); _} as c) ->
+      Pexp_constant({c with pconst_desc= Pconst_integer(neg_string n,m)})
+  | ("-" | "-."), Pexp_constant({pconst_desc= Pconst_float (f, m); _} as c) ->
+      Pexp_constant({c with pconst_desc= Pconst_float(neg_string f, m)})
   | _ ->
       Pexp_apply(mkoperator ~loc:oploc ("~" ^ name), [Nolabel, arg])
 
 let mkuplus ~oploc name arg =
   let desc = arg.pexp_desc in
   match name, desc with
-  | "+", Pexp_constant(Pconst_integer _)
-  | ("+" | "+."), Pexp_constant(Pconst_float _) -> desc
+  | "+", Pexp_constant({pconst_desc= Pconst_integer _; _})
+  | ("+" | "+."), Pexp_constant({pconst_desc= Pconst_float _; _}) -> desc
   | _ ->
       Pexp_apply(mkoperator ~loc:oploc ("~" ^ name), [Nolabel, arg])
 
 (* TODO define an abstraction boundary between locations-as-pairs
    and locations-as-Location.t; it should be clear when we move from
    one world to the other *)
 
-let mkexp_cons_desc consloc args =
-  Pexp_construct(mkrhs (Lident "::") consloc, Some args)
-let mkexp_cons ~loc consloc args =
-  mkexp ~loc (mkexp_cons_desc consloc args)
-
-let mkpat_cons_desc consloc args =
-  Ppat_construct(mkrhs (Lident "::") consloc, Some ([], args))
-let mkpat_cons ~loc consloc args =
-  mkpat ~loc (mkpat_cons_desc consloc args)
-
-let ghexp_cons_desc consloc args =
-  Pexp_construct(ghrhs (Lident "::") consloc, Some args)
-let ghpat_cons_desc consloc args =
-  Ppat_construct(ghrhs (Lident "::") consloc, Some ([], args))
-
-let rec mktailexp nilloc = let open Location in function
-    [] ->
-      let nil = ghloc ~loc:nilloc (Lident "[]") in
-      Pexp_construct (nil, None), nilloc
-  | e1 :: el ->
-      let exp_el, el_loc = mktailexp nilloc el in
-      let loc = (e1.pexp_loc.loc_start, snd el_loc) in
-      let arg = ghexp ~loc (Pexp_tuple [e1; ghexp ~loc:el_loc exp_el]) in
-      ghexp_cons_desc loc arg, loc
-
-let rec mktailpat nilloc = let open Location in function
-    [] ->
-      let nil = ghloc ~loc:nilloc (Lident "[]") in
-      Ppat_construct (nil, None), nilloc
-  | p1 :: pl ->
-      let pat_pl, el_loc = mktailpat nilloc pl in
-      let loc = (p1.ppat_loc.loc_start, snd el_loc) in
-      let arg = ghpat ~loc (Ppat_tuple [p1; ghpat ~loc:el_loc pat_pl]) in
-      ghpat_cons_desc loc arg, loc
-
 let mkstrexp e attrs =
   { pstr_desc = Pstr_eval (e, attrs); pstr_loc = e.pexp_loc }
 
 let mkexp_constraint ~loc e (t1, t2) =
   match t1, t2 with
@@@@
 let wrap_mksig_ext ~loc (item, ext) =
   wrap_sig_ext ~loc (mksig ~loc item) ext
 
 let mk_quotedext ~loc (id, idloc, str, strloc, delim) =
   let exp_id = mkloc id idloc in
-  let e = ghexp ~loc (Pexp_constant (Pconst_string (str, strloc, delim))) in
+  let const = Const.mk ~loc:strloc (Pconst_string (str, strloc, delim)) in
+  let e = ghexp ~loc (Pexp_constant const) in
   (exp_id, PStr [mkstrexp e []])
 
 let text_str pos = Str.text (rhs_text pos)
 let text_sig pos = Sig.text (rhs_text pos)
 let text_cstr pos = Cf.text (rhs_text pos)
@@@@
    semantic value is a pair of a list of [X]s and an optional [Y]. *)
 
 listx(delimiter, X, Y):
 | x = X ioption(delimiter)
     { [x], None }
-| x = X delimiter y = Y delimiter?
+| x = X delimiter y = mkloc(Y) delimiter?
     { [x], Some y }
 | x = X
   delimiter
   tail = listx(delimiter, X, Y)
     { let xs, y = tail in
@@@@
     Opn.mk id ~override ~attrs ~loc ~docs, ext
   }
 ;
 
 %inline open_dot_declaration: mkrhs(mod_longident)
-  { let loc = make_loc $loc($1) in
-    let me = Mod.ident ~loc $1 in
-    Opn.mk ~loc me }
+  { $1 }
 ;
 
 (* -------------------------------------------------------------------------- *)
 
 /* Module types */
@@@@
     attrs = attributes
     mutable_ = virtual_with_mutable_flag
     label = mkrhs(label) COLON ty = core_type
       { (label, mutable_, Cfk_virtual ty), attrs }
   | override_flag attributes mutable_flag mkrhs(label) EQUAL seq_expr
-      { ($4, $3, Cfk_concrete ($1, $6)), $2 }
+      { ($4, mv_of_mut $3, Cfk_concrete ($1, $6)), $2 }
   | override_flag attributes mutable_flag mkrhs(label) type_constraint
     EQUAL seq_expr
       { let e = mkexp_constraint ~loc:$sloc $7 $5 in
-        ($4, $3, Cfk_concrete ($1, e)), $2
+        ($4, mv_of_mut $3, Cfk_concrete ($1, e)), $2
       }
 ;
 method_:
     no_override_flag
     attrs = attributes
@@@@
     label = mkrhs(label) COLON ty = poly_type
       { (label, private_, Cfk_virtual ty), attrs }
   | override_flag attributes private_flag mkrhs(label) strict_binding
       { let e = $5 in
         let loc = Location.(e.pexp_loc.loc_start, e.pexp_loc.loc_end) in
-        ($4, $3,
+        ($4, pv_of_priv $3,
         Cfk_concrete ($1, ghexp ~loc (Pexp_poly (e, None)))), $2 }
   | override_flag attributes private_flag mkrhs(label)
     COLON poly_type EQUAL seq_expr
       { let poly_exp =
           let loc = ($startpos($6), $endpos($8)) in
           ghexp ~loc (Pexp_poly($8, Some $6)) in
-        ($4, $3, Cfk_concrete ($1, poly_exp)), $2 }
+        ($4, pv_of_priv $3, Cfk_concrete ($1, poly_exp)), $2 }
   | override_flag attributes private_flag mkrhs(label) COLON TYPE lident_list
     DOT core_type EQUAL seq_expr
       { let poly_exp_loc = ($startpos($7), $endpos($11)) in
         let poly_exp =
           let exp, poly =
             (* it seems odd to use the global ~loc here while poly_exp_loc
                is tighter, but this is what ocamlyacc does;
                TODO improve parser.mly *)
             wrap_type_annotation ~loc:$sloc $7 $9 $11 in
           ghexp ~loc:poly_exp_loc (Pexp_poly(exp, Some poly)) in
-        ($4, $3,
+        ($4, pv_of_priv $3,
         Cfk_concrete ($1, poly_exp)), $2 }
 ;
 
 /* Class types */
 
@@@@
   | mkcty(
       label = arg_label
       domain = tuple_type
       MINUSGREATER
       codomain = class_type
-        { Pcty_arrow(label, domain, codomain) }
+        { let arrow_type = {
+            pap_label = label;
+            pap_loc = make_loc $sloc;
+            pap_type = domain;
+          }
+          in
+          let params, codomain =
+            match codomain.pcty_attributes, codomain.pcty_desc with
+            | [], Pcty_arrow (params, codomain) -> params, codomain
+            | _, _ -> [], codomain
+          in
+          Pcty_arrow (arrow_type :: params, codomain) }
     ) { $1 }
  ;
 class_signature:
     mkcty(
       tys = actual_class_parameters cid = mkrhs(clty_longident)
@@@@
   | VAL attributes value_type post_item_attributes
       { let docs = symbol_docs $sloc in
         mkctf ~loc:$sloc (Pctf_val $3) ~attrs:($2@$4) ~docs }
   | METHOD attributes private_virtual_flags mkrhs(label) COLON poly_type
     post_item_attributes
-      { let (p, v) = $3 in
-        let docs = symbol_docs $sloc in
-        mkctf ~loc:$sloc (Pctf_method ($4, p, v, $6)) ~attrs:($2@$7) ~docs }
+      { let docs = symbol_docs $sloc in
+        mkctf ~loc:$sloc (Pctf_method ($4, $3, $6)) ~attrs:($2@$7) ~docs }
   | CONSTRAINT attributes constrain_field post_item_attributes
       { let docs = symbol_docs $sloc in
         mkctf ~loc:$sloc (Pctf_constraint $3) ~attrs:($2@$4) ~docs }
   | item_extension post_item_attributes
       { let docs = symbol_docs $sloc in
@@@@
   flags = mutable_virtual_flags
   label = mkrhs(label)
   COLON
   ty = core_type
   {
-    let mut, virt = flags in
-    label, mut, virt, ty
+    label, flags, ty
   }
 ;
 %inline constrain:
     core_type EQUAL core_type
     { $1, $3, make_loc $sloc }
@@@@
       { let (pbop_pat, pbop_exp, rev_ands) = bindings in
         let ands = List.rev rev_ands in
         let pbop_loc = make_loc $sloc in
         let let_ = {pbop_op; pbop_pat; pbop_exp; pbop_loc} in
         mkexp ~loc:$sloc (Pexp_letop{ let_; ands; body}) }
-  | expr COLONCOLON expr
-      { mkexp_cons ~loc:$sloc $loc($2) (ghexp ~loc:$sloc (Pexp_tuple[$1;$3])) }
+  | expr COLONCOLON e = expr
+      { match e.pexp_desc, e.pexp_attributes with
+        | Pexp_cons l, [] -> Exp.cons ~loc:(make_loc $sloc) ($1 :: l)
+        | _ -> Exp.cons ~loc:(make_loc $sloc) [$1; e] }
   | mkrhs(label) LESSMINUS expr
       { mkexp ~loc:$sloc (Pexp_setinstvar($1, $3)) }
   | simple_expr DOT mkrhs(label_longident) LESSMINUS expr
       { mkexp ~loc:$sloc (Pexp_setfield($1, $3, $5)) }
   | indexop_expr(DOT, seq_expr, LESSMINUS v=expr {Some v})
@@@@
   | LET EXCEPTION ext_attributes let_exception_declaration IN seq_expr
       { Pexp_letexception($4, $6), $3 }
   | LET OPEN override_flag ext_attributes module_expr IN seq_expr
       { let open_loc = make_loc ($startpos($2), $endpos($5)) in
         let od = Opn.mk $5 ~override:$3 ~loc:open_loc in
-        Pexp_open(od, $7), $4 }
+        Pexp_letopen(od, $7), $4 }
   | FUNCTION ext_attributes match_cases
       { Pexp_function $3, $2 }
   | FUN ext_attributes labeled_simple_pattern fun_def
       { let (l,o,p) = $3 in
         Pexp_fun(l, o, p, $4), $2 }
@@@@
       mkexp_attrs ~loc:$sloc desc attrs }
   | mkexp(simple_expr_)
       { $1 }
 ;
 %inline simple_expr_attrs:
-  | BEGIN ext = ext attrs = attributes e = seq_expr END
-      { e.pexp_desc, (ext, attrs @ e.pexp_attributes) }
+  | BEGIN ext_attributes seq_expr END
+      { Pexp_beginend $3, $2 }
   | BEGIN ext_attributes END
       { Pexp_construct (mkloc (Lident "()") (make_loc $sloc), None), $2 }
   | BEGIN ext_attributes seq_expr error
       { unclosed "begin" $loc($1) "end" $loc($4) }
   | NEW ext_attributes mkrhs(class_longident)
@@@@
         Pexp_open(od, mkexp ~loc:($startpos($3), $endpos) (Pexp_array [])) }
   | mod_longident DOT
     LBRACKETBAR expr_semi_list error
       { unclosed "[|" $loc($3) "|]" $loc($5) }
   | LBRACKET expr_semi_list RBRACKET
-      { fst (mktailexp $loc($3) $2) }
+      { Pexp_list $2 }
   | LBRACKET expr_semi_list error
       { unclosed "[" $loc($1) "]" $loc($3) }
   | od=open_dot_declaration DOT LBRACKET expr_semi_list RBRACKET
-      { let list_exp =
-          (* TODO: review the location of list_exp *)
-          let tail_exp, _tail_loc = mktailexp $loc($5) $4 in
-          mkexp ~loc:($startpos($3), $endpos) tail_exp in
+      { let list_exp = mkexp ~loc:($startpos($3), $endpos) (Pexp_list $4) in
         Pexp_open(od, list_exp) }
   | od=open_dot_declaration DOT mkrhs(LBRACKET RBRACKET {Lident "[]"})
       { Pexp_open(od, mkexp ~loc:$loc($3) (Pexp_construct($3, None))) }
   | mod_longident DOT
     LBRACKET expr_semi_list error
@@@@
     pattern_(pattern_no_exn)
       { $1 }
 ;
 
 %inline pattern_(self):
-  | self COLONCOLON pattern
-      { mkpat_cons ~loc:$sloc $loc($2) (ghpat ~loc:$sloc (Ppat_tuple[$1;$3])) }
+  | self COLONCOLON p = pattern
+      { match p.ppat_desc, p.ppat_attributes with
+        | Ppat_cons pl, [] -> Pat.cons ~loc:(make_loc $sloc) ($1 :: pl)
+        | _ -> Pat.cons ~loc:(make_loc $sloc) [$1; p] }
   | self attribute
       { Pat.attr $1 $2 }
   | pattern_gen
       { $1 }
   | mkpat(
@@@@
       { let (fields, closed) = $2 in
         Ppat_record(fields, closed) }
     | LBRACE record_pat_content error
       { unclosed "{" $loc($1) "}" $loc($3) }
     | LBRACKET pattern_semi_list RBRACKET
-      { fst (mktailpat $loc($3) $2) }
+      { Ppat_list $2 }
     | LBRACKET pattern_semi_list error
       { unclosed "[" $loc($1) "]" $loc($3) }
     | LBRACKETBAR pattern_semi_list BARRBRACKET
       { Ppat_array $2 }
     | LBRACKETBAR BARRBRACKET
@@@@
 (* A label-pattern list is a nonempty list of label-pattern pairs, optionally
    followed with an UNDERSCORE, separated-or-terminated with semicolons. *)
 %inline record_pat_content:
   listx(SEMI, record_pat_field, UNDERSCORE)
     { let fields, closed = $1 in
-      let closed = match closed with Some () -> Open | None -> Closed in
+      let closed =
+        match closed with
+        | None -> OClosed
+        | Some { txt = (); loc } -> OOpen loc
+      in
       fields, closed }
 ;
 %inline record_pat_field:
   label = mkrhs(label_longident)
   octy = preceded(COLON, core_type)?
@@@@
       { Ptyp_any }
   ) { $1 }
 ;
 
 type_variance:
-    /* empty */                             { NoVariance, NoInjectivity }
-  | PLUS                                    { Covariant, NoInjectivity }
-  | MINUS                                   { Contravariant, NoInjectivity }
-  | BANG                                    { NoVariance, Injective }
-  | PLUS BANG | BANG PLUS                   { Covariant, Injective }
-  | MINUS BANG | BANG MINUS                 { Contravariant, Injective }
+    /* empty */                             { [] }
+  | PLUS                                    { [ mkvarinj "+" $sloc ] }
+  | MINUS                                   { [ mkvarinj "-" $sloc ] }
+  | BANG                                    { [ mkvarinj "!" $sloc ] }
+  | PLUS BANG   { [ mkvarinj "+" $loc($1); mkvarinj "!" $loc($2) ] }
+  | BANG PLUS   { [ mkvarinj "!" $loc($1); mkvarinj "+" $loc($2) ] }
+  | MINUS BANG  { [ mkvarinj "-" $loc($1); mkvarinj "!" $loc($2) ] }
+  | BANG MINUS  { [ mkvarinj "!" $loc($1); mkvarinj "-" $loc($2) ] }
   | INFIXOP2
-      { if $1 = "+!" then Covariant, Injective else
-        if $1 = "-!" then Contravariant, Injective else
-        expecting $loc($1) "type_variance" }
+      { if ($1 = "+!") || ($1 = "-!") then [ mkvarinj $1 $sloc ]
+        else expecting $loc($1) "type_variance" }
   | PREFIXOP
-      { if $1 = "!+" then Covariant, Injective else
-        if $1 = "!-" then Contravariant, Injective else
-        expecting $loc($1) "type_variance" }
+      { if ($1 = "!+") || ($1 = "!-") then [ mkvarinj $1 $sloc ]
+        else expecting $loc($1) "type_variance" }
 ;
 
 (* A sequence of constructor declarations is either a single BAR, which
    means that the list is empty, or a nonempty BAR-separated list of
    declarations, with an optional leading BAR. *)
@@@@
   | MODULE TYPE l=mkrhs(mty_longident) COLONEQUAL rhs=module_type
       { Pwith_modtypesubst (l, rhs) }
 ;
 with_type_binder:
     EQUAL          { Public }
-  | EQUAL PRIVATE  { Private }
+  | EQUAL PRIVATE  { Private (make_loc $loc($2)) }
 ;
 
 /* Polymorphic types */
 
 %inline typevar:
@@@@
   | mktyp(
       label = arg_label
       domain = extra_rhs(tuple_type)
       MINUSGREATER
       codomain = function_type
-        { Ptyp_arrow(label, domain, codomain) }
+        { let arrow_type = {
+            pap_label = label;
+            pap_loc = make_loc $sloc;
+            pap_type = domain;
+          }
+          in
+          let params, codomain =
+            match codomain.ptyp_attributes, codomain.ptyp_desc with
+            | [], Ptyp_arrow (params, codomain) -> params, codomain
+            | _, _ -> [], codomain
+          in
+          Ptyp_arrow (arrow_type :: params, codomain)
+        }
     )
     { $1 }
 ;
 %inline arg_label:
   | label = optlabel
@@@@
       tid = mkrhs(type_longident)
         { Ptyp_constr(tid, tys) }
     | LESS meth_list GREATER
         { let (f, c) = $2 in Ptyp_object (f, c) }
     | LESS GREATER
-        { Ptyp_object ([], Closed) }
+        { Ptyp_object ([], OClosed) }
     | tys = actual_type_parameters
       HASH
       cid = mkrhs(clty_longident)
         { Ptyp_class(cid, tys) }
     | LBRACKET tag_field RBRACKET
@@@@
     head = field_semi         tail = meth_list
   | head = inherit_field SEMI tail = meth_list
       { let (f, c) = tail in (head :: f, c) }
   | head = field_semi
   | head = inherit_field SEMI
-      { [head], Closed }
+      { [head], OClosed }
   | head = field
   | head = inherit_field
-      { [head], Closed }
+      { [head], OClosed }
   | DOTDOT
-      { [], Open }
+      { [], OOpen (make_loc $sloc) }
 ;
 %inline field:
   mkrhs(label) COLON poly_type_no_attr attributes
     { let info = symbol_info $endpos in
       let attrs = add_info_attrs info $4 in
@@@@
 ;
 
 /* Constants */
 
 constant:
-  | INT          { let (n, m) = $1 in Pconst_integer (n, m) }
-  | CHAR         { Pconst_char $1 }
-  | STRING       { let (s, strloc, d) = $1 in Pconst_string (s, strloc, d) }
-  | FLOAT        { let (f, m) = $1 in Pconst_float (f, m) }
+  | INT          { let (n, m) = $1 in
+                   mkconst ~loc:$sloc (Pconst_integer (n, m)) }
+  | CHAR         { mkconst ~loc:$sloc (Pconst_char $1) }
+  | STRING       { let (s, strloc, d) = $1 in
+                   mkconst ~loc:$sloc (Pconst_string (s,strloc,d)) }
+  | FLOAT        { let (f, m) = $1 in
+                   mkconst ~loc:$sloc (Pconst_float (f, m)) }
 ;
 signed_constant:
     constant     { $1 }
-  | MINUS INT    { let (n, m) = $2 in Pconst_integer("-" ^ n, m) }
-  | MINUS FLOAT  { let (f, m) = $2 in Pconst_float("-" ^ f, m) }
-  | PLUS INT     { let (n, m) = $2 in Pconst_integer (n, m) }
-  | PLUS FLOAT   { let (f, m) = $2 in Pconst_float(f, m) }
+  | MINUS INT    { let (n, m) = $2 in
+                   mkconst ~loc:$sloc (Pconst_integer("-" ^ n, m)) }
+  | MINUS FLOAT  { let (f, m) = $2 in
+                   mkconst ~loc:$sloc (Pconst_float("-" ^ f, m)) }
+  | PLUS INT     { let (n, m) = $2 in
+                   mkconst ~loc:$sloc (Pconst_integer (n, m)) }
+  | PLUS FLOAT   { let (f, m) = $2 in
+                   mkconst ~loc:$sloc (Pconst_float(f, m)) }
 ;
 
 /* Identifiers and long identifiers */
 
 ident:
@@@@
   inline_private_flag
     { $1 }
 ;
 %inline inline_private_flag:
     /* empty */                                 { Public }
-  | PRIVATE                                     { Private }
+  | PRIVATE                                     { Private (make_loc $sloc) }
 ;
 mutable_flag:
     /* empty */                                 { Immutable }
-  | MUTABLE                                     { Mutable }
+  | MUTABLE                                     { Mutable (make_loc $sloc) }
 ;
 virtual_flag:
     /* empty */                                 { Concrete }
-  | VIRTUAL                                     { Virtual }
+  | VIRTUAL                                     { Virtual (make_loc $sloc) }
 ;
 mutable_virtual_flags:
     /* empty */
-      { Immutable, Concrete }
+      { mk_mv () }
   | MUTABLE
-      { Mutable, Concrete }
+      { mk_mv ~mut:(make_loc $sloc) () }
   | VIRTUAL
-      { Immutable, Virtual }
+      { mk_mv ~virt:(make_loc $sloc) () }
   | MUTABLE VIRTUAL
+      { mk_mv ~mut:(make_loc $loc($1)) ~virt:(make_loc $loc($2)) () }
   | VIRTUAL MUTABLE
-      { Mutable, Virtual }
+      { mk_mv ~virt:(make_loc $loc($1)) ~mut:(make_loc $loc($2)) () }
 ;
 private_virtual_flags:
-    /* empty */  { Public, Concrete }
-  | PRIVATE { Private, Concrete }
-  | VIRTUAL { Public, Virtual }
-  | PRIVATE VIRTUAL { Private, Virtual }
-  | VIRTUAL PRIVATE { Private, Virtual }
+    /* empty */
+      { mk_pv () }
+  | PRIVATE
+      { mk_pv ~priv:(make_loc $sloc) () }
+  | VIRTUAL
+      { mk_pv ~virt:(make_loc $sloc) () }
+  | PRIVATE VIRTUAL
+      { mk_pv ~priv:(make_loc $loc($1)) ~virt:(make_loc $loc($2)) () }
+  | VIRTUAL PRIVATE
+      { mk_pv ~virt:(make_loc $loc($1)) ~priv:(make_loc $loc($2)) () }
 ;
 (* This nonterminal symbol indicates the definite presence of a VIRTUAL
    keyword and the possible presence of a MUTABLE keyword. *)
 virtual_with_mutable_flag:
-  | VIRTUAL { Immutable }
-  | MUTABLE VIRTUAL { Mutable }
-  | VIRTUAL MUTABLE { Mutable }
+  | VIRTUAL
+      { mk_mv ~virt:(make_loc $sloc) () }
+  | MUTABLE VIRTUAL
+      { mk_mv ~mut:(make_loc $loc($1)) ~virt:(make_loc $loc($2)) () }
+  | VIRTUAL MUTABLE
+      { mk_mv ~virt:(make_loc $loc($1)) ~mut:(make_loc $loc($2)) () }
 ;
 (* This nonterminal symbol indicates the definite presence of a VIRTUAL
    keyword and the possible presence of a PRIVATE keyword. *)
 virtual_with_private_flag:
-  | VIRTUAL { Public }
-  | PRIVATE VIRTUAL { Private }
-  | VIRTUAL PRIVATE { Private }
+  | VIRTUAL
+      { mk_pv ~virt:(make_loc $sloc) () }
+  | PRIVATE VIRTUAL
+      { mk_pv ~priv:(make_loc $loc($1)) ~virt:(make_loc $loc($2)) () }
+  | VIRTUAL PRIVATE
+      { mk_pv ~virt:(make_loc $loc($1)) ~priv:(make_loc $loc($2)) () }
 ;
 %inline no_override_flag:
     /* empty */                                 { Fresh }
 ;
 %inline override_flag:
--- parser-standard/parsetree.mli
+++ parser-extended/parsetree.mli
@@@@
 
 *)
 
 open Asttypes
 
-type constant =
+type constant_desc =
   | Pconst_integer of string * char option
       (** Integer constants such as [3] [3l] [3L] [3n].
 
      Suffixes [[g-z][G-Z]] are accepted by the parser.
      Suffixes except ['l'], ['L'] and ['n'] are rejected by the typechecker
@@@@
 
      Suffixes [g-z][G-Z] are accepted by the parser.
      Suffixes are rejected by the typechecker.
   *)
 
+type constant = {
+  pconst_desc : constant_desc;
+  pconst_loc : Location.t;
+}
+
 type location_stack = Location.t list
 
 (** {1 Extension points} *)
 
 type attribute = {
@@@@
      ptyp_loc: Location.t;
      ptyp_loc_stack: location_stack;
      ptyp_attributes: attributes;  (** [... [\@id1] [\@id2]] *)
     }
 
+and arrow_param =
+  {
+    pap_label: arg_label;
+    pap_loc: Location.t; (** Location also including the codomain. *)
+    pap_type: core_type;
+  }
+
 and core_type_desc =
   | Ptyp_any  (** [_] *)
   | Ptyp_var of string  (** A type variable such as ['a] *)
-  | Ptyp_arrow of arg_label * core_type * core_type
+  | Ptyp_arrow of arrow_param list * core_type
       (** [Ptyp_arrow(lbl, T1, T2)] represents:
             - [T1 -> T2]    when [lbl] is
                                      {{!Asttypes.arg_label.Nolabel}[Nolabel]},
             - [~l:T1 -> T2] when [lbl] is
                                      {{!Asttypes.arg_label.Labelled}[Labelled]},
@@@@
       (** [Ptyp_constr(lident, l)] represents:
             - [tconstr]               when [l=[]],
             - [T tconstr]             when [l=[T]],
             - [(T1, ..., Tn) tconstr] when [l=[T1 ; ... ; Tn]].
          *)
-  | Ptyp_object of object_field list * closed_flag
+  | Ptyp_object of object_field list * obj_closed_flag
       (** [Ptyp_object([ l1:T1; ...; ln:Tn ], flag)] represents:
             - [< l1:T1; ...; ln:Tn >]     when [flag] is
                                        {{!Asttypes.closed_flag.Closed}[Closed]},
             - [< l1:T1; ...; ln:Tn; .. >] when [flag] is
                                            {{!Asttypes.closed_flag.Open}[Open]}.
@@@@
   | Ppat_variant of label * pattern option
       (** [Ppat_variant(`A, pat)] represents:
             - [`A]   when [pat] is [None],
             - [`A P] when [pat] is [Some P]
          *)
-  | Ppat_record of (Longident.t loc * pattern) list * closed_flag
+  | Ppat_record of (Longident.t loc * pattern) list * obj_closed_flag
       (** [Ppat_record([(l1, P1) ; ... ; (ln, Pn)], flag)] represents:
             - [{ l1=P1; ...; ln=Pn }]
                  when [flag] is {{!Asttypes.closed_flag.Closed}[Closed]}
             - [{ l1=P1; ...; ln=Pn; _}]
                  when [flag] is {{!Asttypes.closed_flag.Open}[Open]}
 
            Invariant: [n > 0]
          *)
   | Ppat_array of pattern list  (** Pattern [[| P1; ...; Pn |]] *)
+  | Ppat_list of pattern list  (** Pattern [[ P1; ...; Pn ]] *)
   | Ppat_or of pattern * pattern  (** Pattern [P1 | P2] *)
   | Ppat_constraint of pattern * core_type  (** Pattern [(P : T)] *)
   | Ppat_type of Longident.t loc  (** Pattern [#tconst] *)
   | Ppat_lazy of pattern  (** Pattern [lazy P] *)
   | Ppat_unpack of string option loc
@@@@
            [Ppat_constraint(Ppat_unpack(Some "P"), Ptyp_package S)]
          *)
   | Ppat_exception of pattern  (** Pattern [exception P] *)
   | Ppat_extension of extension  (** Pattern [[%id]] *)
   | Ppat_open of Longident.t loc * pattern  (** Pattern [M.(P)] *)
+  | Ppat_cons of pattern list  (** Pattern [P1 :: ... :: Pn] *)
 
 (** {2 Value expressions} *)
 
 and expression =
     {
@@@@
          *)
   | Pexp_field of expression * Longident.t loc  (** [E.l] *)
   | Pexp_setfield of expression * Longident.t loc * expression
       (** [E1.l <- E2] *)
   | Pexp_array of expression list  (** [[| E1; ...; En |]] *)
+  | Pexp_list of expression list  (** [[ E1; ...; En ]] *)
   | Pexp_ifthenelse of expression * expression * expression option
       (** [if E1 then E2 else E3] *)
   | Pexp_sequence of expression * expression  (** [E1; E2] *)
   | Pexp_while of expression * expression  (** [while E1 do E2 done] *)
   | Pexp_for of pattern * expression * expression * direction_flag * expression
@@@@
   | Pexp_pack of module_expr
       (** [(module ME)].
 
            [(module ME : S)] is represented as
            [Pexp_constraint(Pexp_pack ME, Ptyp_package S)] *)
-  | Pexp_open of open_declaration * expression
-      (** - [M.(E)]
-            - [let open M in E]
-            - [let open! M in E] *)
+  | Pexp_open of Longident.t loc * expression  (** [M.(E)] *)
+  | Pexp_letopen of open_declaration * expression
+      (** - [let open M in E]
+          - [let open! M in E] *)
   | Pexp_letop of letop
       (** - [let* P = E0 in E1]
             - [let* P0 = E00 and* P1 = E01 in E1] *)
   | Pexp_extension of extension  (** [[%id]] *)
   | Pexp_unreachable  (** [.] *)
   | Pexp_hole  (** [_] *)
+  | Pexp_beginend of expression  (** [begin E end] *)
+  | Pexp_cons of expression list  (** [E1 :: ... :: En] *)
 
 and case =
     {
      pc_lhs: pattern;
      pc_guard: expression option;
@@@@
 (** {2 Type declarations} *)
 
 and type_declaration =
     {
      ptype_name: string loc;
-     ptype_params: (core_type * (variance * injectivity)) list;
+     ptype_params: (core_type * variance_and_injectivity) list;
       (** [('a1,...'an) t] *)
      ptype_cstrs: (core_type * core_type * Location.t) list;
       (** [... constraint T1=T1'  ... constraint Tn=Tn'] *)
      ptype_kind: type_kind;
      ptype_private: private_flag;  (** for [= private ...] *)
@@@@
 *)
 
 and type_extension =
     {
      ptyext_path: Longident.t loc;
-     ptyext_params: (core_type * (variance * injectivity)) list;
+     ptyext_params: (core_type * variance_and_injectivity) list;
      ptyext_constructors: extension_constructor list;
      ptyext_private: private_flag;
      ptyext_loc: Location.t;
      ptyext_attributes: attributes;  (** ... [\@\@id1] [\@\@id2] *)
     }
@@@@
 and class_type_desc =
   | Pcty_constr of Longident.t loc * core_type list
       (** - [c]
             - [['a1, ..., 'an] c] *)
   | Pcty_signature of class_signature  (** [object ... end] *)
-  | Pcty_arrow of arg_label * core_type * class_type
+  | Pcty_arrow of arrow_param list * class_type
       (** [Pcty_arrow(lbl, T, CT)] represents:
             - [T -> CT]
                      when [lbl] is {{!Asttypes.arg_label.Nolabel}[Nolabel]},
             - [~l:T -> CT]
                      when [lbl] is {{!Asttypes.arg_label.Labelled}[Labelled l]},
@@@@
      pctf_attributes: attributes;  (** [... [\@\@id1] [\@\@id2]] *)
     }
 
 and class_type_field_desc =
   | Pctf_inherit of class_type  (** [inherit CT] *)
-  | Pctf_val of (label loc * mutable_flag * virtual_flag * core_type)
+  | Pctf_val of (label loc * mutable_virtual * core_type)
       (** [val x: T] *)
-  | Pctf_method of (label loc * private_flag * virtual_flag * core_type)
+  | Pctf_method of (label loc * private_virtual * core_type)
       (** [method x: T]
 
             Note: [T] can be a {{!core_type_desc.Ptyp_poly}[Ptyp_poly]}.
         *)
   | Pctf_constraint of (core_type * core_type)  (** [constraint T1 = T2] *)
@@@@
   | Pctf_extension of extension  (** [[%%id]] *)
 
 and 'a class_infos =
     {
      pci_virt: virtual_flag;
-     pci_params: (core_type * (variance * injectivity)) list;
+     pci_params: (core_type * variance_and_injectivity) list;
      pci_name: string loc;
      pci_expr: 'a;
      pci_loc: Location.t;
      pci_attributes: attributes;  (** [... [\@\@id1] [\@\@id2]] *)
     }
@@@@
                     and [s] is [None],
             - [inherit! CE as x]
                    when [flag] is {{!Asttypes.override_flag.Override}[Override]}
                     and [s] is [Some x]
   *)
-  | Pcf_val of (label loc * mutable_flag * class_field_kind)
+  | Pcf_val of (label loc * mutable_virtual * class_field_kind)
       (** [Pcf_val(x,flag, kind)] represents:
             - [val x = E]
        when [flag] is {{!Asttypes.mutable_flag.Immutable}[Immutable]}
         and [kind] is {{!class_field_kind.Cfk_concrete}[Cfk_concrete(Fresh, E)]}
             - [val virtual x: T]
@@@@
         and [kind] is {{!class_field_kind.Cfk_concrete}[Cfk_concrete(Fresh, E)]}
             - [val mutable virtual x: T]
        when [flag] is {{!Asttypes.mutable_flag.Mutable}[Mutable]}
         and [kind] is {{!class_field_kind.Cfk_virtual}[Cfk_virtual(T)]}
   *)
-  | Pcf_method of (label loc * private_flag * class_field_kind)
+  | Pcf_method of (label loc * private_virtual * class_field_kind)
       (** - [method x = E]
                         ([E] can be a {{!expression_desc.Pexp_poly}[Pexp_poly]})
             - [method virtual x: T]
                         ([T] can be a {{!core_type_desc.Ptyp_poly}[Ptyp_poly]})
   *)
@@@@
 and directive_argument_desc =
   | Pdir_string of string
   | Pdir_int of string * char option
   | Pdir_ident of Longident.t
   | Pdir_bool of bool
+
+type repl_phrase =
+  {
+    prepl_phrase : toplevel_phrase;
+    prepl_output : string;
+  }
--- parser-standard/printast.ml
+++ parser-extended/printast.ml
@@@@
   if l.pos_lnum = -1
   then fprintf f "%s[%d]" fname l.pos_cnum
   else fprintf f "%s[%d,%d+%d]" fname l.pos_lnum l.pos_bol
                (l.pos_cnum - l.pos_bol)
 
+let curr_indent : int ref = ref 0
+
+let line i f s (*...*) =
+  curr_indent := i;
+  fprintf f "%s" (String.make ((2*i) mod 72) ' ');
+  fprintf f s (*...*)
+
+type cmts =
+  { before: Location.t -> string list option
+  ; within: Location.t -> string list option
+  ; after: Location.t -> string list option }
+
+let cmts : cmts option ref = ref None
+
+let fmt_cmts i f lbl = function
+  | Some cmts ->
+      let fmt_cmt f s =
+        line i f "%s: (*%s*)" lbl s
+      in
+      fprintf f "\n";
+      pp_print_list fmt_cmt f cmts
+  | None -> ()
+
 let fmt_location f loc =
   if not !Clflags.locations then ()
   else begin
     let p_2nd_name = loc.loc_start.pos_fname <> loc.loc_end.pos_fname in
     fprintf f "(%a..%a)" (fmt_position true) loc.loc_start
                          (fmt_position p_2nd_name) loc.loc_end;
     if loc.loc_ghost then fprintf f " ghost";
+    match !cmts with
+    | None -> ()
+    | Some {before; within; after} -> (
+        match before loc, within loc, after loc with
+        | None, None, None -> ()
+        | b, w, a ->
+            let i = !curr_indent in
+            fprintf f "\n";
+            line i f "comments";
+            let i = i+1 in
+            fmt_cmts i f "before" b;
+            fmt_cmts i f "within" w;
+            fmt_cmts i f " after" a )
   end
 
 let rec fmt_longident_aux f x =
   match x with
   | Longident.Lident (s) -> fprintf f "%s" s
@@@@
 
 let fmt_char_option f = function
   | None -> fprintf f "None"
   | Some c -> fprintf f "Some %c" c
 
-let fmt_constant f x =
-  match x with
-  | Pconst_integer (i,m) -> fprintf f "PConst_int (%s,%a)" i fmt_char_option m
-  | Pconst_char (c) -> fprintf f "PConst_char %02x" (Char.code c)
+let fmt_constant i f x =
+  line i f "constant %a\n" fmt_location x.pconst_loc;
+  let i = i+1 in
+  match x.pconst_desc with
+  | Pconst_integer (j,m) -> line i f "PConst_int (%s,%a)" j fmt_char_option m
+  | Pconst_char (c) -> line i f "PConst_char %02x" (Char.code c)
   | Pconst_string (s, strloc, None) ->
-      fprintf f "PConst_string(%S,%a,None)" s fmt_location strloc
+      line i f "PConst_string(%S,%a,None)" s fmt_location strloc
   | Pconst_string (s, strloc, Some delim) ->
-      fprintf f "PConst_string (%S,%a,Some %S)" s fmt_location strloc delim
-  | Pconst_float (s,m) -> fprintf f "PConst_float (%s,%a)" s fmt_char_option m
+      line i f "PConst_string (%S,%a,Some %S)" s fmt_location strloc delim
+  | Pconst_float (s,m) -> line i f "PConst_float (%s,%a)" s fmt_char_option m
 
 let fmt_mutable_flag f x =
   match x with
   | Immutable -> fprintf f "Immutable"
-  | Mutable -> fprintf f "Mutable"
+  | Mutable loc -> fprintf f "Mutable %a" fmt_location loc
 
 let fmt_virtual_flag f x =
   match x with
-  | Virtual -> fprintf f "Virtual"
+  | Virtual loc -> fprintf f "Virtual %a" fmt_location loc
   | Concrete -> fprintf f "Concrete"
 
 let fmt_override_flag f x =
   match x with
   | Override -> fprintf f "Override"
@@@@
 let fmt_closed_flag f x =
   match x with
   | Closed -> fprintf f "Closed"
   | Open -> fprintf f "Open"
 
+let fmt_obj_closed_flag f x =
+  match x with
+  | OClosed -> fprintf f "OClosed"
+  | OOpen loc -> fprintf f "OOpen %a" fmt_location loc
+
 let fmt_rec_flag f x =
   match x with
   | Nonrecursive -> fprintf f "Nonrec"
   | Recursive -> fprintf f "Rec"
 
@@@@
   | Downto -> fprintf f "Down"
 
 let fmt_private_flag f x =
   match x with
   | Public -> fprintf f "Public"
-  | Private -> fprintf f "Private"
+  | Private loc -> fprintf f "Private %a" fmt_location loc
 
-let line i f s (*...*) =
-  fprintf f "%s" (String.make ((2*i) mod 72) ' ');
-  fprintf f s (*...*)
+let fmt_opt f ppf = function
+  | None -> fprintf ppf "None"
+  | Some x -> fprintf ppf "Some(%a)" f x
+
+let fmt_private_virtual_flag ppf { pv_priv; pv_virt } =
+  fprintf ppf "(private=%a, virtual=%a)"
+    (fmt_opt fmt_location) pv_priv
+    (fmt_opt fmt_location) pv_virt
+
+let fmt_mutable_virtual_flag ppf { mv_mut; mv_virt } =
+  fprintf ppf "(mutable=%a, virtual=%a)"
+    (fmt_opt fmt_location) mv_mut
+    (fmt_opt fmt_location) mv_virt
 
 let list i f ppf l =
   match l with
   | [] -> line i ppf "[]\n"
   | _ :: _ ->
@@@@
       f (i+1) ppf x
 
 let longident_loc i ppf li = line i ppf "%a\n" fmt_longident_loc li
 let string i ppf s = line i ppf "\"%s\"\n" s
 let string_loc i ppf s = line i ppf "%a\n" fmt_string_loc s
-let str_opt_loc i ppf s = line i ppf "%a\n" fmt_str_opt_loc s
 let arg_label i ppf = function
   | Nolabel -> line i ppf "Nolabel\n"
   | Optional s -> line i ppf "Optional \"%s\"\n" s
   | Labelled s -> line i ppf "Labelled \"%s\"\n" s
 
 let typevars ppf vs =
-  List.iter (fun x -> fprintf ppf " %a" Pprintast.tyvar x.txt) vs
+  List.iter (fun x ->
+      fprintf ppf " %a %a" Pprintast.tyvar x.txt fmt_location x.loc) vs
 
 let rec core_type i ppf x =
   line i ppf "core_type %a\n" fmt_location x.ptyp_loc;
   attributes i ppf x.ptyp_attributes;
   let i = i+1 in
   match x.ptyp_desc with
   | Ptyp_any -> line i ppf "Ptyp_any\n";
   | Ptyp_var (s) -> line i ppf "Ptyp_var %s\n" s;
-  | Ptyp_arrow (l, ct1, ct2) ->
+  | Ptyp_arrow (params, ct2) ->
       line i ppf "Ptyp_arrow\n";
-      arg_label i ppf l;
-      core_type i ppf ct1;
+      list i arrow_param ppf params;
       core_type i ppf ct2;
   | Ptyp_tuple l ->
       line i ppf "Ptyp_tuple\n";
       list i core_type ppf l;
   | Ptyp_constr (li, l) ->
       line i ppf "Ptyp_constr %a\n" fmt_longident_loc li;
       list i core_type ppf l;
   | Ptyp_variant (l, closed, low) ->
       line i ppf "Ptyp_variant closed=%a\n" fmt_closed_flag closed;
-      list i label_x_bool_x_core_type_list ppf l;
+      list i row_field ppf l;
       option i (fun i -> list i string) ppf low
   | Ptyp_object (l, c) ->
-      line i ppf "Ptyp_object %a\n" fmt_closed_flag c;
-      let i = i + 1 in
-      List.iter (fun field ->
-        match field.pof_desc with
-          | Otag (l, t) ->
-            line i ppf "method %s\n" l.txt;
-            attributes i ppf field.pof_attributes;
-            core_type (i + 1) ppf t
-          | Oinherit ct ->
-              line i ppf "Oinherit\n";
-              core_type (i + 1) ppf ct
-      ) l
+      line i ppf "Ptyp_object %a\n" fmt_obj_closed_flag c;
+      list i object_field ppf l
   | Ptyp_class (li, l) ->
       line i ppf "Ptyp_class %a\n" fmt_longident_loc li;
       list i core_type ppf l
   | Ptyp_alias (ct, s) ->
       line i ppf "Ptyp_alias \"%s\"\n" s;
@@@@
       core_type i ppf ct;
   | Ptyp_package (s, l) ->
       line i ppf "Ptyp_package %a\n" fmt_longident_loc s;
       list i package_with ppf l;
   | Ptyp_extension (s, arg) ->
-      line i ppf "Ptyp_extension \"%s\"\n" s.txt;
+      line i ppf "Ptyp_extension %a\n" fmt_string_loc s;
       payload i ppf arg
 
+and arrow_param i ppf {pap_label; pap_loc; pap_type} =
+  line i ppf "arrow_param %a\n" fmt_location pap_loc;
+  arg_label i ppf pap_label;
+  core_type i ppf pap_type
+
+and object_field i ppf x =
+  line i ppf "object_field %a\n" fmt_location x.pof_loc;
+  attributes i ppf x.pof_attributes;
+  let i = i+1 in
+  match x.pof_desc with
+  | Otag (l, t) ->
+      line i ppf "Otag %a\n" fmt_string_loc l;
+      core_type i ppf t
+  | Oinherit ct ->
+      line i ppf "Oinherit\n";
+      core_type i ppf ct
+
 and package_with i ppf (s, t) =
   line i ppf "with type %a\n" fmt_longident_loc s;
   core_type i ppf t
 
 and pattern i ppf x =
@@@@
   | Ppat_any -> line i ppf "Ppat_any\n";
   | Ppat_var (s) -> line i ppf "Ppat_var %a\n" fmt_string_loc s;
   | Ppat_alias (p, s) ->
       line i ppf "Ppat_alias %a\n" fmt_string_loc s;
       pattern i ppf p;
-  | Ppat_constant (c) -> line i ppf "Ppat_constant %a\n" fmt_constant c;
+  | Ppat_constant (c) ->
+      line i ppf "Ppat_constant\n";
+      fmt_constant i ppf c;
   | Ppat_interval (c1, c2) ->
-      line i ppf "Ppat_interval %a..%a\n" fmt_constant c1 fmt_constant c2;
+      line i ppf "Ppat_interval\n";
+      fmt_constant i ppf c1;
+      fmt_constant i ppf c2;
   | Ppat_tuple (l) ->
       line i ppf "Ppat_tuple\n";
       list i pattern ppf l;
   | Ppat_construct (li, po) ->
       line i ppf "Ppat_construct %a\n" fmt_longident_loc li;
@@@@
         ppf po
   | Ppat_variant (l, po) ->
       line i ppf "Ppat_variant \"%s\"\n" l;
       option i pattern ppf po;
   | Ppat_record (l, c) ->
-      line i ppf "Ppat_record %a\n" fmt_closed_flag c;
+      line i ppf "Ppat_record %a\n" fmt_obj_closed_flag c;
       list i longident_x_pattern ppf l;
   | Ppat_array (l) ->
       line i ppf "Ppat_array\n";
       list i pattern ppf l;
+  | Ppat_list (l) ->
+      line i ppf "Ppat_list\n";
+      list i pattern ppf l;
   | Ppat_or (p1, p2) ->
       line i ppf "Ppat_or\n";
       pattern i ppf p1;
       pattern i ppf p2;
   | Ppat_lazy p ->
@@@@
       pattern i ppf p
   | Ppat_open (m,p) ->
       line i ppf "Ppat_open \"%a\"\n" fmt_longident_loc m;
       pattern i ppf p
   | Ppat_extension (s, arg) ->
-      line i ppf "Ppat_extension \"%s\"\n" s.txt;
+      line i ppf "Ppat_extension %a\n" fmt_string_loc s;
       payload i ppf arg
+  | Ppat_cons l ->
+      line i ppf "Ppat_cons\n";
+      list i pattern ppf l
 
 and expression i ppf x =
   line i ppf "expression %a\n" fmt_location x.pexp_loc;
   attributes i ppf x.pexp_attributes;
   let i = i+1 in
   match x.pexp_desc with
   | Pexp_ident (li) -> line i ppf "Pexp_ident %a\n" fmt_longident_loc li;
-  | Pexp_constant (c) -> line i ppf "Pexp_constant %a\n" fmt_constant c;
+  | Pexp_constant (c) ->
+      line i ppf "Pexp_constant\n";
+      fmt_constant i ppf c;
   | Pexp_let (rf, l, e) ->
       line i ppf "Pexp_let %a\n" fmt_rec_flag rf;
       list i value_binding ppf l;
       expression i ppf e;
   | Pexp_function l ->
@@@@
       longident_loc i ppf li;
       expression i ppf e2;
   | Pexp_array (l) ->
       line i ppf "Pexp_array\n";
       list i expression ppf l;
+  | Pexp_list (l) ->
+      line i ppf "Pexp_list\n";
+      list i expression ppf l;
   | Pexp_ifthenelse (e1, e2, eo) ->
       line i ppf "Pexp_ifthenelse\n";
       expression i ppf e1;
       expression i ppf e2;
       option i expression ppf eo;
@@@@
       line i ppf "Pexp_coerce\n";
       expression i ppf e;
       option i core_type ppf cto1;
       core_type i ppf cto2;
   | Pexp_send (e, s) ->
-      line i ppf "Pexp_send \"%s\"\n" s.txt;
+      line i ppf "Pexp_send %a\n" fmt_string_loc s;
       expression i ppf e;
   | Pexp_new (li) -> line i ppf "Pexp_new %a\n" fmt_longident_loc li;
   | Pexp_setinstvar (s, e) ->
       line i ppf "Pexp_setinstvar %a\n" fmt_string_loc s;
       expression i ppf e;
@@@@
       option i core_type ppf cto;
   | Pexp_object s ->
       line i ppf "Pexp_object\n";
       class_structure i ppf s
   | Pexp_newtype (s, e) ->
-      line i ppf "Pexp_newtype \"%s\"\n" s.txt;
+      line i ppf "Pexp_newtype %a\n" fmt_string_loc s;
       expression i ppf e
   | Pexp_pack me ->
       line i ppf "Pexp_pack\n";
       module_expr i ppf me
-  | Pexp_open (o, e) ->
-      line i ppf "Pexp_open %a\n" fmt_override_flag o.popen_override;
-      module_expr i ppf o.popen_expr;
+  | Pexp_open (lid, e) ->
+      line i ppf "Pexp_open\n";
+      longident_loc i ppf lid;
+      expression i ppf e
+  | Pexp_letopen (o, e) ->
+      line i ppf "Pexp_letopen\n";
+      open_declaration i ppf o;
       expression i ppf e
   | Pexp_letop {let_; ands; body} ->
       line i ppf "Pexp_letop\n";
       binding_op i ppf let_;
       list i binding_op ppf ands;
       expression i ppf body
   | Pexp_extension (s, arg) ->
-      line i ppf "Pexp_extension \"%s\"\n" s.txt;
+      line i ppf "Pexp_extension %a\n" fmt_string_loc s;
       payload i ppf arg
   | Pexp_unreachable ->
       line i ppf "Pexp_unreachable"
   | Pexp_hole ->
       line i ppf "Pexp_hole"
+  | Pexp_beginend e ->
+      line i ppf "Pexp_beginend\n";
+      expression i ppf e
+  | Pexp_cons l ->
+      line i ppf "Pexp_cons\n";
+      list i expression ppf l
 
 and value_description i ppf x =
   line i ppf "value_description %a %a\n" fmt_string_loc
        x.pval_name fmt_location x.pval_loc;
   attributes i ppf x.pval_attributes;
@@@@
   line i ppf "ptype_private = %a\n" fmt_private_flag x.ptype_private;
   line i ppf "ptype_manifest =\n";
   option (i+1) core_type ppf x.ptype_manifest
 
 and attribute i ppf k a =
-  line i ppf "%s \"%s\"\n" k a.attr_name.txt;
+  line i ppf "%s %a %a\n" k fmt_string_loc a.attr_name fmt_location a.attr_loc;
   payload i ppf a.attr_payload;
 
 and attributes i ppf l =
   let i = i + 1 in
   List.iter (fun a ->
-    line i ppf "attribute \"%s\"\n" a.attr_name.txt;
+    line i ppf "attribute %a %a\n" fmt_string_loc a.attr_name
+      fmt_location a.attr_loc;
     payload (i + 1) ppf a.attr_payload;
   ) l;
 
 and payload i ppf = function
   | PStr x -> structure i ppf x
@@@@
       list (i+1) label_decl ppf l;
   | Ptype_open ->
       line i ppf "Ptype_open\n";
 
 and type_extension i ppf x =
-  line i ppf "type_extension\n";
+  line i ppf "type_extension %a\n" fmt_location x.ptyext_loc;
   attributes i ppf x.ptyext_attributes;
   let i = i+1 in
   line i ppf "ptyext_path = %a\n" fmt_longident_loc x.ptyext_path;
   line i ppf "ptyext_params =\n";
   list (i+1) type_parameter ppf x.ptyext_params;
   line i ppf "ptyext_constructors =\n";
   list (i+1) extension_constructor ppf x.ptyext_constructors;
   line i ppf "ptyext_private = %a\n" fmt_private_flag x.ptyext_private;
 
 and type_exception i ppf x =
-  line i ppf "type_exception\n";
+  line i ppf "type_exception %a\n" fmt_location x.ptyexn_loc;
   attributes i ppf x.ptyexn_attributes;
   let i = i+1 in
   line i ppf "ptyext_constructor =\n";
   let i = i+1 in
   extension_constructor i ppf x.ptyexn_constructor
 
 and extension_constructor i ppf x =
   line i ppf "extension_constructor %a\n" fmt_location x.pext_loc;
   attributes i ppf x.pext_attributes;
   let i = i + 1 in
-  line i ppf "pext_name = \"%s\"\n" x.pext_name.txt;
+  line i ppf "pext_name = %a\n" fmt_string_loc x.pext_name;
   line i ppf "pext_kind =\n";
   extension_constructor_kind (i + 1) ppf x.pext_kind;
 
 and extension_constructor_kind i ppf x =
   match x with
@@@@
       line i ppf "Pcty_constr %a\n" fmt_longident_loc li;
       list i core_type ppf l;
   | Pcty_signature (cs) ->
       line i ppf "Pcty_signature\n";
       class_signature i ppf cs;
-  | Pcty_arrow (l, co, cl) ->
+  | Pcty_arrow (params, cl) ->
       line i ppf "Pcty_arrow\n";
-      arg_label i ppf l;
-      core_type i ppf co;
+      list i arrow_param ppf params;
       class_type i ppf cl;
   | Pcty_extension (s, arg) ->
-      line i ppf "Pcty_extension \"%s\"\n" s.txt;
+      line i ppf "Pcty_extension %a\n" fmt_string_loc s;
       payload i ppf arg
   | Pcty_open (o, e) ->
-      line i ppf "Pcty_open %a %a\n" fmt_override_flag o.popen_override
-        fmt_longident_loc o.popen_expr;
+      line i ppf "Pcty_open\n";
+      open_description i ppf o;
       class_type i ppf e
 
 and class_signature i ppf cs =
   line i ppf "class_signature\n";
   core_type (i+1) ppf cs.pcsig_self;
@@@@
   attributes i ppf x.pctf_attributes;
   match x.pctf_desc with
   | Pctf_inherit (ct) ->
       line i ppf "Pctf_inherit\n";
       class_type i ppf ct;
-  | Pctf_val (s, mf, vf, ct) ->
-      line i ppf "Pctf_val \"%s\" %a %a\n" s.txt fmt_mutable_flag mf
-           fmt_virtual_flag vf;
+  | Pctf_val (s, mv, ct) ->
+      line i ppf "Pctf_val %a %a\n" fmt_string_loc s
+        fmt_mutable_virtual_flag mv;
       core_type (i+1) ppf ct;
-  | Pctf_method (s, pf, vf, ct) ->
-      line i ppf "Pctf_method \"%s\" %a %a\n" s.txt fmt_private_flag pf
-           fmt_virtual_flag vf;
+  | Pctf_method (s, pv, ct) ->
+      line i ppf "Pctf_method %a %a\n" fmt_string_loc s
+        fmt_private_virtual_flag pv;
       core_type (i+1) ppf ct;
   | Pctf_constraint (ct1, ct2) ->
       line i ppf "Pctf_constraint\n";
       core_type (i+1) ppf ct1;
       core_type (i+1) ppf ct2;
   | Pctf_attribute a ->
       attribute i ppf "Pctf_attribute" a
   | Pctf_extension (s, arg) ->
-      line i ppf "Pctf_extension \"%s\"\n" s.txt;
+      line i ppf "Pctf_extension %a\n" fmt_string_loc s;
      payload i ppf arg
 
 and class_description i ppf x =
   line i ppf "class_description %a\n" fmt_location x.pci_loc;
   attributes i ppf x.pci_attributes;
@@@@
   | Pcl_constraint (ce, ct) ->
       line i ppf "Pcl_constraint\n";
       class_expr i ppf ce;
       class_type i ppf ct;
   | Pcl_extension (s, arg) ->
-      line i ppf "Pcl_extension \"%s\"\n" s.txt;
+      line i ppf "Pcl_extension %a\n" fmt_string_loc s;
       payload i ppf arg
   | Pcl_open (o, e) ->
-      line i ppf "Pcl_open %a %a\n" fmt_override_flag o.popen_override
-        fmt_longident_loc o.popen_expr;
+      line i ppf "Pcl_open\n";
+      open_description i ppf o;
       class_expr i ppf e
 
 and class_structure i ppf { pcstr_self = p; pcstr_fields = l } =
   line i ppf "class_structure\n";
   pattern (i+1) ppf p;
@@@@
   | Pcf_inherit (ovf, ce, so) ->
       line i ppf "Pcf_inherit %a\n" fmt_override_flag ovf;
       class_expr (i+1) ppf ce;
       option (i+1) string_loc ppf so;
   | Pcf_val (s, mf, k) ->
-      line i ppf "Pcf_val %a\n" fmt_mutable_flag mf;
+      line i ppf "Pcf_val %a\n" fmt_mutable_virtual_flag mf;
       line (i+1) ppf "%a\n" fmt_string_loc s;
       class_field_kind (i+1) ppf k
   | Pcf_method (s, pf, k) ->
-      line i ppf "Pcf_method %a\n" fmt_private_flag pf;
+      line i ppf "Pcf_method %a\n" fmt_private_virtual_flag pf;
       line (i+1) ppf "%a\n" fmt_string_loc s;
       class_field_kind (i+1) ppf k
   | Pcf_constraint (ct1, ct2) ->
       line i ppf "Pcf_constraint\n";
       core_type (i+1) ppf ct1;
@@@@
       line i ppf "Pcf_initializer\n";
       expression (i+1) ppf e;
   | Pcf_attribute a ->
       attribute i ppf "Pcf_attribute" a
   | Pcf_extension (s, arg) ->
-      line i ppf "Pcf_extension \"%s\"\n" s.txt;
+      line i ppf "Pcf_extension %a\n" fmt_string_loc s;
       payload i ppf arg
 
 and class_field_kind i ppf = function
   | Cfk_concrete (o, e) ->
       line i ppf "Concrete %a\n" fmt_override_flag o;
@@@@
       list i with_constraint ppf l;
   | Pmty_typeof m ->
       line i ppf "Pmty_typeof\n";
       module_expr i ppf m;
   | Pmty_extension (s, arg) ->
-      line i ppf "Pmod_extension \"%s\"\n" s.txt;
+      line i ppf "Pmod_extension %a\n" fmt_string_loc s;
       payload i ppf arg
 
 and signature i ppf x = list i signature_item ppf x
 
 and signature_item i ppf x =
@@@@
       type_extension i ppf te
   | Psig_exception te ->
       line i ppf "Psig_exception\n";
       type_exception i ppf te
   | Psig_module pmd ->
-      line i ppf "Psig_module %a\n" fmt_str_opt_loc pmd.pmd_name;
-      attributes i ppf pmd.pmd_attributes;
-      module_type i ppf pmd.pmd_type
+      line i ppf "Psig_module\n";
+      module_declaration i ppf pmd
   | Psig_modsubst pms ->
       line i ppf "Psig_modsubst %a = %a\n"
         fmt_string_loc pms.pms_name
         fmt_longident_loc pms.pms_manifest;
+      fmt_location ppf pms.pms_loc;
       attributes i ppf pms.pms_attributes;
   | Psig_recmodule decls ->
       line i ppf "Psig_recmodule\n";
       list i module_declaration ppf decls;
   | Psig_modtype x ->
-      line i ppf "Psig_modtype %a\n" fmt_string_loc x.pmtd_name;
-      attributes i ppf x.pmtd_attributes;
-      modtype_declaration i ppf x.pmtd_type
+      line i ppf "Psig_modtype\n";
+      module_type_declaration i ppf x
   | Psig_modtypesubst x ->
-      line i ppf "Psig_modtypesubst %a\n" fmt_string_loc x.pmtd_name;
-      attributes i ppf x.pmtd_attributes;
-      modtype_declaration i ppf x.pmtd_type
+      line i ppf "Psig_modtypesubst\n";
+      module_type_declaration i ppf x
   | Psig_open od ->
-      line i ppf "Psig_open %a %a\n" fmt_override_flag od.popen_override
-        fmt_longident_loc od.popen_expr;
-      attributes i ppf od.popen_attributes
+      line i ppf "Psig_open\n";
+      open_description i ppf od
   | Psig_include incl ->
       line i ppf "Psig_include\n";
-      module_type i ppf incl.pincl_mod;
-      attributes i ppf incl.pincl_attributes
+      include_description i ppf incl
   | Psig_class (l) ->
       line i ppf "Psig_class\n";
       list i class_description ppf l;
   | Psig_class_type (l) ->
       line i ppf "Psig_class_type\n";
       list i class_type_declaration ppf l;
   | Psig_extension ((s, arg), attrs) ->
-      line i ppf "Psig_extension \"%s\"\n" s.txt;
+      line i ppf "Psig_extension %a\n" fmt_string_loc s;
       attributes i ppf attrs;
       payload i ppf arg
   | Psig_attribute a ->
       attribute i ppf "Psig_attribute" a
 
@@@@
       module_type i ppf mt;
   | Pmod_unpack (e) ->
       line i ppf "Pmod_unpack\n";
       expression i ppf e;
   | Pmod_extension (s, arg) ->
-      line i ppf "Pmod_extension \"%s\"\n" s.txt;
+      line i ppf "Pmod_extension %a\n" fmt_string_loc s;
       payload i ppf arg
   | Pmod_hole ->
       line i ppf "Pmod_hole"
 
 and structure i ppf x = list i structure_item ppf x
@@@@
       module_binding i ppf x
   | Pstr_recmodule bindings ->
       line i ppf "Pstr_recmodule\n";
       list i module_binding ppf bindings;
   | Pstr_modtype x ->
-      line i ppf "Pstr_modtype %a\n" fmt_string_loc x.pmtd_name;
-      attributes i ppf x.pmtd_attributes;
-      modtype_declaration i ppf x.pmtd_type
+      line i ppf "Pstr_modtype\n";
+      module_type_declaration i ppf x
   | Pstr_open od ->
-      line i ppf "Pstr_open %a\n" fmt_override_flag od.popen_override;
-      module_expr i ppf od.popen_expr;
-      attributes i ppf od.popen_attributes
+      line i ppf "Pstr_open\n";
+      open_declaration i ppf od
   | Pstr_class (l) ->
       line i ppf "Pstr_class\n";
       list i class_declaration ppf l;
   | Pstr_class_type (l) ->
       line i ppf "Pstr_class_type\n";
       list i class_type_declaration ppf l;
   | Pstr_include incl ->
-      line i ppf "Pstr_include";
-      attributes i ppf incl.pincl_attributes;
-      module_expr i ppf incl.pincl_mod
+      line i ppf "Pstr_include\n";
+      include_declaration i ppf incl
   | Pstr_extension ((s, arg), attrs) ->
-      line i ppf "Pstr_extension \"%s\"\n" s.txt;
+      line i ppf "Pstr_extension %a\n" fmt_string_loc s;
       attributes i ppf attrs;
       payload i ppf arg
   | Pstr_attribute a ->
       attribute i ppf "Pstr_attribute" a
 
+and module_type_declaration i ppf x =
+  line i ppf "module_type_declaration %a %a\n" fmt_string_loc x.pmtd_name
+    fmt_location x.pmtd_loc;
+  attributes i ppf x.pmtd_attributes;
+  modtype_declaration (i+1) ppf x.pmtd_type
+
 and module_declaration i ppf pmd =
-  str_opt_loc i ppf pmd.pmd_name;
+  line i ppf "module_declaration %a %a\n" fmt_str_opt_loc pmd.pmd_name
+    fmt_location pmd.pmd_loc;
   attributes i ppf pmd.pmd_attributes;
   module_type (i+1) ppf pmd.pmd_type;
 
 and module_binding i ppf x =
-  str_opt_loc i ppf x.pmb_name;
+  line i ppf "module_binding %a %a\n" fmt_str_opt_loc x.pmb_name
+    fmt_location x.pmb_loc;
   attributes i ppf x.pmb_attributes;
   module_expr (i+1) ppf x.pmb_expr
 
 and core_type_x_core_type_x_location i ppf (ct1, ct2, l) =
   line i ppf "<constraint> %a\n" fmt_location l;
@@@@
   | None -> ()
   | Some g -> line (i+1) ppf "<when>\n"; expression (i + 2) ppf g
   end;
   expression (i+1) ppf pc_rhs;
 
+and open_description i ppf x =
+  line i ppf "open_description %a %a\n" fmt_override_flag x.popen_override
+    fmt_location x.popen_loc;
+  attributes i ppf x.popen_attributes;
+  fmt_longident_loc ppf x.popen_expr
+
+and open_declaration i ppf x =
+  line i ppf "open_declaration %a %a\n" fmt_override_flag x.popen_override
+    fmt_location x.popen_loc;
+  attributes i ppf x.popen_attributes;
+  let i = i+1 in
+  module_expr i ppf x.popen_expr
+
+and include_description i ppf x =
+  line i ppf "include_description %a\n" fmt_location x.pincl_loc;
+  attributes i ppf x.pincl_attributes;
+  let i = i+1 in
+  module_type i ppf x.pincl_mod
+
+and include_declaration i ppf x =
+  line i ppf "include_declaration %a\n" fmt_location x.pincl_loc;
+  attributes i ppf x.pincl_attributes;
+  let i = i+1 in
+  module_expr i ppf x.pincl_mod
+
 and value_binding i ppf x =
-  line i ppf "<def>\n";
+  line i ppf "<def> %a\n" fmt_location x.pvb_loc;
   attributes (i+1) ppf x.pvb_attributes;
   pattern (i+1) ppf x.pvb_pat;
   expression (i+1) ppf x.pvb_expr
 
 and binding_op i ppf x =
@@@@
 and label_x_expression i ppf (l,e) =
   line i ppf "<arg>\n";
   arg_label i ppf l;
   expression (i+1) ppf e;
 
-and label_x_bool_x_core_type_list i ppf x =
+and row_field i ppf x =
+  line i ppf "row_field %a\n" fmt_location x.prf_loc;
+  attributes i ppf x.prf_attributes;
+  let i = i+1 in
   match x.prf_desc with
-    Rtag (l, b, ctl) ->
-      line i ppf "Rtag \"%s\" %s\n" l.txt (string_of_bool b);
-      attributes (i+1) ppf x.prf_attributes;
-      list (i+1) core_type ppf ctl
+  | Rtag (l, b, ctl) ->
+      line i ppf "Rtag %a %s\n" fmt_string_loc l (string_of_bool b);
+      list i core_type ppf ctl
   | Rinherit (ct) ->
       line i ppf "Rinherit\n";
-      core_type (i+1) ppf ct
+      core_type i ppf ct
 
 let rec toplevel_phrase i ppf x =
   match x with
   | Ptop_def (s) ->
       line i ppf "Ptop_def\n";
       structure (i+1) ppf s;
-  | Ptop_dir {pdir_name; pdir_arg; _} ->
-      line i ppf "Ptop_dir \"%s\"\n" pdir_name.txt;
+  | Ptop_dir {pdir_name; pdir_arg; pdir_loc} ->
+      line i ppf "Ptop_dir %a %a\n" fmt_string_loc pdir_name
+        fmt_location pdir_loc;
       match pdir_arg with
       | None -> ()
       | Some da -> directive_argument i ppf da;
 
 and directive_argument i ppf x =
+  line i ppf "directive_argument %a\n" fmt_location x.pdira_loc;
+  let i = i+1 in
   match x.pdira_desc with
   | Pdir_string (s) -> line i ppf "Pdir_string \"%s\"\n" s
   | Pdir_int (n, None) -> line i ppf "Pdir_int %s\n" n
   | Pdir_int (n, Some m) -> line i ppf "Pdir_int %s%c\n" n m
   | Pdir_ident (li) -> line i ppf "Pdir_ident %a\n" fmt_longident li
   | Pdir_bool (b) -> line i ppf "Pdir_bool %s\n" (string_of_bool b)
 
+let repl_phrase i ppf x =
+  line i ppf "repl_phrase\n";
+  let i = i+1 in
+  toplevel_phrase i ppf x.prepl_phrase;
+  line i ppf "output %S\n" x.prepl_output
+
 let interface ppf x = list 0 signature_item ppf x
 
 let implementation ppf x = list 0 structure_item ppf x
 
 let top_phrase ppf x = toplevel_phrase 0 ppf x
+
+let repl_phrase ppf x = repl_phrase 0 ppf x
+
+let expression ppf x = expression 0 ppf x
+
+let payload ppf x = payload 0 ppf x
+
+let core_type ppf x = core_type 0 ppf x
+
+let module_type ppf x = module_type 0 ppf x
+
+let pattern ppf x = pattern 0 ppf x
+
+let type_declaration ppf x = type_declaration 0 ppf x
+
+let value_binding ppf x = value_binding 0 ppf x
+
+let class_expr ppf x = class_expr 0 ppf x
+
+let class_type ppf x = class_type 0 ppf x
+
+let class_field ppf x = class_field 0 ppf x
+
+let class_type_field ppf x = class_type_field 0 ppf x
+
+let module_expr ppf x = module_expr 0 ppf x
+
+let structure_item ppf x = structure_item 0 ppf x
+
+let signature_item ppf x = signature_item 0 ppf x
--- parser-standard/printast.mli
+++ parser-extended/printast.mli
@@@@
 open Format
 
 val interface : formatter -> signature_item list -> unit
 val implementation : formatter -> structure_item list -> unit
 val top_phrase : formatter -> toplevel_phrase -> unit
+val repl_phrase : formatter -> repl_phrase -> unit
 
-val expression: int -> formatter -> expression -> unit
+val expression: formatter -> expression -> unit
 val structure: int -> formatter -> structure -> unit
-val payload: int -> formatter -> payload -> unit
-val core_type: int -> formatter -> core_type -> unit
-val module_type: int -> formatter -> module_type -> unit
+val payload: formatter -> payload -> unit
+val core_type: formatter -> core_type -> unit
+val module_type: formatter -> module_type -> unit
+val pattern: formatter -> pattern -> unit
+val type_declaration: formatter -> type_declaration -> unit
+val value_binding: formatter -> value_binding -> unit
+val class_expr: formatter -> class_expr -> unit
+val class_type: formatter -> class_type -> unit
+val class_field: formatter -> class_field -> unit
+val class_type_field: formatter -> class_type_field -> unit
+val module_expr: formatter -> module_expr -> unit
+val structure_item: formatter -> structure_item -> unit
+val signature_item: formatter -> signature_item -> unit
+
+type cmts =
+  { before: Location.t -> string list option
+  ; within: Location.t -> string list option
+  ; after: Location.t -> string list option }
+
+val cmts : cmts option ref
