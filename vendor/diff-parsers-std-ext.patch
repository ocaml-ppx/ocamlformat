--- parser-standard/ast_helper.ml
+++ parser-extended/ast_helper.ml
@@@@
 
 let with_default_loc l f =
   Misc.protect_refs [Misc.R (default_loc, l)] f
 
 module Const = struct
-  let integer ?suffix i = Pconst_integer (i, suffix)
-  let int ?suffix i = integer ?suffix (Int.to_string i)
-  let int32 ?(suffix='l') i = integer ~suffix (Int32.to_string i)
-  let int64 ?(suffix='L') i = integer ~suffix (Int64.to_string i)
-  let nativeint ?(suffix='n') i = integer ~suffix (Nativeint.to_string i)
-  let float ?suffix f = Pconst_float (f, suffix)
-  let char c = Pconst_char c
+  let mk ?(loc = !default_loc) d =
+    {pconst_desc = d;
+     pconst_loc = loc}
+
+  let integer ?loc ?suffix i = mk ?loc (Pconst_integer (i, suffix))
+  let int ?loc ?suffix i = integer ?loc ?suffix (Int.to_string i)
+  let int32 ?loc ?(suffix='l') i = integer ?loc ~suffix (Int32.to_string i)
+  let int64 ?loc ?(suffix='L') i = integer ?loc ~suffix (Int64.to_string i)
+  let nativeint ?loc ?(suffix='n') i =
+    integer ?loc ~suffix (Nativeint.to_string i)
+  let float ?loc ?suffix f = mk ?loc (Pconst_float (f, suffix))
+  let char ?loc c = mk ?loc (Pconst_char c)
   let string ?quotation_delimiter ?(loc= !default_loc) s =
-    Pconst_string (s, loc, quotation_delimiter)
+    mk ~loc (Pconst_string (s, loc, quotation_delimiter))
 end
 
 module Attr = struct
   let mk ?(loc= !default_loc) name payload =
     { attr_name = name;
@@@@
   let object_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_object (a, b))
   let class_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_class (a, b))
   let alias ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_alias (a, b))
   let variant ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_variant (a, b, c))
   let poly ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_poly (a, b))
-  let package ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_package (a, b))
+  let package ?loc ?attrs ?ext a b = mk ?loc ?attrs (Ptyp_package ((a, b), ext))
   let extension ?loc ?attrs a = mk ?loc ?attrs (Ptyp_extension a)
 
   let force_poly t =
     match t.ptyp_desc with
     | Ptyp_poly _ -> t
@@@@
                          flag, lbl_lst_option)
         | Ptyp_poly(string_lst, core_type) ->
           List.iter (fun v ->
             check_variable var_names t.ptyp_loc v.txt) string_lst;
             Ptyp_poly(string_lst, loop core_type)
-        | Ptyp_package(longident,lst) ->
-            Ptyp_package(longident,List.map (fun (n,typ) -> (n,loop typ) ) lst)
+        | Ptyp_package((longident,lst), ext) ->
+            Ptyp_package
+              ((longident,List.map (fun (n,typ) -> (n,loop typ) ) lst), ext)
         | Ptyp_extension (s, arg) ->
             Ptyp_extension (s, arg)
       in
       {t with ptyp_desc = desc}
     and loop_row_field field =
@@@@
     loop t
 
 end
 
 module Pat = struct
-  let mk ?(loc = !default_loc) ?(attrs = []) d =
+  let mk ?(loc = !default_loc) ?(attrs = []) ?ext d =
     {ppat_desc = d;
      ppat_loc = loc;
      ppat_loc_stack = [];
+     ppat_ext = ext;
      ppat_attributes = attrs}
   let attr d a = {d with ppat_attributes = d.ppat_attributes @ [a]}
 
   let any ?loc ?attrs () = mk ?loc ?attrs Ppat_any
   let var ?loc ?attrs a = mk ?loc ?attrs (Ppat_var a)
@@@@
   let tuple ?loc ?attrs a = mk ?loc ?attrs (Ppat_tuple a)
   let construct ?loc ?attrs a b = mk ?loc ?attrs (Ppat_construct (a, b))
   let variant ?loc ?attrs a b = mk ?loc ?attrs (Ppat_variant (a, b))
   let record ?loc ?attrs a b = mk ?loc ?attrs (Ppat_record (a, b))
   let array ?loc ?attrs a = mk ?loc ?attrs (Ppat_array a)
+  let list ?loc ?attrs a = mk ?loc ?attrs (Ppat_list a)
   let or_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_or (a, b))
-  let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_constraint (a, b))
+  let constraint_ ?loc ?attrs ?ext a b = mk ?loc ?attrs ?ext (Ppat_constraint (a, b))
   let type_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_type a)
-  let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_lazy a)
-  let unpack ?loc ?attrs a = mk ?loc ?attrs (Ppat_unpack a)
+  let lazy_ ?loc ?attrs ?ext a = mk ?loc ?attrs ?ext (Ppat_lazy a)
+  let unpack ?loc ?attrs ?ext a = mk ?loc ?attrs ?ext (Ppat_unpack a)
   let open_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_open (a, b))
-  let exception_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_exception a)
+  let exception_ ?loc ?attrs ?ext a = mk ?loc ?attrs ?ext (Ppat_exception a)
   let extension ?loc ?attrs a = mk ?loc ?attrs (Ppat_extension a)
 end
 
 module Exp = struct
-  let mk ?(loc = !default_loc) ?(attrs = []) d =
+  let mk ?(loc = !default_loc) ?(attrs = []) ?ext d =
     {pexp_desc = d;
      pexp_loc = loc;
      pexp_loc_stack = [];
+     pexp_ext = ext;
      pexp_attributes = attrs}
   let attr d a = {d with pexp_attributes = d.pexp_attributes @ [a]}
 
   let ident ?loc ?attrs a = mk ?loc ?attrs (Pexp_ident a)
   let constant ?loc ?attrs a = mk ?loc ?attrs (Pexp_constant a)
-  let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_let (a, b, c))
-  let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pexp_fun (a, b, c, d))
-  let function_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_function a)
+  let let_ ?loc ?attrs ?ext a b c = mk ?loc ?attrs ?ext (Pexp_let (a, b, c))
+  let fun_ ?loc ?attrs ?ext a b c d = mk ?loc ?attrs ?ext (Pexp_fun (a, b, c, d))
+  let function_ ?loc ?attrs ?ext a = mk ?loc ?attrs ?ext (Pexp_function a)
   let apply ?loc ?attrs a b = mk ?loc ?attrs (Pexp_apply (a, b))
-  let match_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_match (a, b))
-  let try_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_try (a, b))
+  let match_ ?loc ?attrs ?ext a b = mk ?loc ?attrs ?ext (Pexp_match (a, b))
+  let try_ ?loc ?attrs ?ext a b = mk ?loc ?attrs ?ext (Pexp_try (a, b))
   let tuple ?loc ?attrs a = mk ?loc ?attrs (Pexp_tuple a)
   let construct ?loc ?attrs a b = mk ?loc ?attrs (Pexp_construct (a, b))
   let variant ?loc ?attrs a b = mk ?loc ?attrs (Pexp_variant (a, b))
   let record ?loc ?attrs a b = mk ?loc ?attrs (Pexp_record (a, b))
   let field ?loc ?attrs a b = mk ?loc ?attrs (Pexp_field (a, b))
   let setfield ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_setfield (a, b, c))
   let array ?loc ?attrs a = mk ?loc ?attrs (Pexp_array a)
-  let ifthenelse ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_ifthenelse (a, b, c))
-  let sequence ?loc ?attrs a b = mk ?loc ?attrs (Pexp_sequence (a, b))
-  let while_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_while (a, b))
-  let for_ ?loc ?attrs a b c d e = mk ?loc ?attrs (Pexp_for (a, b, c, d, e))
-  let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_constraint (a, b))
+  let list ?loc ?attrs a = mk ?loc ?attrs (Pexp_list a)
+  let ifthenelse ?loc ?attrs ?ext a b c = mk ?loc ?attrs ?ext (Pexp_ifthenelse (a, b, c))
+  let sequence ?loc ?attrs ?ext a b = mk ?loc ?attrs ?ext (Pexp_sequence (a, b))
+  let while_ ?loc ?attrs ?ext a b = mk ?loc ?attrs ?ext (Pexp_while (a, b))
+  let for_ ?loc ?attrs ?ext a b c d e = mk ?loc ?attrs ?ext (Pexp_for (a, b, c, d, e))
+  let constraint_ ?loc ?attrs ?ext a b = mk ?loc ?attrs ?ext (Pexp_constraint (a, b))
   let coerce ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_coerce (a, b, c))
   let send ?loc ?attrs a b = mk ?loc ?attrs (Pexp_send (a, b))
-  let new_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_new a)
+  let new_ ?loc ?attrs ?ext a = mk ?loc ?attrs ?ext (Pexp_new a)
   let setinstvar ?loc ?attrs a b = mk ?loc ?attrs (Pexp_setinstvar (a, b))
   let override ?loc ?attrs a = mk ?loc ?attrs (Pexp_override a)
-  let letmodule ?loc ?attrs a b c= mk ?loc ?attrs (Pexp_letmodule (a, b, c))
-  let letexception ?loc ?attrs a b = mk ?loc ?attrs (Pexp_letexception (a, b))
-  let assert_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_assert a)
-  let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_lazy a)
+  let letmodule ?loc ?attrs ?ext a b c= mk ?loc ?attrs ?ext (Pexp_letmodule (a, b, c))
+  let letexception ?loc ?attrs ?ext a b = mk ?loc ?attrs ?ext (Pexp_letexception (a, b))
+  let assert_ ?loc ?attrs ?ext a = mk ?loc ?attrs ?ext (Pexp_assert a)
+  let lazy_ ?loc ?attrs ?ext a = mk ?loc ?attrs ?ext (Pexp_lazy a)
   let poly ?loc ?attrs a b = mk ?loc ?attrs (Pexp_poly (a, b))
-  let object_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_object a)
-  let newtype ?loc ?attrs a b = mk ?loc ?attrs (Pexp_newtype (a, b))
-  let pack ?loc ?attrs a = mk ?loc ?attrs (Pexp_pack a)
-  let open_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_open (a, b))
-  let letop ?loc ?attrs let_ ands body =
-    mk ?loc ?attrs (Pexp_letop {let_; ands; body})
+  let object_ ?loc ?attrs ?ext a = mk ?loc ?attrs ?ext (Pexp_object a)
+  let newtype ?loc ?attrs ?ext a b = mk ?loc ?attrs ?ext (Pexp_newtype (a, b))
+  let pack ?loc ?attrs ?ext a = mk ?loc ?attrs ?ext (Pexp_pack a)
+  let open_ ?loc ?attrs ?ext a b = mk ?loc ?attrs ?ext (Pexp_open (a, b))
+  let letop ?loc ?attrs ?ext let_ ands body =
+    mk ?loc ?attrs ?ext (Pexp_letop {let_; ands; body})
   let extension ?loc ?attrs a = mk ?loc ?attrs (Pexp_extension a)
   let unreachable ?loc ?attrs () = mk ?loc ?attrs Pexp_unreachable
   let hole  ?loc ?attrs () = mk ?loc ?attrs Pexp_hole
+  let beginend ?loc ?attrs ?ext a = mk ?loc ?attrs ?ext (Pexp_beginend a)
 
   let case lhs ?guard rhs =
     {
      pc_lhs = lhs;
      pc_guard = guard;
@@@@
     }
 end
 
 module Mty = struct
   let mk ?(loc = !default_loc) ?(attrs = []) d =
-    {pmty_desc = d; pmty_loc = loc; pmty_attributes = attrs}
+    {pmty_desc = d;
+     pmty_loc = loc;
+     pmty_attributes = attrs}
   let attr d a = {d with pmty_attributes = d.pmty_attributes @ [a]}
 
   let ident ?loc ?attrs a = mk ?loc ?attrs (Pmty_ident a)
   let alias ?loc ?attrs a = mk ?loc ?attrs (Pmty_alias a)
   let signature ?loc ?attrs a = mk ?loc ?attrs (Pmty_signature a)
@@@@
   let typeof_ ?loc ?attrs a = mk ?loc ?attrs (Pmty_typeof a)
   let extension ?loc ?attrs a = mk ?loc ?attrs (Pmty_extension a)
 end
 
 module Mod = struct
-let mk ?(loc = !default_loc) ?(attrs = []) d =
-  {pmod_desc = d; pmod_loc = loc; pmod_attributes = attrs}
+  let mk ?(loc = !default_loc) ?(attrs = []) d =
+    {pmod_desc = d;
+     pmod_loc = loc;
+     pmod_attributes = attrs}
   let attr d a = {d with pmod_attributes = d.pmod_attributes @ [a]}
 
   let ident ?loc ?attrs x = mk ?loc ?attrs (Pmod_ident x)
   let structure ?loc ?attrs x = mk ?loc ?attrs (Pmod_structure x)
   let functor_ ?loc ?attrs arg body =
@@@@
   let extension ?loc ?attrs a = mk ?loc ?attrs (Pmod_extension a)
   let hole ?loc ?attrs () = mk ?loc ?attrs Pmod_hole
 end
 
 module Sig = struct
-  let mk ?(loc = !default_loc) d = {psig_desc = d; psig_loc = loc}
-
-  let value ?loc a = mk ?loc (Psig_value a)
-  let type_ ?loc rec_flag a = mk ?loc (Psig_type (rec_flag, a))
-  let type_subst ?loc a = mk ?loc (Psig_typesubst a)
-  let type_extension ?loc a = mk ?loc (Psig_typext a)
-  let exception_ ?loc a = mk ?loc (Psig_exception a)
-  let module_ ?loc a = mk ?loc (Psig_module a)
-  let mod_subst ?loc a = mk ?loc (Psig_modsubst a)
-  let rec_module ?loc a = mk ?loc (Psig_recmodule a)
-  let modtype ?loc a = mk ?loc (Psig_modtype a)
-  let modtype_subst ?loc a = mk ?loc (Psig_modtypesubst a)
-  let open_ ?loc a = mk ?loc (Psig_open a)
-  let include_ ?loc a = mk ?loc (Psig_include a)
-  let class_ ?loc a = mk ?loc (Psig_class a)
-  let class_type ?loc a = mk ?loc (Psig_class_type a)
+  let mk ?(loc = !default_loc) d =
+    {psig_desc = d;
+     psig_loc = loc}
+
+  let value ?loc ?ext a = mk ?loc (Psig_value (a, ext))
+  let type_ ?loc ?ext rec_flag a = mk ?loc (Psig_type (rec_flag, a, ext))
+  let type_subst ?loc ?ext a = mk ?loc (Psig_typesubst (a, ext))
+  let type_extension ?loc ?ext a = mk ?loc (Psig_typext (a, ext))
+  let exception_ ?loc ?ext a = mk ?loc (Psig_exception (a, ext))
+  let module_ ?loc ?ext a = mk ?loc (Psig_module (a, ext))
+  let mod_subst ?loc ?ext a = mk ?loc (Psig_modsubst (a, ext))
+  let rec_module ?loc ?ext a = mk ?loc (Psig_recmodule (a, ext))
+  let modtype ?loc ?ext a = mk ?loc (Psig_modtype (a, ext))
+  let modtype_subst ?loc ?ext a = mk ?loc (Psig_modtypesubst (a, ext))
+  let open_ ?loc ?ext a = mk ?loc (Psig_open (a, ext))
+  let include_ ?loc ?ext a = mk ?loc (Psig_include (a, ext))
+  let class_ ?loc ?ext a = mk ?loc (Psig_class (a, ext))
+  let class_type ?loc ?ext a = mk ?loc (Psig_class_type (a, ext))
   let extension ?loc ?(attrs = []) a = mk ?loc (Psig_extension (a, attrs))
   let attribute ?loc a = mk ?loc (Psig_attribute a)
   let text txt =
     let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
     List.map
       (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
       f_txt
 end
 
 module Str = struct
-  let mk ?(loc = !default_loc) d = {pstr_desc = d; pstr_loc = loc}
+  let mk ?(loc = !default_loc) d =
+    {pstr_desc = d;
+     pstr_loc = loc}
 
   let eval ?loc ?(attrs = []) a = mk ?loc (Pstr_eval (a, attrs))
-  let value ?loc a b = mk ?loc (Pstr_value (a, b))
-  let primitive ?loc a = mk ?loc (Pstr_primitive a)
-  let type_ ?loc rec_flag a = mk ?loc (Pstr_type (rec_flag, a))
-  let type_extension ?loc a = mk ?loc (Pstr_typext a)
-  let exception_ ?loc a = mk ?loc (Pstr_exception a)
-  let module_ ?loc a = mk ?loc (Pstr_module a)
-  let rec_module ?loc a = mk ?loc (Pstr_recmodule a)
-  let modtype ?loc a = mk ?loc (Pstr_modtype a)
-  let open_ ?loc a = mk ?loc (Pstr_open a)
-  let class_ ?loc a = mk ?loc (Pstr_class a)
-  let class_type ?loc a = mk ?loc (Pstr_class_type a)
-  let include_ ?loc a = mk ?loc (Pstr_include a)
+  let value ?loc ?ext a b = mk ?loc (Pstr_value (a, b, ext))
+  let primitive ?loc ?ext a = mk ?loc (Pstr_primitive (a, ext))
+  let type_ ?loc ?ext rec_flag a = mk ?loc (Pstr_type (rec_flag, a, ext))
+  let type_extension ?loc ?ext a = mk ?loc (Pstr_typext (a, ext))
+  let exception_ ?loc ?ext a = mk ?loc (Pstr_exception (a, ext))
+  let module_ ?loc ?ext a = mk ?loc (Pstr_module (a, ext))
+  let rec_module ?loc ?ext a = mk ?loc (Pstr_recmodule (a, ext))
+  let modtype ?loc ?ext a = mk ?loc (Pstr_modtype (a, ext))
+  let open_ ?loc ?ext a = mk ?loc (Pstr_open (a, ext))
+  let class_ ?loc ?ext a = mk ?loc (Pstr_class (a, ext))
+  let class_type ?loc ?ext a = mk ?loc (Pstr_class_type (a, ext))
+  let include_ ?loc ?ext a = mk ?loc (Pstr_include (a, ext))
   let extension ?loc ?(attrs = []) a = mk ?loc (Pstr_extension (a, attrs))
   let attribute ?loc a = mk ?loc (Pstr_attribute a)
   let text txt =
     let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
     List.map
--- parser-standard/ast_helper.mli
+++ parser-extended/ast_helper.mli
@@@@
         of the provided function. *)
 
 (** {1 Constants} *)
 
 module Const : sig
-  val char : char -> constant
+  val mk: ?loc:loc -> constant_desc -> constant
+
+  val char : ?loc:loc -> char -> constant
   val string :
     ?quotation_delimiter:string -> ?loc:Location.t -> string -> constant
-  val integer : ?suffix:char -> string -> constant
-  val int : ?suffix:char -> int -> constant
-  val int32 : ?suffix:char -> int32 -> constant
-  val int64 : ?suffix:char -> int64 -> constant
-  val nativeint : ?suffix:char -> nativeint -> constant
-  val float : ?suffix:char -> string -> constant
+  val integer : ?loc:loc -> ?suffix:char -> string -> constant
+  val int : ?loc:loc -> ?suffix:char -> int -> constant
+  val int32 : ?loc:loc -> ?suffix:char -> int32 -> constant
+  val int64 : ?loc:loc -> ?suffix:char -> int64 -> constant
+  val nativeint : ?loc:loc -> ?suffix:char -> nativeint -> constant
+  val float : ?loc:loc -> ?suffix:char -> string -> constant
 end
 
 (** {1 Attributes} *)
 module Attr : sig
   val mk: ?loc:loc -> str -> payload -> attribute
@@@@
     val class_: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
     val alias: ?loc:loc -> ?attrs:attrs -> core_type -> string -> core_type
     val variant: ?loc:loc -> ?attrs:attrs -> row_field list -> closed_flag
                  -> label list option -> core_type
     val poly: ?loc:loc -> ?attrs:attrs -> str list -> core_type -> core_type
-    val package: ?loc:loc -> ?attrs:attrs -> lid -> (lid * core_type) list
+    val package: ?loc:loc -> ?attrs:attrs -> ?ext:str -> lid -> (lid * core_type) list
                  -> core_type
     val extension: ?loc:loc -> ?attrs:attrs -> extension -> core_type
 
     val force_poly: core_type -> core_type
 
@@@@
   end
 
 (** Patterns *)
 module Pat:
   sig
-    val mk: ?loc:loc -> ?attrs:attrs -> pattern_desc -> pattern
+    val mk: ?loc:loc -> ?attrs:attrs -> ?ext:str -> pattern_desc -> pattern
     val attr:pattern -> attribute -> pattern
 
     val any: ?loc:loc -> ?attrs:attrs -> unit -> pattern
     val var: ?loc:loc -> ?attrs:attrs -> str -> pattern
     val alias: ?loc:loc -> ?attrs:attrs -> pattern -> str -> pattern
@@@@
     val interval: ?loc:loc -> ?attrs:attrs -> constant -> constant -> pattern
     val tuple: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
     val construct: ?loc:loc -> ?attrs:attrs ->
       lid -> (str list * pattern) option -> pattern
     val variant: ?loc:loc -> ?attrs:attrs -> label -> pattern option -> pattern
-    val record: ?loc:loc -> ?attrs:attrs -> (lid * pattern) list -> closed_flag
-                -> pattern
+    val record: ?loc:loc -> ?attrs:attrs -> (lid * pattern) list
+                -> closed_flag_loc -> pattern
     val array: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
+    val list: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
     val or_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern -> pattern
-    val constraint_: ?loc:loc -> ?attrs:attrs -> pattern -> core_type -> pattern
+    val constraint_: ?loc:loc -> ?attrs:attrs -> ?ext:str -> pattern -> core_type -> pattern
     val type_: ?loc:loc -> ?attrs:attrs -> lid -> pattern
-    val lazy_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
-    val unpack: ?loc:loc -> ?attrs:attrs -> str_opt -> pattern
+    val lazy_: ?loc:loc -> ?attrs:attrs -> ?ext:str -> pattern -> pattern
+    val unpack: ?loc:loc -> ?attrs:attrs -> ?ext:str -> str_opt -> pattern
     val open_: ?loc:loc -> ?attrs:attrs  -> lid -> pattern -> pattern
-    val exception_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
+    val exception_: ?loc:loc -> ?attrs:attrs -> ?ext:str -> pattern -> pattern
     val extension: ?loc:loc -> ?attrs:attrs -> extension -> pattern
   end
 
 (** Expressions *)
 module Exp:
   sig
-    val mk: ?loc:loc -> ?attrs:attrs -> expression_desc -> expression
+    val mk: ?loc:loc -> ?attrs:attrs -> ?ext:str -> expression_desc -> expression
     val attr: expression -> attribute -> expression
 
     val ident: ?loc:loc -> ?attrs:attrs -> lid -> expression
     val constant: ?loc:loc -> ?attrs:attrs -> constant -> expression
-    val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list
+    val let_: ?loc:loc -> ?attrs:attrs -> ?ext:str -> rec_flag -> value_binding list
               -> expression -> expression
-    val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option
+    val fun_: ?loc:loc -> ?attrs:attrs -> ?ext:str -> arg_label -> expression option
               -> pattern -> expression -> expression
-    val function_: ?loc:loc -> ?attrs:attrs -> case list -> expression
+    val function_: ?loc:loc -> ?attrs:attrs -> ?ext:str -> case list -> expression
     val apply: ?loc:loc -> ?attrs:attrs -> expression
                -> (arg_label * expression) list -> expression
-    val match_: ?loc:loc -> ?attrs:attrs -> expression -> case list
+    val match_: ?loc:loc -> ?attrs:attrs -> ?ext:str -> expression -> case list
                 -> expression
-    val try_: ?loc:loc -> ?attrs:attrs -> expression -> case list -> expression
+    val try_: ?loc:loc -> ?attrs:attrs -> ?ext:str -> expression -> case list -> expression
     val tuple: ?loc:loc -> ?attrs:attrs -> expression list -> expression
     val construct: ?loc:loc -> ?attrs:attrs -> lid -> expression option
                    -> expression
     val variant: ?loc:loc -> ?attrs:attrs -> label -> expression option
                  -> expression
@@@@
                 -> expression option -> expression
     val field: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
     val setfield: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
                   -> expression
     val array: ?loc:loc -> ?attrs:attrs -> expression list -> expression
-    val ifthenelse: ?loc:loc -> ?attrs:attrs -> expression -> expression
+    val list: ?loc:loc -> ?attrs:attrs -> expression list -> expression
+    val ifthenelse: ?loc:loc -> ?attrs:attrs -> ?ext:str -> expression -> expression
                     -> expression option -> expression
-    val sequence: ?loc:loc -> ?attrs:attrs -> expression -> expression
+    val sequence: ?loc:loc -> ?attrs:attrs -> ?ext:str -> expression -> expression
                   -> expression
-    val while_: ?loc:loc -> ?attrs:attrs -> expression -> expression
+    val while_: ?loc:loc -> ?attrs:attrs -> ?ext:str -> expression -> expression
                 -> expression
-    val for_: ?loc:loc -> ?attrs:attrs -> pattern -> expression -> expression
+    val for_: ?loc:loc -> ?attrs:attrs -> ?ext:str -> pattern -> expression -> expression
               -> direction_flag -> expression -> expression
     val coerce: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
                 -> core_type -> expression
-    val constraint_: ?loc:loc -> ?attrs:attrs -> expression -> core_type
+    val constraint_: ?loc:loc -> ?attrs:attrs -> ?ext:str -> expression -> core_type
                      -> expression
     val send: ?loc:loc -> ?attrs:attrs -> expression -> str -> expression
-    val new_: ?loc:loc -> ?attrs:attrs -> lid -> expression
+    val new_: ?loc:loc -> ?attrs:attrs -> ?ext:str -> lid -> expression
     val setinstvar: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression
     val override: ?loc:loc -> ?attrs:attrs -> (str * expression) list
                   -> expression
-    val letmodule: ?loc:loc -> ?attrs:attrs -> str_opt -> module_expr
+    val letmodule: ?loc:loc -> ?attrs:attrs -> ?ext:str -> str_opt -> module_expr
                    -> expression -> expression
     val letexception:
-      ?loc:loc -> ?attrs:attrs -> extension_constructor -> expression
+      ?loc:loc -> ?attrs:attrs -> ?ext:str -> extension_constructor -> expression
       -> expression
-    val assert_: ?loc:loc -> ?attrs:attrs -> expression -> expression
-    val lazy_: ?loc:loc -> ?attrs:attrs -> expression -> expression
+    val assert_: ?loc:loc -> ?attrs:attrs -> ?ext:str -> expression -> expression
+    val lazy_: ?loc:loc -> ?attrs:attrs -> ?ext:str -> expression -> expression
     val poly: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
               -> expression
-    val object_: ?loc:loc -> ?attrs:attrs -> class_structure -> expression
-    val newtype: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression
-    val pack: ?loc:loc -> ?attrs:attrs -> module_expr -> expression
-    val open_: ?loc:loc -> ?attrs:attrs -> open_declaration -> expression
+    val object_: ?loc:loc -> ?attrs:attrs -> ?ext:str -> class_structure -> expression
+    val newtype: ?loc:loc -> ?attrs:attrs -> ?ext:str -> str -> expression -> expression
+    val pack: ?loc:loc -> ?attrs:attrs -> ?ext:str -> module_expr -> expression
+    val open_: ?loc:loc -> ?attrs:attrs -> ?ext:str -> open_declaration -> expression
                -> expression
-    val letop: ?loc:loc -> ?attrs:attrs -> binding_op
+    val letop: ?loc:loc -> ?attrs:attrs -> ?ext:str -> binding_op
                -> binding_op list -> expression -> expression
     val extension: ?loc:loc -> ?attrs:attrs -> extension -> expression
     val unreachable: ?loc:loc -> ?attrs:attrs -> unit -> expression
 
     val case: pattern -> ?guard:expression -> expression -> case
     val binding_op: str -> pattern -> expression -> loc -> binding_op
     val hole: ?loc:loc -> ?attrs:attrs -> unit -> expression
+    val beginend: ?loc:loc -> ?attrs:attrs -> ?ext:str -> expression option -> expression
   end
 
 (** Value declarations *)
 module Val:
   sig
@@@@
 (** Signature items *)
 module Sig:
   sig
     val mk: ?loc:loc -> signature_item_desc -> signature_item
 
-    val value: ?loc:loc -> value_description -> signature_item
-    val type_: ?loc:loc -> rec_flag -> type_declaration list -> signature_item
-    val type_subst: ?loc:loc -> type_declaration list -> signature_item
-    val type_extension: ?loc:loc -> type_extension -> signature_item
-    val exception_: ?loc:loc -> type_exception -> signature_item
-    val module_: ?loc:loc -> module_declaration -> signature_item
-    val mod_subst: ?loc:loc -> module_substitution -> signature_item
-    val rec_module: ?loc:loc -> module_declaration list -> signature_item
-    val modtype: ?loc:loc -> module_type_declaration -> signature_item
-    val modtype_subst: ?loc:loc -> module_type_declaration -> signature_item
-    val open_: ?loc:loc -> open_description -> signature_item
-    val include_: ?loc:loc -> include_description -> signature_item
-    val class_: ?loc:loc -> class_description list -> signature_item
-    val class_type: ?loc:loc -> class_type_declaration list -> signature_item
+    val value: ?loc:loc -> ?ext:str -> value_description -> signature_item
+    val type_: ?loc:loc -> ?ext:str -> rec_flag -> type_declaration list -> signature_item
+    val type_subst: ?loc:loc -> ?ext:str -> type_declaration list -> signature_item
+    val type_extension: ?loc:loc -> ?ext:str -> type_extension -> signature_item
+    val exception_: ?loc:loc -> ?ext:str -> type_exception -> signature_item
+    val module_: ?loc:loc -> ?ext:str -> module_declaration -> signature_item
+    val mod_subst: ?loc:loc -> ?ext:str -> module_substitution -> signature_item
+    val rec_module: ?loc:loc -> ?ext:str -> module_declaration list -> signature_item
+    val modtype: ?loc:loc -> ?ext:str -> module_type_declaration -> signature_item
+    val modtype_subst: ?loc:loc -> ?ext:str -> module_type_declaration -> signature_item
+    val open_: ?loc:loc -> ?ext:str -> open_description -> signature_item
+    val include_: ?loc:loc -> ?ext:str -> include_description -> signature_item
+    val class_: ?loc:loc -> ?ext:str -> class_description list -> signature_item
+    val class_type: ?loc:loc -> ?ext:str -> class_type_declaration list -> signature_item
     val extension: ?loc:loc -> ?attrs:attrs -> extension -> signature_item
     val attribute: ?loc:loc -> attribute -> signature_item
     val text: text -> signature_item list
   end
 
@@@@
 module Str:
   sig
     val mk: ?loc:loc -> structure_item_desc -> structure_item
 
     val eval: ?loc:loc -> ?attrs:attributes -> expression -> structure_item
-    val value: ?loc:loc -> rec_flag -> value_binding list -> structure_item
-    val primitive: ?loc:loc -> value_description -> structure_item
-    val type_: ?loc:loc -> rec_flag -> type_declaration list -> structure_item
-    val type_extension: ?loc:loc -> type_extension -> structure_item
-    val exception_: ?loc:loc -> type_exception -> structure_item
-    val module_: ?loc:loc -> module_binding -> structure_item
-    val rec_module: ?loc:loc -> module_binding list -> structure_item
-    val modtype: ?loc:loc -> module_type_declaration -> structure_item
-    val open_: ?loc:loc -> open_declaration -> structure_item
-    val class_: ?loc:loc -> class_declaration list -> structure_item
-    val class_type: ?loc:loc -> class_type_declaration list -> structure_item
-    val include_: ?loc:loc -> include_declaration -> structure_item
+    val value: ?loc:loc -> ?ext:str -> rec_flag -> value_binding list -> structure_item
+    val primitive: ?loc:loc -> ?ext:str -> value_description -> structure_item
+    val type_: ?loc:loc -> ?ext:str -> rec_flag -> type_declaration list -> structure_item
+    val type_extension: ?loc:loc -> ?ext:str -> type_extension -> structure_item
+    val exception_: ?loc:loc -> ?ext:str -> type_exception -> structure_item
+    val module_: ?loc:loc -> ?ext:str -> module_binding -> structure_item
+    val rec_module: ?loc:loc -> ?ext:str -> module_binding list -> structure_item
+    val modtype: ?loc:loc -> ?ext:str -> module_type_declaration -> structure_item
+    val open_: ?loc:loc -> ?ext:str -> open_declaration -> structure_item
+    val class_: ?loc:loc -> ?ext:str -> class_declaration list -> structure_item
+    val class_type: ?loc:loc -> ?ext:str -> class_type_declaration list -> structure_item
+    val include_: ?loc:loc -> ?ext:str -> include_declaration -> structure_item
     val extension: ?loc:loc -> ?attrs:attrs -> extension -> structure_item
     val attribute: ?loc:loc -> attribute -> structure_item
     val text: text -> structure_item list
   end
 
--- parser-standard/ast_mapper.ml
+++ parser-extended/ast_mapper.ml
@@@@
   value_description: mapper -> value_description -> value_description;
   with_constraint: mapper -> with_constraint -> with_constraint;
   directive_argument: mapper -> directive_argument -> directive_argument;
   toplevel_directive: mapper -> toplevel_directive -> toplevel_directive;
   toplevel_phrase: mapper -> toplevel_phrase -> toplevel_phrase;
+  repl_phrase: mapper -> repl_phrase -> repl_phrase;
 }
 
 let map_fst f (x, y) = (f x, y)
 let map_snd f (x, y) = (x, f y)
 let map_tuple f1 f2 (x, y) = (f1 x, f2 y)
 let map_tuple3 f1 f2 f3 (x, y, z) = (f1 x, f2 y, f3 z)
 let map_opt f = function None -> None | Some x -> Some (f x)
 
 let map_loc sub {loc; txt} = {loc = sub.location sub loc; txt}
 
+let map_ext sub ext = map_opt (map_loc sub) ext
+
 module C = struct
   (* Constants *)
 
-  let map sub c = match c with
-    | Pconst_integer _
-    | Pconst_char _
-    | Pconst_float _
-      -> c
-    | Pconst_string (s, loc, quotation_delimiter) ->
-        let loc = sub.location sub loc in
-        Const.string ~loc ?quotation_delimiter s
+  let map sub { pconst_desc; pconst_loc } =
+    let loc = sub.location sub pconst_loc in
+    let desc =
+      match pconst_desc with
+      | Pconst_integer _
+      | Pconst_char _
+      | Pconst_float _ ->
+          pconst_desc
+      | Pconst_string (s, loc, quotation_delimiter) ->
+          Pconst_string (s, sub.location sub loc, quotation_delimiter)
+    in
+    Const.mk ~loc desc
 end
 
 module T = struct
   (* Type expressions for the core language *)
 
@@@@
     | Ptyp_alias (t, s) -> alias ~loc ~attrs (sub.typ sub t) s
     | Ptyp_variant (rl, b, ll) ->
         variant ~loc ~attrs (List.map (row_field sub) rl) b ll
     | Ptyp_poly (sl, t) -> poly ~loc ~attrs
                              (List.map (map_loc sub) sl) (sub.typ sub t)
-    | Ptyp_package (lid, l) ->
-        package ~loc ~attrs (map_loc sub lid)
+    | Ptyp_package ((lid, l), ext) ->
+        let ext = map_opt (map_loc sub) ext in
+        package ~loc ~attrs ?ext (map_loc sub lid)
           (List.map (map_tuple (map_loc sub) (sub.typ sub)) l)
     | Ptyp_extension x -> extension ~loc ~attrs (sub.extension sub x)
 
   let map_type_declaration sub
       {ptype_name; ptype_params; ptype_cstrs;
@@@@
 
   let map_signature_item sub {psig_desc = desc; psig_loc = loc} =
     let open Sig in
     let loc = sub.location sub loc in
     match desc with
-    | Psig_value vd -> value ~loc (sub.value_description sub vd)
-    | Psig_type (rf, l) ->
-        type_ ~loc rf (List.map (sub.type_declaration sub) l)
-    | Psig_typesubst l ->
-        type_subst ~loc (List.map (sub.type_declaration sub) l)
-    | Psig_typext te -> type_extension ~loc (sub.type_extension sub te)
-    | Psig_exception ed -> exception_ ~loc (sub.type_exception sub ed)
-    | Psig_module x -> module_ ~loc (sub.module_declaration sub x)
-    | Psig_modsubst x -> mod_subst ~loc (sub.module_substitution sub x)
-    | Psig_recmodule l ->
-        rec_module ~loc (List.map (sub.module_declaration sub) l)
-    | Psig_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
-    | Psig_modtypesubst x ->
-        modtype_subst ~loc (sub.module_type_declaration sub x)
-    | Psig_open x -> open_ ~loc (sub.open_description sub x)
-    | Psig_include x -> include_ ~loc (sub.include_description sub x)
-    | Psig_class l -> class_ ~loc (List.map (sub.class_description sub) l)
-    | Psig_class_type l ->
-        class_type ~loc (List.map (sub.class_type_declaration sub) l)
+    | Psig_value (vd, ext) ->
+        let ext = map_ext sub ext in
+        value ~loc ?ext (sub.value_description sub vd)
+    | Psig_type (rf, l, ext) ->
+        let ext = map_ext sub ext in
+        type_ ~loc ?ext rf (List.map (sub.type_declaration sub) l)
+    | Psig_typesubst (l, ext) ->
+        let ext = map_ext sub ext in
+        type_subst ~loc ?ext (List.map (sub.type_declaration sub) l)
+    | Psig_typext (te, ext) ->
+        let ext = map_ext sub ext in
+        type_extension ~loc ?ext (sub.type_extension sub te)
+    | Psig_exception (ed, ext) ->
+        let ext = map_ext sub ext in
+        exception_ ~loc ?ext (sub.type_exception sub ed)
+    | Psig_module (x, ext) ->
+        let ext = map_ext sub ext in
+        module_ ~loc ?ext (sub.module_declaration sub x)
+    | Psig_modsubst (x, ext) ->
+        let ext = map_ext sub ext in
+        mod_subst ~loc ?ext (sub.module_substitution sub x)
+    | Psig_recmodule (l, ext) ->
+        let ext = map_ext sub ext in
+        rec_module ~loc ?ext (List.map (sub.module_declaration sub) l)
+    | Psig_modtype (x, ext) ->
+        let ext = map_ext sub ext in
+        modtype ~loc ?ext (sub.module_type_declaration sub x)
+    | Psig_modtypesubst (x, ext) ->
+        let ext = map_ext sub ext in
+        modtype_subst ~loc ?ext (sub.module_type_declaration sub x)
+    | Psig_open (x, ext) ->
+        let ext = map_ext sub ext in
+        open_ ~loc ?ext (sub.open_description sub x)
+    | Psig_include (x, ext) ->
+        let ext = map_ext sub ext in
+        include_ ~loc ?ext (sub.include_description sub x)
+    | Psig_class (l, ext) ->
+        let ext = map_ext sub ext in
+        class_ ~loc ?ext (List.map (sub.class_description sub) l)
+    | Psig_class_type (l, ext) ->
+        let ext = map_ext sub ext in
+        class_type ~loc ?ext (List.map (sub.class_type_declaration sub) l)
     | Psig_extension (x, attrs) ->
         let attrs = sub.attributes sub attrs in
         extension ~loc ~attrs (sub.extension sub x)
     | Psig_attribute x -> attribute ~loc (sub.attribute sub x)
 end
@@@@
     let loc = sub.location sub loc in
     match desc with
     | Pstr_eval (x, attrs) ->
         let attrs = sub.attributes sub attrs in
         eval ~loc ~attrs (sub.expr sub x)
-    | Pstr_value (r, vbs) -> value ~loc r (List.map (sub.value_binding sub) vbs)
-    | Pstr_primitive vd -> primitive ~loc (sub.value_description sub vd)
-    | Pstr_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)
-    | Pstr_typext te -> type_extension ~loc (sub.type_extension sub te)
-    | Pstr_exception ed -> exception_ ~loc (sub.type_exception sub ed)
-    | Pstr_module x -> module_ ~loc (sub.module_binding sub x)
-    | Pstr_recmodule l -> rec_module ~loc (List.map (sub.module_binding sub) l)
-    | Pstr_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
-    | Pstr_open x -> open_ ~loc (sub.open_declaration sub x)
-    | Pstr_class l -> class_ ~loc (List.map (sub.class_declaration sub) l)
-    | Pstr_class_type l ->
-        class_type ~loc (List.map (sub.class_type_declaration sub) l)
-    | Pstr_include x -> include_ ~loc (sub.include_declaration sub x)
+    | Pstr_value (r, vbs, ext) ->
+        let ext = map_ext sub ext in
+        value ~loc ?ext r (List.map (sub.value_binding sub) vbs)
+    | Pstr_primitive (vd, ext) ->
+        let ext = map_ext sub ext in
+        primitive ~loc ?ext (sub.value_description sub vd)
+    | Pstr_type (rf, l, ext) ->
+        let ext = map_ext sub ext in
+        type_ ~loc ?ext rf (List.map (sub.type_declaration sub) l)
+    | Pstr_typext (te, ext) ->
+        let ext = map_ext sub ext in
+        type_extension ~loc ?ext (sub.type_extension sub te)
+    | Pstr_exception (ed, ext) ->
+        let ext = map_ext sub ext in
+        exception_ ~loc ?ext (sub.type_exception sub ed)
+    | Pstr_module (x, ext) ->
+        let ext = map_ext sub ext in
+        module_ ~loc ?ext (sub.module_binding sub x)
+    | Pstr_recmodule (l, ext) ->
+        let ext = map_ext sub ext in
+        rec_module ~loc ?ext (List.map (sub.module_binding sub) l)
+    | Pstr_modtype (x, ext) ->
+        let ext = map_ext sub ext in
+        modtype ~loc ?ext (sub.module_type_declaration sub x)
+    | Pstr_open (x, ext) ->
+        let ext = map_ext sub ext in
+        open_ ~loc ?ext (sub.open_declaration sub x)
+    | Pstr_class (l, ext) ->
+        let ext = map_ext sub ext in
+        class_ ~loc ?ext (List.map (sub.class_declaration sub) l)
+    | Pstr_class_type (l, ext) ->
+        let ext = map_ext sub ext in
+        class_type ~loc ?ext (List.map (sub.class_type_declaration sub) l)
+    | Pstr_include (x, ext) ->
+        let ext = map_ext sub ext in
+        include_ ~loc ?ext (sub.include_declaration sub x)
     | Pstr_extension (x, attrs) ->
         let attrs = sub.attributes sub attrs in
         extension ~loc ~attrs (sub.extension sub x)
     | Pstr_attribute x -> attribute ~loc (sub.attribute sub x)
 end
 
 module E = struct
   (* Value expressions for the core language *)
 
-  let map sub {pexp_loc = loc; pexp_desc = desc; pexp_attributes = attrs} =
+  let map sub {pexp_loc = loc; pexp_desc = desc; pexp_attributes = attrs; pexp_ext = ext} =
     let open Exp in
     let loc = sub.location sub loc in
     let attrs = sub.attributes sub attrs in
+    let ext = map_opt (map_loc sub) ext in
     match desc with
     | Pexp_ident x -> ident ~loc ~attrs (map_loc sub x)
     | Pexp_constant x -> constant ~loc ~attrs (sub.constant sub x)
     | Pexp_let (r, vbs, e) ->
-        let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
+        let_ ~loc ~attrs ?ext r (List.map (sub.value_binding sub) vbs)
           (sub.expr sub e)
     | Pexp_fun (lab, def, p, e) ->
-        fun_ ~loc ~attrs lab (map_opt (sub.expr sub) def) (sub.pat sub p)
+        fun_ ~loc ~attrs ?ext lab (map_opt (sub.expr sub) def) (sub.pat sub p)
           (sub.expr sub e)
-    | Pexp_function pel -> function_ ~loc ~attrs (sub.cases sub pel)
+    | Pexp_function pel -> function_ ~loc ~attrs ?ext (sub.cases sub pel)
     | Pexp_apply (e, l) ->
         apply ~loc ~attrs (sub.expr sub e) (List.map (map_snd (sub.expr sub)) l)
     | Pexp_match (e, pel) ->
-        match_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
-    | Pexp_try (e, pel) -> try_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
+        match_ ~loc ~attrs ?ext (sub.expr sub e) (sub.cases sub pel)
+    | Pexp_try (e, pel) -> try_ ~loc ~attrs ?ext (sub.expr sub e) (sub.cases sub pel)
     | Pexp_tuple el -> tuple ~loc ~attrs (List.map (sub.expr sub) el)
     | Pexp_construct (lid, arg) ->
         construct ~loc ~attrs (map_loc sub lid) (map_opt (sub.expr sub) arg)
     | Pexp_variant (lab, eo) ->
         variant ~loc ~attrs lab (map_opt (sub.expr sub) eo)
@@@@
         field ~loc ~attrs (sub.expr sub e) (map_loc sub lid)
     | Pexp_setfield (e1, lid, e2) ->
         setfield ~loc ~attrs (sub.expr sub e1) (map_loc sub lid)
           (sub.expr sub e2)
     | Pexp_array el -> array ~loc ~attrs (List.map (sub.expr sub) el)
+    | Pexp_list el -> list ~loc ~attrs (List.map (sub.expr sub) el)
     | Pexp_ifthenelse (e1, e2, e3) ->
-        ifthenelse ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
+        ifthenelse ~loc ~attrs ?ext (sub.expr sub e1) (sub.expr sub e2)
           (map_opt (sub.expr sub) e3)
     | Pexp_sequence (e1, e2) ->
-        sequence ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
+        sequence ~loc ~attrs ?ext (sub.expr sub e1) (sub.expr sub e2)
     | Pexp_while (e1, e2) ->
-        while_ ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
+        while_ ~loc ~attrs ?ext (sub.expr sub e1) (sub.expr sub e2)
     | Pexp_for (p, e1, e2, d, e3) ->
-        for_ ~loc ~attrs (sub.pat sub p) (sub.expr sub e1) (sub.expr sub e2) d
+        for_ ~loc ~attrs ?ext (sub.pat sub p) (sub.expr sub e1) (sub.expr sub e2) d
           (sub.expr sub e3)
     | Pexp_coerce (e, t1, t2) ->
         coerce ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t1)
           (sub.typ sub t2)
     | Pexp_constraint (e, t) ->
-        constraint_ ~loc ~attrs (sub.expr sub e) (sub.typ sub t)
+        constraint_ ~loc ~attrs ?ext (sub.expr sub e) (sub.typ sub t)
     | Pexp_send (e, s) ->
         send ~loc ~attrs (sub.expr sub e) (map_loc sub s)
-    | Pexp_new lid -> new_ ~loc ~attrs (map_loc sub lid)
+    | Pexp_new lid -> new_ ~loc ~attrs ?ext (map_loc sub lid)
     | Pexp_setinstvar (s, e) ->
         setinstvar ~loc ~attrs (map_loc sub s) (sub.expr sub e)
     | Pexp_override sel ->
         override ~loc ~attrs
           (List.map (map_tuple (map_loc sub) (sub.expr sub)) sel)
     | Pexp_letmodule (s, me, e) ->
-        letmodule ~loc ~attrs (map_loc sub s) (sub.module_expr sub me)
+        letmodule ~loc ~attrs ?ext (map_loc sub s) (sub.module_expr sub me)
           (sub.expr sub e)
     | Pexp_letexception (cd, e) ->
-        letexception ~loc ~attrs
+        letexception ~loc ~attrs ?ext
           (sub.extension_constructor sub cd)
           (sub.expr sub e)
-    | Pexp_assert e -> assert_ ~loc ~attrs (sub.expr sub e)
-    | Pexp_lazy e -> lazy_ ~loc ~attrs (sub.expr sub e)
+    | Pexp_assert e -> assert_ ~loc ~attrs ?ext (sub.expr sub e)
+    | Pexp_lazy e -> lazy_ ~loc ~attrs ?ext (sub.expr sub e)
     | Pexp_poly (e, t) ->
         poly ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t)
-    | Pexp_object cls -> object_ ~loc ~attrs (sub.class_structure sub cls)
+    | Pexp_object cls -> object_ ~loc ~attrs ?ext (sub.class_structure sub cls)
     | Pexp_newtype (s, e) ->
-        newtype ~loc ~attrs (map_loc sub s) (sub.expr sub e)
-    | Pexp_pack me -> pack ~loc ~attrs (sub.module_expr sub me)
+        newtype ~loc ~attrs ?ext (map_loc sub s) (sub.expr sub e)
+    | Pexp_pack me -> pack ~loc ~attrs ?ext (sub.module_expr sub me)
     | Pexp_open (o, e) ->
-        open_ ~loc ~attrs (sub.open_declaration sub o) (sub.expr sub e)
+        open_ ~loc ~attrs ?ext (sub.open_declaration sub o) (sub.expr sub e)
     | Pexp_letop {let_; ands; body} ->
-        letop ~loc ~attrs (sub.binding_op sub let_)
+        letop ~loc ~attrs ?ext (sub.binding_op sub let_)
           (List.map (sub.binding_op sub) ands) (sub.expr sub body)
     | Pexp_extension x -> extension ~loc ~attrs (sub.extension sub x)
     | Pexp_unreachable -> unreachable ~loc ~attrs ()
     | Pexp_hole -> hole ~loc ~attrs ()
+    | Pexp_beginend e -> beginend ~loc ~attrs ?ext (map_opt (sub.expr sub) e)
 
   let map_binding_op sub {pbop_op; pbop_pat; pbop_exp; pbop_loc} =
     let open Exp in
     let op = map_loc sub pbop_op in
     let pat = sub.pat sub pbop_pat in
@@@@
 end
 
 module P = struct
   (* Patterns *)
 
-  let map sub {ppat_desc = desc; ppat_loc = loc; ppat_attributes = attrs} =
+  let map sub {ppat_desc = desc; ppat_loc = loc; ppat_attributes = attrs; ppat_ext = ext} =
     let open Pat in
     let loc = sub.location sub loc in
     let attrs = sub.attributes sub attrs in
+    let ext = map_opt (map_loc sub) ext in
     match desc with
     | Ppat_any -> any ~loc ~attrs ()
     | Ppat_var s -> var ~loc ~attrs (map_loc sub s)
     | Ppat_alias (p, s) -> alias ~loc ~attrs (sub.pat sub p) (map_loc sub s)
     | Ppat_constant c -> constant ~loc ~attrs (sub.constant sub c)
@@@@
              (fun (vl, p) -> List.map (map_loc sub) vl, sub.pat sub p)
              p)
     | Ppat_variant (l, p) -> variant ~loc ~attrs l (map_opt (sub.pat sub) p)
     | Ppat_record (lpl, cf) ->
         record ~loc ~attrs
-               (List.map (map_tuple (map_loc sub) (sub.pat sub)) lpl) cf
+               (List.map (map_tuple (map_loc sub) (sub.pat sub)) lpl)
+               (match cf with
+                | Closed -> Closed
+                | Open loc -> Open (sub.location sub loc))
     | Ppat_array pl -> array ~loc ~attrs (List.map (sub.pat sub) pl)
+    | Ppat_list pl -> list ~loc ~attrs (List.map (sub.pat sub) pl)
     | Ppat_or (p1, p2) -> or_ ~loc ~attrs (sub.pat sub p1) (sub.pat sub p2)
     | Ppat_constraint (p, t) ->
-        constraint_ ~loc ~attrs (sub.pat sub p) (sub.typ sub t)
+        constraint_ ~loc ~attrs ?ext (sub.pat sub p) (sub.typ sub t)
     | Ppat_type s -> type_ ~loc ~attrs (map_loc sub s)
-    | Ppat_lazy p -> lazy_ ~loc ~attrs (sub.pat sub p)
-    | Ppat_unpack s -> unpack ~loc ~attrs (map_loc sub s)
+    | Ppat_lazy p -> lazy_ ~loc ~attrs ?ext (sub.pat sub p)
+    | Ppat_unpack s -> unpack ~loc ~attrs ?ext (map_loc sub s)
     | Ppat_open (lid,p) -> open_ ~loc ~attrs (map_loc sub lid) (sub.pat sub p)
-    | Ppat_exception p -> exception_ ~loc ~attrs (sub.pat sub p)
+    | Ppat_exception p -> exception_ ~loc ~attrs ?ext (sub.pat sub p)
     | Ppat_extension x -> extension ~loc ~attrs (sub.extension sub x)
 end
 
 module CE = struct
   (* Value expressions for the class language *)
@@@@
 
     toplevel_phrase =
       (fun this -> function
          | Ptop_def s -> Ptop_def (this.structure this s)
          | Ptop_dir d -> Ptop_dir (this.toplevel_directive this d) );
+
+    repl_phrase =
+      (fun this p ->
+         { prepl_phrase= this.toplevel_phrase this p.prepl_phrase
+         ; prepl_output= p.prepl_output } );
   }
 
 let extension_of_error {kind; main; sub} =
   if kind <> Location.Report_error then
     raise (Invalid_argument "extension_of_error: expected kind Report_error");
   let str_of_pp pp_msg = Format.asprintf "%t" pp_msg in
   let extension_of_sub sub =
     { loc = sub.loc; txt = "ocaml.error" },
     PStr ([Str.eval (Exp.constant
-                       (Pconst_string (str_of_pp sub.txt, sub.loc, None)))])
+                       (Const.mk (Pconst_string (str_of_pp sub.txt, sub.loc, None))))])
   in
   { loc = main.loc; txt = "ocaml.error" },
   PStr (Str.eval (Exp.constant
-                    (Pconst_string (str_of_pp main.txt, main.loc, None))) ::
+                    (Const.mk (Pconst_string (str_of_pp main.txt, main.loc, None)))) ::
         List.map (fun msg -> Str.extension (extension_of_sub msg)) sub)
 
 let attribute_of_warning loc s =
   Attr.mk
     {loc; txt = "ocaml.ppwarning" }
-    (PStr ([Str.eval ~loc (Exp.constant (Pconst_string (s, loc, None)))]))
+    (PStr ([Str.eval ~loc (Exp.constant (Const.mk (Pconst_string (s, loc, None))))]))
 
 let cookies = ref String.Map.empty
 
 let get_cookie k =
   try Some (String.Map.find k !cookies)
@@@@
         raise_errorf "Internal error: invalid [@@@ocaml.ppx.context] syntax"
 
   let restore fields =
     let field name payload =
       let rec get_string = function
-        | { pexp_desc = Pexp_constant (Pconst_string (str, _, None)) } -> str
+        | { pexp_desc = Pexp_constant {pconst_desc= Pconst_string (str, _, None); _ } } -> str
         | _ -> raise_errorf "Internal error: invalid [@@@ocaml.ppx.context \
                              { %s }] string syntax" name
       and get_bool pexp =
         match pexp with
         | {pexp_desc = Pexp_construct ({txt = Longident.Lident "true"},
--- parser-standard/ast_mapper.mli
+++ parser-extended/ast_mapper.mli
@@@@
   value_description: mapper -> value_description -> value_description;
   with_constraint: mapper -> with_constraint -> with_constraint;
   directive_argument: mapper -> directive_argument -> directive_argument;
   toplevel_directive: mapper -> toplevel_directive -> toplevel_directive;
   toplevel_phrase: mapper -> toplevel_phrase -> toplevel_phrase;
+  repl_phrase: mapper -> repl_phrase -> repl_phrase;
 }
 (** A mapper record implements one "method" per syntactic category,
     using an open recursion style: each method takes as its first
     argument the mapper to be applied to children in the syntax
     tree. *)
--- parser-standard/asttypes.mli
+++ parser-extended/asttypes.mli
@@@@
 
 type override_flag = Override | Fresh
 
 type closed_flag = Closed | Open
 
+type closed_flag_loc = Closed | Open of Location.t
+
 type label = string
 
 type arg_label =
     Nolabel
   | Labelled of string (** [label:T -> ...] *)
--- parser-standard/docstrings.ml
+++ parser-extended/docstrings.ml
@@@@
 
 let docs_attr ds =
   let open Parsetree in
   let body = ds.ds_body in
   let loc = ds.ds_loc in
+  let const = { pconst_desc= Pconst_string(body,loc,None); pconst_loc= loc } in
   let exp =
-    { pexp_desc = Pexp_constant (Pconst_string(body, loc, None));
+    { pexp_desc = Pexp_constant const;
       pexp_loc = loc;
       pexp_loc_stack = [];
+      pexp_ext = None;
       pexp_attributes = []; }
   in
   let item =
     { pstr_desc = Pstr_eval (exp, []); pstr_loc = loc }
   in
@@@@
 
 let text_attr ds =
   let open Parsetree in
   let body = ds.ds_body in
   let loc = ds.ds_loc in
+  let const = { pconst_desc= Pconst_string(body,loc,None); pconst_loc= loc } in
   let exp =
-    { pexp_desc = Pexp_constant (Pconst_string(body, loc, None));
+    { pexp_desc = Pexp_constant const;
       pexp_loc = loc;
       pexp_loc_stack = [];
+      pexp_ext = None;
       pexp_attributes = []; }
   in
   let item =
     { pstr_desc = Pstr_eval (exp, []); pstr_loc = loc }
   in
--- parser-standard/parser.mly
+++ parser-extended/parser.mly
@@@@
   Location.loc_ghost = true;
 }
 
 let mktyp ~loc ?attrs d = Typ.mk ~loc:(make_loc loc) ?attrs d
 let mkpat ~loc d = Pat.mk ~loc:(make_loc loc) d
-let mkexp ~loc d = Exp.mk ~loc:(make_loc loc) d
+let mkexp ~loc ?ext d = Exp.mk ~loc:(make_loc loc) ?ext d
 let mkmty ~loc ?attrs d = Mty.mk ~loc:(make_loc loc) ?attrs d
 let mksig ~loc d = Sig.mk ~loc:(make_loc loc) d
 let mkmod ~loc ?attrs d = Mod.mk ~loc:(make_loc loc) ?attrs d
 let mkstr ~loc d = Str.mk ~loc:(make_loc loc) d
 let mkclass ~loc ?attrs d = Cl.mk ~loc:(make_loc loc) ?attrs d
 let mkcty ~loc ?attrs d = Cty.mk ~loc:(make_loc loc) ?attrs d
+let mkconst ~loc c = Const.mk ~loc:(make_loc loc) c
 
 let pstr_typext (te, ext) =
-  (Pstr_typext te, ext)
+  Pstr_typext (te, ext)
 let pstr_primitive (vd, ext) =
-  (Pstr_primitive vd, ext)
+  Pstr_primitive (vd, ext)
 let pstr_type ((nr, ext), tys) =
-  (Pstr_type (nr, tys), ext)
+  Pstr_type (nr, tys, ext)
 let pstr_exception (te, ext) =
-  (Pstr_exception te, ext)
+  Pstr_exception (te, ext)
 let pstr_include (body, ext) =
-  (Pstr_include body, ext)
+  Pstr_include (body, ext)
 let pstr_recmodule (ext, bindings) =
-  (Pstr_recmodule bindings, ext)
+  Pstr_recmodule (bindings, ext)
 
 let psig_typext (te, ext) =
-  (Psig_typext te, ext)
+  Psig_typext (te, ext)
 let psig_value (vd, ext) =
-  (Psig_value vd, ext)
+  Psig_value (vd, ext)
 let psig_type ((nr, ext), tys) =
-  (Psig_type (nr, tys), ext)
+  Psig_type (nr, tys, ext)
 let psig_typesubst ((nr, ext), tys) =
   assert (nr = Recursive); (* see [no_nonrec_flag] *)
-  (Psig_typesubst tys, ext)
+  Psig_typesubst (tys, ext)
 let psig_exception (te, ext) =
-  (Psig_exception te, ext)
+  Psig_exception (te, ext)
 let psig_include (body, ext) =
-  (Psig_include body, ext)
+  Psig_include (body, ext)
 
 let mkctf ~loc ?attrs ?docs d =
   Ctf.mk ~loc:(make_loc loc) ?attrs ?docs d
 let mkcf ~loc ?attrs ?docs d =
   Cf.mk ~loc:(make_loc loc) ?attrs ?docs d
 
 let mkrhs rhs loc = mkloc rhs (make_loc loc)
-let ghrhs rhs loc = mkloc rhs (ghost_loc loc)
 
 let push_loc x acc =
   if x.Location.loc_ghost
   then acc
   else x :: acc
@@@@
 *)
 let ghexp ~loc d = Exp.mk ~loc:(ghost_loc loc) d
 let ghpat ~loc d = Pat.mk ~loc:(ghost_loc loc) d
 let ghtyp ~loc d = Typ.mk ~loc:(ghost_loc loc) d
 let ghloc ~loc d = { txt = d; loc = ghost_loc loc }
-let ghstr ~loc d = Str.mk ~loc:(ghost_loc loc) d
-let ghsig ~loc d = Sig.mk ~loc:(ghost_loc loc) d
 
 let mkinfix arg1 op arg2 =
   Pexp_apply(op, [Nolabel, arg1; Nolabel, arg2])
 
 let neg_string f =
@@@@
   then String.sub f 1 (String.length f - 1)
   else "-" ^ f
 
 let mkuminus ~oploc name arg =
   match name, arg.pexp_desc with
-  | "-", Pexp_constant(Pconst_integer (n,m)) ->
-      Pexp_constant(Pconst_integer(neg_string n,m))
-  | ("-" | "-."), Pexp_constant(Pconst_float (f, m)) ->
-      Pexp_constant(Pconst_float(neg_string f, m))
+  | "-", Pexp_constant({pconst_desc= Pconst_integer (n,m); _} as c) ->
+      Pexp_constant({c with pconst_desc= Pconst_integer(neg_string n,m)})
+  | ("-" | "-."), Pexp_constant({pconst_desc= Pconst_float (f, m); _} as c) ->
+      Pexp_constant({c with pconst_desc= Pconst_float(neg_string f, m)})
   | _ ->
       Pexp_apply(mkoperator ~loc:oploc ("~" ^ name), [Nolabel, arg])
 
 let mkuplus ~oploc name arg =
   let desc = arg.pexp_desc in
   match name, desc with
-  | "+", Pexp_constant(Pconst_integer _)
-  | ("+" | "+."), Pexp_constant(Pconst_float _) -> desc
+  | "+", Pexp_constant({pconst_desc= Pconst_integer _; _})
+  | ("+" | "+."), Pexp_constant({pconst_desc= Pconst_float _; _}) -> desc
   | _ ->
       Pexp_apply(mkoperator ~loc:oploc ("~" ^ name), [Nolabel, arg])
 
 (* TODO define an abstraction boundary between locations-as-pairs
    and locations-as-Location.t; it should be clear when we move from
@@@@
 let mkpat_cons_desc consloc args =
   Ppat_construct(mkrhs (Lident "::") consloc, Some ([], args))
 let mkpat_cons ~loc consloc args =
   mkpat ~loc (mkpat_cons_desc consloc args)
 
-let ghexp_cons_desc consloc args =
-  Pexp_construct(ghrhs (Lident "::") consloc, Some args)
-let ghpat_cons_desc consloc args =
-  Ppat_construct(ghrhs (Lident "::") consloc, Some ([], args))
-
-let rec mktailexp nilloc = let open Location in function
-    [] ->
-      let nil = ghloc ~loc:nilloc (Lident "[]") in
-      Pexp_construct (nil, None), nilloc
-  | e1 :: el ->
-      let exp_el, el_loc = mktailexp nilloc el in
-      let loc = (e1.pexp_loc.loc_start, snd el_loc) in
-      let arg = ghexp ~loc (Pexp_tuple [e1; ghexp ~loc:el_loc exp_el]) in
-      ghexp_cons_desc loc arg, loc
-
-let rec mktailpat nilloc = let open Location in function
-    [] ->
-      let nil = ghloc ~loc:nilloc (Lident "[]") in
-      Ppat_construct (nil, None), nilloc
-  | p1 :: pl ->
-      let pat_pl, el_loc = mktailpat nilloc pl in
-      let loc = (p1.ppat_loc.loc_start, snd el_loc) in
-      let arg = ghpat ~loc (Ppat_tuple [p1; ghpat ~loc:el_loc pat_pl]) in
-      ghpat_cons_desc loc arg, loc
-
 let mkstrexp e attrs =
   { pstr_desc = Pstr_eval (e, attrs); pstr_loc = e.pexp_loc }
 
 let mkexp_constraint ~loc e (t1, t2) =
   match t1, t2 with
@@@@
   let mk_newtypes = mk_newtypes ~loc in
   let exp = mkexp(Pexp_constraint(body,core_type)) in
   let exp = mk_newtypes newtypes exp in
   (exp, ghtyp(Ptyp_poly(newtypes, Typ.varify_constructors newtypes core_type)))
 
-let wrap_exp_attrs ~loc body (ext, attrs) =
-  let ghexp = ghexp ~loc in
+let wrap_exp_attrs ~loc:_ body (ext, attrs) =
   (* todo: keep exact location for the entire attribute *)
-  let body = {body with pexp_attributes = attrs @ body.pexp_attributes} in
-  match ext with
-  | None -> body
-  | Some id -> ghexp(Pexp_extension (id, PStr [mkstrexp body []]))
+  {body with
+    pexp_ext = ext;
+    pexp_attributes = attrs @ body.pexp_attributes}
 
 let mkexp_attrs ~loc d attrs =
   wrap_exp_attrs ~loc (mkexp ~loc d) attrs
 
-let wrap_typ_attrs ~loc typ (ext, attrs) =
+let wrap_typ_attrs ~loc:_ typ attrs =
   (* todo: keep exact location for the entire attribute *)
-  let typ = {typ with ptyp_attributes = attrs @ typ.ptyp_attributes} in
-  match ext with
-  | None -> typ
-  | Some id -> ghtyp ~loc (Ptyp_extension (id, PTyp typ))
+  {typ with ptyp_attributes = attrs @ typ.ptyp_attributes}
 
-let wrap_pat_attrs ~loc pat (ext, attrs) =
+let wrap_pat_attrs ~loc:_ pat (ext, attrs) =
   (* todo: keep exact location for the entire attribute *)
-  let pat = {pat with ppat_attributes = attrs @ pat.ppat_attributes} in
-  match ext with
-  | None -> pat
-  | Some id -> ghpat ~loc (Ppat_extension (id, PPat (pat, None)))
+  {pat with
+    ppat_ext = ext;
+    ppat_attributes = attrs @ pat.ppat_attributes}
 
 let mkpat_attrs ~loc d attrs =
   wrap_pat_attrs ~loc (mkpat ~loc d) attrs
 
 let wrap_class_attrs ~loc:_ body attrs =
@@@@
 let wrap_mod_attrs ~loc:_ attrs body =
   {body with pmod_attributes = attrs @ body.pmod_attributes}
 let wrap_mty_attrs ~loc:_ attrs body =
   {body with pmty_attributes = attrs @ body.pmty_attributes}
 
-let wrap_str_ext ~loc body ext =
-  match ext with
-  | None -> body
-  | Some id -> ghstr ~loc (Pstr_extension ((id, PStr [body]), []))
-
-let wrap_mkstr_ext ~loc (item, ext) =
-  wrap_str_ext ~loc (mkstr ~loc item) ext
-
-let wrap_sig_ext ~loc body ext =
-  match ext with
-  | None -> body
-  | Some id -> ghsig ~loc (Psig_extension ((id, PSig [body]), []))
+let wrap_mkstr_ext ~loc item =
+  mkstr ~loc item
 
-let wrap_mksig_ext ~loc (item, ext) =
-  wrap_sig_ext ~loc (mksig ~loc item) ext
+let wrap_mksig_ext ~loc item =
+  mksig ~loc item
 
 let mk_quotedext ~loc (id, idloc, str, strloc, delim) =
   let exp_id = mkloc id idloc in
-  let e = ghexp ~loc (Pexp_constant (Pconst_string (str, strloc, delim))) in
+  let const = Const.mk ~loc:strloc (Pconst_string (str, strloc, delim)) in
+  let e = ghexp ~loc (Pexp_constant const) in
   (exp_id, PStr [mkstrexp e []])
 
 let text_str pos = Str.text (rhs_text pos)
 let text_sig pos = Sig.text (rhs_text pos)
 let text_cstr pos = Cf.text (rhs_text pos)
@@@@
            ~docs:(Lazy.force lb.lb_docs)
            ~text:(Lazy.force lb.lb_text)
            lb.lb_pattern lb.lb_expression)
       lbs.lbs_bindings
   in
-  let str = mkstr ~loc (Pstr_value(lbs.lbs_rec, List.rev bindings)) in
-  match lbs.lbs_extension with
-  | None -> str
-  | Some id -> ghstr ~loc (Pstr_extension((id, PStr [str]), []))
+  mkstr ~loc (Pstr_value(lbs.lbs_rec, List.rev bindings, lbs.lbs_extension))
 
 let expr_of_let_bindings ~loc lbs body =
   let bindings =
     List.map
       (fun lb ->
@@@@
    semantic value is a pair of a list of [X]s and an optional [Y]. *)
 
 listx(delimiter, X, Y):
 | x = X ioption(delimiter)
     { [x], None }
-| x = X delimiter y = Y delimiter?
+| x = X delimiter y = mkloc(Y) delimiter?
     { [x], Some y }
 | x = X
   delimiter
   tail = listx(delimiter, X, Y)
     { let xs, y = tail in
@@@@
     | module_binding
         { $1 }
     | rec_module_bindings
         { pstr_recmodule $1 }
     | module_type_declaration
-        { let (body, ext) = $1 in (Pstr_modtype body, ext) }
+        { let (body, ext) = $1 in Pstr_modtype (body, ext) }
     | open_declaration
-        { let (body, ext) = $1 in (Pstr_open body, ext) }
+        { let (body, ext) = $1 in Pstr_open (body, ext) }
     | class_declarations
-        { let (ext, l) = $1 in (Pstr_class l, ext) }
+        { let (ext, l) = $1 in Pstr_class (l, ext) }
     | class_type_declarations
-        { let (ext, l) = $1 in (Pstr_class_type l, ext) }
+        { let (ext, l) = $1 in Pstr_class_type (l, ext) }
     | include_statement(module_expr)
         { pstr_include $1 }
     )
     { $1 }
 ;
@@@@
   attrs2 = post_item_attributes
     { let docs = symbol_docs $sloc in
       let loc = make_loc $sloc in
       let attrs = attrs1 @ attrs2 in
       let body = Mb.mk name body ~attrs ~loc ~docs in
-      Pstr_module body, ext }
+      Pstr_module (body, ext) }
 ;
 
 (* The body (right-hand side) of a module binding. *)
 module_binding_body:
     EQUAL me = module_expr
@@@@
     | sig_type_extension
         { psig_typext $1 }
     | sig_exception_declaration
         { psig_exception $1 }
     | module_declaration
-        { let (body, ext) = $1 in (Psig_module body, ext) }
+        { let (body, ext) = $1 in Psig_module (body, ext) }
     | module_alias
-        { let (body, ext) = $1 in (Psig_module body, ext) }
+        { let (body, ext) = $1 in Psig_module (body, ext) }
     | module_subst
-        { let (body, ext) = $1 in (Psig_modsubst body, ext) }
+        { let (body, ext) = $1 in Psig_modsubst (body, ext) }
     | rec_module_declarations
-        { let (ext, l) = $1 in (Psig_recmodule l, ext) }
+        { let (ext, l) = $1 in Psig_recmodule (l, ext) }
     | module_type_declaration
-        { let (body, ext) = $1 in (Psig_modtype body, ext) }
+        { let (body, ext) = $1 in Psig_modtype (body, ext) }
     | module_type_subst
-        { let (body, ext) = $1 in (Psig_modtypesubst body, ext) }
+        { let (body, ext) = $1 in Psig_modtypesubst (body, ext) }
     | open_description
-        { let (body, ext) = $1 in (Psig_open body, ext) }
+        { let (body, ext) = $1 in Psig_open (body, ext) }
     | include_statement(module_type)
         { psig_include $1 }
     | class_descriptions
-        { let (ext, l) = $1 in (Psig_class l, ext) }
+        { let (ext, l) = $1 in Psig_class (l, ext) }
     | class_type_declarations
-        { let (ext, l) = $1 in (Psig_class_type l, ext) }
+        { let (ext, l) = $1 in Psig_class_type (l, ext) }
     )
     { $1 }
 
 (* A module declaration. *)
 %inline module_declaration:
@@@@
   | expr        %prec below_SEMI  { $1 }
   | expr SEMI                     { $1 }
   | mkexp(expr SEMI seq_expr
     { Pexp_sequence($1, $3) })
     { $1 }
-  | expr SEMI PERCENT attr_id seq_expr
-    { let seq = mkexp ~loc:$sloc (Pexp_sequence ($1, $5)) in
-      let payload = PStr [mkstrexp seq []] in
-      mkexp ~loc:$sloc (Pexp_extension ($4, payload)) }
+  | expr SEMI PERCENT ext=attr_id seq_expr
+    { mkexp ~loc:$sloc ~ext (Pexp_sequence ($1, $5)) }
 ;
 labeled_simple_pattern:
     QUESTION LPAREN label_let_pattern opt_default RPAREN
       { (Optional (fst $3), $4, snd $3) }
   | QUESTION label_var
@@@@
       mkexp_attrs ~loc:$sloc desc attrs }
   | mkexp(simple_expr_)
       { $1 }
 ;
 %inline simple_expr_attrs:
-  | BEGIN ext = ext attrs = attributes e = seq_expr END
-      { e.pexp_desc, (ext, attrs @ e.pexp_attributes) }
+  | BEGIN ext_attributes seq_expr END
+      { Pexp_beginend (Some $3), $2 }
   | BEGIN ext_attributes END
-      { Pexp_construct (mkloc (Lident "()") (make_loc $sloc), None), $2 }
+      { Pexp_beginend None, $2 }
   | BEGIN ext_attributes seq_expr error
       { unclosed "begin" $loc($1) "end" $loc($4) }
   | NEW ext_attributes mkrhs(class_longident)
       { Pexp_new($3), $2 }
   | LPAREN MODULE ext_attributes module_expr RPAREN
@@@@
         Pexp_open(od, mkexp ~loc:($startpos($3), $endpos) (Pexp_array [])) }
   | mod_longident DOT
     LBRACKETBAR expr_semi_list error
       { unclosed "[|" $loc($3) "|]" $loc($5) }
   | LBRACKET expr_semi_list RBRACKET
-      { fst (mktailexp $loc($3) $2) }
+      { Pexp_list $2 }
   | LBRACKET expr_semi_list error
       { unclosed "[" $loc($1) "]" $loc($3) }
   | od=open_dot_declaration DOT LBRACKET expr_semi_list RBRACKET
-      { let list_exp =
-          (* TODO: review the location of list_exp *)
-          let tail_exp, _tail_loc = mktailexp $loc($5) $4 in
-          mkexp ~loc:($startpos($3), $endpos) tail_exp in
+      { let list_exp = mkexp ~loc:($startpos($3), $endpos) (Pexp_list $4) in
         Pexp_open(od, list_exp) }
   | od=open_dot_declaration DOT mkrhs(LBRACKET RBRACKET {Lident "[]"})
       { Pexp_open(od, mkexp ~loc:$loc($3) (Pexp_construct($3, None))) }
   | mod_longident DOT
     LBRACKET expr_semi_list error
@@@@
       { let (fields, closed) = $2 in
         Ppat_record(fields, closed) }
     | LBRACE record_pat_content error
       { unclosed "{" $loc($1) "}" $loc($3) }
     | LBRACKET pattern_semi_list RBRACKET
-      { fst (mktailpat $loc($3) $2) }
+      { Ppat_list $2 }
     | LBRACKET pattern_semi_list error
       { unclosed "[" $loc($1) "]" $loc($3) }
     | LBRACKETBAR pattern_semi_list BARRBRACKET
       { Ppat_array $2 }
     | LBRACKETBAR BARRBRACKET
@@@@
 (* A label-pattern list is a nonempty list of label-pattern pairs, optionally
    followed with an UNDERSCORE, separated-or-terminated with semicolons. *)
 %inline record_pat_content:
   listx(SEMI, record_pat_field, UNDERSCORE)
     { let fields, closed = $1 in
-      let closed = match closed with Some () -> Open | None -> Closed in
+      let closed : closed_flag_loc =
+        match closed with Some {loc; _} -> Open loc | None -> Closed
+      in
       fields, closed }
 ;
 %inline record_pat_field:
   label = mkrhs(label_longident)
   octy = preceded(COLON, core_type)?
@@@@
    - variant types:                       [`A]
  *)
 atomic_type:
   | LPAREN core_type RPAREN
       { $2 }
-  | LPAREN MODULE ext_attributes package_type RPAREN
-      { wrap_typ_attrs ~loc:$sloc (reloc_typ ~loc:$sloc $4) $3 }
+  | LPAREN MODULE ext_attributes module_type RPAREN
+      { let ext, attrs' = $3 in
+        let (lid, cstrs, attrs) = package_type_of_module_type $4 in
+        let descr = Ptyp_package ((lid, cstrs), ext) in
+        let ty = mktyp ~loc:$sloc ~attrs descr in
+        wrap_typ_attrs ~loc:$sloc (reloc_typ ~loc:$sloc ty) attrs' }
   | mktyp( /* begin mktyp group */
       QUOTE ident
         { Ptyp_var $2 }
     | UNDERSCORE
         { Ptyp_any }
@@@@
       { tys }
 ;
 
 %inline package_type: module_type
       { let (lid, cstrs, attrs) = package_type_of_module_type $1 in
-        let descr = Ptyp_package (lid, cstrs) in
+        let descr = Ptyp_package ((lid, cstrs), None) in
         mktyp ~loc:$sloc ~attrs descr }
 ;
 %inline row_field_list:
   separated_nonempty_llist(BAR, row_field)
     { $1 }
@@@@
 ;
 
 /* Constants */
 
 constant:
-  | INT          { let (n, m) = $1 in Pconst_integer (n, m) }
-  | CHAR         { Pconst_char $1 }
-  | STRING       { let (s, strloc, d) = $1 in Pconst_string (s, strloc, d) }
-  | FLOAT        { let (f, m) = $1 in Pconst_float (f, m) }
+  | INT          { let (n, m) = $1 in
+                   mkconst ~loc:$sloc (Pconst_integer (n, m)) }
+  | CHAR         { mkconst ~loc:$sloc (Pconst_char $1) }
+  | STRING       { let (s, strloc, d) = $1 in
+                   mkconst ~loc:$sloc (Pconst_string (s,strloc,d)) }
+  | FLOAT        { let (f, m) = $1 in
+                   mkconst ~loc:$sloc (Pconst_float (f, m)) }
 ;
 signed_constant:
     constant     { $1 }
-  | MINUS INT    { let (n, m) = $2 in Pconst_integer("-" ^ n, m) }
-  | MINUS FLOAT  { let (f, m) = $2 in Pconst_float("-" ^ f, m) }
-  | PLUS INT     { let (n, m) = $2 in Pconst_integer (n, m) }
-  | PLUS FLOAT   { let (f, m) = $2 in Pconst_float(f, m) }
+  | MINUS INT    { let (n, m) = $2 in
+                   mkconst ~loc:$sloc (Pconst_integer("-" ^ n, m)) }
+  | MINUS FLOAT  { let (f, m) = $2 in
+                   mkconst ~loc:$sloc (Pconst_float("-" ^ f, m)) }
+  | PLUS INT     { let (n, m) = $2 in
+                   mkconst ~loc:$sloc (Pconst_integer (n, m)) }
+  | PLUS FLOAT   { let (f, m) = $2 in
+                   mkconst ~loc:$sloc (Pconst_float(f, m)) }
 ;
 
 /* Identifiers and long identifiers */
 
 ident:
--- parser-standard/parsetree.mli
+++ parser-extended/parsetree.mli
@@@@
 
 *)
 
 open Asttypes
 
-type constant =
+type constant_desc =
   | Pconst_integer of string * char option
       (** Integer constants such as [3] [3l] [3L] [3n].
 
      Suffixes [[g-z][G-Z]] are accepted by the parser.
      Suffixes except ['l'], ['L'] and ['n'] are rejected by the typechecker
@@@@
 
      Suffixes [g-z][G-Z] are accepted by the parser.
      Suffixes are rejected by the typechecker.
   *)
 
+type constant = {
+  pconst_desc : constant_desc;
+  pconst_loc : Location.t;
+}
+
 type location_stack = Location.t list
 
 (** {1 Extension points} *)
 
+type ext = string loc
+
 type attribute = {
     attr_name : string loc;
     attr_payload : payload;
     attr_loc : Location.t;
   }
@@@@
            node.
 
            - As the {{!value_description.pval_type}[pval_type]} field of a
            {!value_description}.
          *)
-  | Ptyp_package of package_type  (** [(module S)]. *)
+  | Ptyp_package of package_type * ext option  (** [(module S)]. *)
   | Ptyp_extension of extension  (** [[%id]]. *)
 
 and package_type = Longident.t loc * (Longident.t loc * core_type) list
 (** As {!package_type} typed values:
          - [(S, [])] represents [(module S)],
@@@@
     {
      ppat_desc: pattern_desc;
      ppat_loc: Location.t;
      ppat_loc_stack: location_stack;
      ppat_attributes: attributes;  (** [... [\@id1] [\@id2]] *)
+     ppat_ext: ext option;
     }
 
 and pattern_desc =
   | Ppat_any  (** The pattern [_]. *)
   | Ppat_var of string loc  (** A variable pattern such as [x] *)
@@@@
   | Ppat_variant of label * pattern option
       (** [Ppat_variant(`A, pat)] represents:
             - [`A]   when [pat] is [None],
             - [`A P] when [pat] is [Some P]
          *)
-  | Ppat_record of (Longident.t loc * pattern) list * closed_flag
+  | Ppat_record of (Longident.t loc * pattern) list * closed_flag_loc
       (** [Ppat_record([(l1, P1) ; ... ; (ln, Pn)], flag)] represents:
             - [{ l1=P1; ...; ln=Pn }]
                  when [flag] is {{!Asttypes.closed_flag.Closed}[Closed]}
             - [{ l1=P1; ...; ln=Pn; _}]
                  when [flag] is {{!Asttypes.closed_flag.Open}[Open]}
 
            Invariant: [n > 0]
          *)
   | Ppat_array of pattern list  (** Pattern [[| P1; ...; Pn |]] *)
+  | Ppat_list of pattern list  (** Pattern [[ P1; ...; Pn ]] *)
   | Ppat_or of pattern * pattern  (** Pattern [P1 | P2] *)
   | Ppat_constraint of pattern * core_type  (** Pattern [(P : T)] *)
   | Ppat_type of Longident.t loc  (** Pattern [#tconst] *)
   | Ppat_lazy of pattern  (** Pattern [lazy P] *)
   | Ppat_unpack of string option loc
@@@@
     {
      pexp_desc: expression_desc;
      pexp_loc: Location.t;
      pexp_loc_stack: location_stack;
      pexp_attributes: attributes;  (** [... [\@id1] [\@id2]] *)
+     pexp_ext: ext option;
     }
 
 and expression_desc =
   | Pexp_ident of Longident.t loc
       (** Identifiers such as [x] and [M.x]
@@@@
          *)
   | Pexp_field of expression * Longident.t loc  (** [E.l] *)
   | Pexp_setfield of expression * Longident.t loc * expression
       (** [E1.l <- E2] *)
   | Pexp_array of expression list  (** [[| E1; ...; En |]] *)
+  | Pexp_list of expression list  (** [[ E1; ...; En ]] *)
   | Pexp_ifthenelse of expression * expression * expression option
       (** [if E1 then E2 else E3] *)
   | Pexp_sequence of expression * expression  (** [E1; E2] *)
   | Pexp_while of expression * expression  (** [while E1 do E2 done] *)
   | Pexp_for of pattern * expression * expression * direction_flag * expression
@@@@
       (** - [let* P = E0 in E1]
             - [let* P0 = E00 and* P1 = E01 in E1] *)
   | Pexp_extension of extension  (** [[%id]] *)
   | Pexp_unreachable  (** [.] *)
   | Pexp_hole  (** [_] *)
+  | Pexp_beginend of expression option  (** [begin E end] *)
 
 and case =
     {
      pc_lhs: pattern;
      pc_guard: expression option;
@@@@
      psig_desc: signature_item_desc;
      psig_loc: Location.t;
     }
 
 and signature_item_desc =
-  | Psig_value of value_description
+  | Psig_value of value_description * ext option
       (** - [val x: T]
             - [external x: T = "s1" ... "sn"]
          *)
-  | Psig_type of rec_flag * type_declaration list
+  | Psig_type of rec_flag * type_declaration list * ext option
       (** [type t1 = ... and ... and tn  = ...] *)
-  | Psig_typesubst of type_declaration list
+  | Psig_typesubst of type_declaration list * ext option
       (** [type t1 := ... and ... and tn := ...]  *)
-  | Psig_typext of type_extension  (** [type t1 += ...] *)
-  | Psig_exception of type_exception  (** [exception C of T] *)
-  | Psig_module of module_declaration  (** [module X = M] and [module X : MT] *)
-  | Psig_modsubst of module_substitution  (** [module X := M] *)
-  | Psig_recmodule of module_declaration list
+  | Psig_typext of type_extension * ext option  (** [type t1 += ...] *)
+  | Psig_exception of type_exception * ext option  (** [exception C of T] *)
+  | Psig_module of module_declaration * ext option
+      (** [module X = M] and [module X : MT] *)
+  | Psig_modsubst of module_substitution * ext option  (** [module X := M] *)
+  | Psig_recmodule of module_declaration list * ext option
       (** [module rec X1 : MT1 and ... and Xn : MTn] *)
-  | Psig_modtype of module_type_declaration
+  | Psig_modtype of module_type_declaration * ext option
       (** [module type S = MT] and [module type S] *)
-  | Psig_modtypesubst of module_type_declaration
+  | Psig_modtypesubst of module_type_declaration * ext option
       (** [module type S :=  ...]  *)
-  | Psig_open of open_description  (** [open X] *)
-  | Psig_include of include_description  (** [include MT] *)
-  | Psig_class of class_description list
+  | Psig_open of open_description * ext option  (** [open X] *)
+  | Psig_include of include_description * ext option  (** [include MT] *)
+  | Psig_class of class_description list * ext option
       (** [class c1 : ... and ... and cn : ...] *)
-  | Psig_class_type of class_type_declaration list
+  | Psig_class_type of class_type_declaration list * ext option
       (** [class type ct1 = ... and ... and ctn = ...] *)
   | Psig_attribute of attribute  (** [[\@\@\@id]] *)
   | Psig_extension of extension * attributes  (** [[%%id]] *)
 
 and module_declaration =
@@@@
      pstr_loc: Location.t;
     }
 
 and structure_item_desc =
   | Pstr_eval of expression * attributes  (** [E] *)
-  | Pstr_value of rec_flag * value_binding list
+  | Pstr_value of rec_flag * value_binding list * ext option
       (** [Pstr_value(rec, [(P1, E1 ; ... ; (Pn, En))])] represents:
             - [let P1 = E1 and ... and Pn = EN]
                 when [rec] is {{!Asttypes.rec_flag.Nonrecursive}[Nonrecursive]},
             - [let rec P1 = E1 and ... and Pn = EN ]
                 when [rec] is {{!Asttypes.rec_flag.Recursive}[Recursive]}.
         *)
-  | Pstr_primitive of value_description
+  | Pstr_primitive of value_description * ext option
       (** - [val x: T]
             - [external x: T = "s1" ... "sn" ]*)
-  | Pstr_type of rec_flag * type_declaration list
+  | Pstr_type of rec_flag * type_declaration list * ext option
       (** [type t1 = ... and ... and tn = ...] *)
-  | Pstr_typext of type_extension  (** [type t1 += ...] *)
-  | Pstr_exception of type_exception
+  | Pstr_typext of type_extension * ext option  (** [type t1 += ...] *)
+  | Pstr_exception of type_exception * ext option
       (** - [exception C of T]
             - [exception C = M.X] *)
-  | Pstr_module of module_binding  (** [module X = ME] *)
-  | Pstr_recmodule of module_binding list
+  | Pstr_module of module_binding * ext option  (** [module X = ME] *)
+  | Pstr_recmodule of module_binding list * ext option
       (** [module rec X1 = ME1 and ... and Xn = MEn] *)
-  | Pstr_modtype of module_type_declaration  (** [module type S = MT] *)
-  | Pstr_open of open_declaration  (** [open X] *)
-  | Pstr_class of class_declaration list
+  | Pstr_modtype of module_type_declaration * ext option
+      (** [module type S = MT] *)
+  | Pstr_open of open_declaration * ext option  (** [open X] *)
+  | Pstr_class of class_declaration list * ext option
       (** [class c1 = ... and ... and cn = ...] *)
-  | Pstr_class_type of class_type_declaration list
+  | Pstr_class_type of class_type_declaration list * ext option
       (** [class type ct1 = ... and ... and ctn = ...] *)
-  | Pstr_include of include_declaration  (** [include ME] *)
+  | Pstr_include of include_declaration * ext option  (** [include ME] *)
   | Pstr_attribute of attribute  (** [[\@\@\@id]] *)
   | Pstr_extension of extension * attributes  (** [[%%id]] *)
 
 and value_binding =
   {
@@@@
 and directive_argument_desc =
   | Pdir_string of string
   | Pdir_int of string * char option
   | Pdir_ident of Longident.t
   | Pdir_bool of bool
+
+type repl_phrase =
+  {
+    prepl_phrase : toplevel_phrase;
+    prepl_output : string;
+  }
--- parser-standard/printast.ml
+++ parser-extended/printast.ml
@@@@
   if l.pos_lnum = -1
   then fprintf f "%s[%d]" fname l.pos_cnum
   else fprintf f "%s[%d,%d+%d]" fname l.pos_lnum l.pos_bol
                (l.pos_cnum - l.pos_bol)
 
+let curr_indent : int ref = ref 0
+
+let line i f s (*...*) =
+  curr_indent := i;
+  fprintf f "%s" (String.make ((2*i) mod 72) ' ');
+  fprintf f s (*...*)
+
+type cmts =
+  { before: Location.t -> string list option
+  ; within: Location.t -> string list option
+  ; after: Location.t -> string list option }
+
+let cmts : cmts option ref = ref None
+
+let fmt_cmts i f lbl = function
+  | Some cmts ->
+      let fmt_cmt f s =
+        line i f "%s: (*%s*)" lbl s
+      in
+      fprintf f "\n";
+      pp_print_list fmt_cmt f cmts
+  | None -> ()
+
 let fmt_location f loc =
   if not !Clflags.locations then ()
   else begin
     let p_2nd_name = loc.loc_start.pos_fname <> loc.loc_end.pos_fname in
     fprintf f "(%a..%a)" (fmt_position true) loc.loc_start
                          (fmt_position p_2nd_name) loc.loc_end;
     if loc.loc_ghost then fprintf f " ghost";
+    match !cmts with
+    | None -> ()
+    | Some {before; within; after} -> (
+        match before loc, within loc, after loc with
+        | None, None, None -> ()
+        | b, w, a ->
+            let i = !curr_indent in
+            fprintf f "\n";
+            line i f "comments";
+            let i = i+1 in
+            fmt_cmts i f "before" b;
+            fmt_cmts i f "within" w;
+            fmt_cmts i f " after" a )
   end
 
 let rec fmt_longident_aux f x =
   match x with
   | Longident.Lident (s) -> fprintf f "%s" s
@@@@
 
 let fmt_char_option f = function
   | None -> fprintf f "None"
   | Some c -> fprintf f "Some %c" c
 
-let fmt_constant f x =
-  match x with
-  | Pconst_integer (i,m) -> fprintf f "PConst_int (%s,%a)" i fmt_char_option m
-  | Pconst_char (c) -> fprintf f "PConst_char %02x" (Char.code c)
+let fmt_constant i f x =
+  line i f "constant %a\n" fmt_location x.pconst_loc;
+  let i = i+1 in
+  match x.pconst_desc with
+  | Pconst_integer (j,m) -> line i f "PConst_int (%s,%a)" j fmt_char_option m
+  | Pconst_char (c) -> line i f "PConst_char %02x" (Char.code c)
   | Pconst_string (s, strloc, None) ->
-      fprintf f "PConst_string(%S,%a,None)" s fmt_location strloc
+      line i f "PConst_string(%S,%a,None)" s fmt_location strloc
   | Pconst_string (s, strloc, Some delim) ->
-      fprintf f "PConst_string (%S,%a,Some %S)" s fmt_location strloc delim
-  | Pconst_float (s,m) -> fprintf f "PConst_float (%s,%a)" s fmt_char_option m
+      line i f "PConst_string (%S,%a,Some %S)" s fmt_location strloc delim
+  | Pconst_float (s,m) -> line i f "PConst_float (%s,%a)" s fmt_char_option m
 
 let fmt_mutable_flag f x =
   match x with
   | Immutable -> fprintf f "Immutable"
   | Mutable -> fprintf f "Mutable"
@@@@
   match x with
   | Override -> fprintf f "Override"
   | Fresh -> fprintf f "Fresh"
 
 let fmt_closed_flag f x =
-  match x with
+  match (x : closed_flag) with
   | Closed -> fprintf f "Closed"
   | Open -> fprintf f "Open"
 
+let fmt_closed_flag_loc f x =
+  match (x : closed_flag_loc) with
+  | Closed -> fprintf f "Closed"
+  | Open loc -> fprintf f "Open %a" fmt_location loc
+
 let fmt_rec_flag f x =
   match x with
   | Nonrecursive -> fprintf f "Nonrec"
   | Recursive -> fprintf f "Rec"
 
@@@@
 let fmt_private_flag f x =
   match x with
   | Public -> fprintf f "Public"
   | Private -> fprintf f "Private"
 
-let line i f s (*...*) =
-  fprintf f "%s" (String.make ((2*i) mod 72) ' ');
-  fprintf f s (*...*)
-
 let list i f ppf l =
   match l with
   | [] -> line i ppf "[]\n"
   | _ :: _ ->
      line i ppf "[\n";
@@@@
       f (i+1) ppf x
 
 let longident_loc i ppf li = line i ppf "%a\n" fmt_longident_loc li
 let string i ppf s = line i ppf "\"%s\"\n" s
 let string_loc i ppf s = line i ppf "%a\n" fmt_string_loc s
-let str_opt_loc i ppf s = line i ppf "%a\n" fmt_str_opt_loc s
 let arg_label i ppf = function
   | Nolabel -> line i ppf "Nolabel\n"
   | Optional s -> line i ppf "Optional \"%s\"\n" s
   | Labelled s -> line i ppf "Labelled \"%s\"\n" s
 
+let sug_ext i ppf = function
+  | Some x -> line i ppf "extension %a\n" fmt_string_loc x
+  | None -> ()
+
 let typevars ppf vs =
-  List.iter (fun x -> fprintf ppf " %a" Pprintast.tyvar x.txt) vs
+  List.iter (fun x ->
+      fprintf ppf " %a %a" Pprintast.tyvar x.txt fmt_location x.loc) vs
 
 let rec core_type i ppf x =
   line i ppf "core_type %a\n" fmt_location x.ptyp_loc;
   attributes i ppf x.ptyp_attributes;
   let i = i+1 in
@@@@
   | Ptyp_constr (li, l) ->
       line i ppf "Ptyp_constr %a\n" fmt_longident_loc li;
       list i core_type ppf l;
   | Ptyp_variant (l, closed, low) ->
       line i ppf "Ptyp_variant closed=%a\n" fmt_closed_flag closed;
-      list i label_x_bool_x_core_type_list ppf l;
+      list i row_field ppf l;
       option i (fun i -> list i string) ppf low
   | Ptyp_object (l, c) ->
       line i ppf "Ptyp_object %a\n" fmt_closed_flag c;
-      let i = i + 1 in
-      List.iter (fun field ->
-        match field.pof_desc with
-          | Otag (l, t) ->
-            line i ppf "method %s\n" l.txt;
-            attributes i ppf field.pof_attributes;
-            core_type (i + 1) ppf t
-          | Oinherit ct ->
-              line i ppf "Oinherit\n";
-              core_type (i + 1) ppf ct
-      ) l
+      list i object_field ppf l
   | Ptyp_class (li, l) ->
       line i ppf "Ptyp_class %a\n" fmt_longident_loc li;
       list i core_type ppf l
   | Ptyp_alias (ct, s) ->
       line i ppf "Ptyp_alias \"%s\"\n" s;
       core_type i ppf ct;
   | Ptyp_poly (sl, ct) ->
       line i ppf "Ptyp_poly%a\n" typevars sl;
       core_type i ppf ct;
-  | Ptyp_package (s, l) ->
+  | Ptyp_package ((s, l), ext) ->
       line i ppf "Ptyp_package %a\n" fmt_longident_loc s;
+      sug_ext i ppf ext;
       list i package_with ppf l;
   | Ptyp_extension (s, arg) ->
-      line i ppf "Ptyp_extension \"%s\"\n" s.txt;
+      line i ppf "Ptyp_extension %a\n" fmt_string_loc s;
       payload i ppf arg
 
+and object_field i ppf x =
+  line i ppf "object_field %a\n" fmt_location x.pof_loc;
+  attributes i ppf x.pof_attributes;
+  let i = i+1 in
+  match x.pof_desc with
+  | Otag (l, t) ->
+      line i ppf "Otag %a\n" fmt_string_loc l;
+      core_type i ppf t
+  | Oinherit ct ->
+      line i ppf "Oinherit\n";
+      core_type i ppf ct
+
 and package_with i ppf (s, t) =
   line i ppf "with type %a\n" fmt_longident_loc s;
   core_type i ppf t
 
 and pattern i ppf x =
   line i ppf "pattern %a\n" fmt_location x.ppat_loc;
+  sug_ext i ppf x.ppat_ext;
   attributes i ppf x.ppat_attributes;
   let i = i+1 in
   match x.ppat_desc with
   | Ppat_any -> line i ppf "Ppat_any\n";
   | Ppat_var (s) -> line i ppf "Ppat_var %a\n" fmt_string_loc s;
   | Ppat_alias (p, s) ->
       line i ppf "Ppat_alias %a\n" fmt_string_loc s;
       pattern i ppf p;
-  | Ppat_constant (c) -> line i ppf "Ppat_constant %a\n" fmt_constant c;
+  | Ppat_constant (c) ->
+      line i ppf "Ppat_constant\n";
+      fmt_constant i ppf c;
   | Ppat_interval (c1, c2) ->
-      line i ppf "Ppat_interval %a..%a\n" fmt_constant c1 fmt_constant c2;
+      line i ppf "Ppat_interval\n";
+      fmt_constant i ppf c1;
+      fmt_constant i ppf c2;
   | Ppat_tuple (l) ->
       line i ppf "Ppat_tuple\n";
       list i pattern ppf l;
   | Ppat_construct (li, po) ->
       line i ppf "Ppat_construct %a\n" fmt_longident_loc li;
@@@@
         ppf po
   | Ppat_variant (l, po) ->
       line i ppf "Ppat_variant \"%s\"\n" l;
       option i pattern ppf po;
   | Ppat_record (l, c) ->
-      line i ppf "Ppat_record %a\n" fmt_closed_flag c;
+      line i ppf "Ppat_record %a\n" fmt_closed_flag_loc c;
       list i longident_x_pattern ppf l;
   | Ppat_array (l) ->
       line i ppf "Ppat_array\n";
       list i pattern ppf l;
+  | Ppat_list (l) ->
+      line i ppf "Ppat_list\n";
+      list i pattern ppf l;
   | Ppat_or (p1, p2) ->
       line i ppf "Ppat_or\n";
       pattern i ppf p1;
       pattern i ppf p2;
   | Ppat_lazy p ->
@@@@
       pattern i ppf p
   | Ppat_open (m,p) ->
       line i ppf "Ppat_open \"%a\"\n" fmt_longident_loc m;
       pattern i ppf p
   | Ppat_extension (s, arg) ->
-      line i ppf "Ppat_extension \"%s\"\n" s.txt;
+      line i ppf "Ppat_extension %a\n" fmt_string_loc s;
       payload i ppf arg
 
 and expression i ppf x =
   line i ppf "expression %a\n" fmt_location x.pexp_loc;
+  sug_ext i ppf x.pexp_ext;
   attributes i ppf x.pexp_attributes;
   let i = i+1 in
   match x.pexp_desc with
   | Pexp_ident (li) -> line i ppf "Pexp_ident %a\n" fmt_longident_loc li;
-  | Pexp_constant (c) -> line i ppf "Pexp_constant %a\n" fmt_constant c;
+  | Pexp_constant (c) ->
+      line i ppf "Pexp_constant\n";
+      fmt_constant i ppf c;
   | Pexp_let (rf, l, e) ->
       line i ppf "Pexp_let %a\n" fmt_rec_flag rf;
       list i value_binding ppf l;
       expression i ppf e;
   | Pexp_function l ->
@@@@
       longident_loc i ppf li;
       expression i ppf e2;
   | Pexp_array (l) ->
       line i ppf "Pexp_array\n";
       list i expression ppf l;
+  | Pexp_list (l) ->
+      line i ppf "Pexp_list\n";
+      list i expression ppf l;
   | Pexp_ifthenelse (e1, e2, eo) ->
       line i ppf "Pexp_ifthenelse\n";
       expression i ppf e1;
       expression i ppf e2;
       option i expression ppf eo;
@@@@
       line i ppf "Pexp_coerce\n";
       expression i ppf e;
       option i core_type ppf cto1;
       core_type i ppf cto2;
   | Pexp_send (e, s) ->
-      line i ppf "Pexp_send \"%s\"\n" s.txt;
+      line i ppf "Pexp_send %a\n" fmt_string_loc s;
       expression i ppf e;
   | Pexp_new (li) -> line i ppf "Pexp_new %a\n" fmt_longident_loc li;
   | Pexp_setinstvar (s, e) ->
       line i ppf "Pexp_setinstvar %a\n" fmt_string_loc s;
       expression i ppf e;
@@@@
       option i core_type ppf cto;
   | Pexp_object s ->
       line i ppf "Pexp_object\n";
       class_structure i ppf s
   | Pexp_newtype (s, e) ->
-      line i ppf "Pexp_newtype \"%s\"\n" s.txt;
+      line i ppf "Pexp_newtype %a\n" fmt_string_loc s;
       expression i ppf e
   | Pexp_pack me ->
       line i ppf "Pexp_pack\n";
       module_expr i ppf me
   | Pexp_open (o, e) ->
-      line i ppf "Pexp_open %a\n" fmt_override_flag o.popen_override;
-      module_expr i ppf o.popen_expr;
+      line i ppf "Pexp_open\n";
+      open_declaration i ppf o;
       expression i ppf e
   | Pexp_letop {let_; ands; body} ->
       line i ppf "Pexp_letop\n";
       binding_op i ppf let_;
       list i binding_op ppf ands;
       expression i ppf body
   | Pexp_extension (s, arg) ->
-      line i ppf "Pexp_extension \"%s\"\n" s.txt;
+      line i ppf "Pexp_extension %a\n" fmt_string_loc s;
       payload i ppf arg
   | Pexp_unreachable ->
       line i ppf "Pexp_unreachable"
   | Pexp_hole ->
       line i ppf "Pexp_hole"
+  | Pexp_beginend e ->
+      line i ppf "Pexp_beginend\n";
+      option i expression ppf e
 
 and value_description i ppf x =
   line i ppf "value_description %a %a\n" fmt_string_loc
        x.pval_name fmt_location x.pval_loc;
   attributes i ppf x.pval_attributes;
@@@@
   line i ppf "ptype_private = %a\n" fmt_private_flag x.ptype_private;
   line i ppf "ptype_manifest =\n";
   option (i+1) core_type ppf x.ptype_manifest
 
 and attribute i ppf k a =
-  line i ppf "%s \"%s\"\n" k a.attr_name.txt;
+  line i ppf "%s %a %a\n" k fmt_string_loc a.attr_name fmt_location a.attr_loc;
   payload i ppf a.attr_payload;
 
 and attributes i ppf l =
   let i = i + 1 in
   List.iter (fun a ->
-    line i ppf "attribute \"%s\"\n" a.attr_name.txt;
+    line i ppf "attribute %a %a\n" fmt_string_loc a.attr_name
+      fmt_location a.attr_loc;
     payload (i + 1) ppf a.attr_payload;
   ) l;
 
 and payload i ppf = function
   | PStr x -> structure i ppf x
@@@@
       list (i+1) label_decl ppf l;
   | Ptype_open ->
       line i ppf "Ptype_open\n";
 
 and type_extension i ppf x =
-  line i ppf "type_extension\n";
+  line i ppf "type_extension %a\n" fmt_location x.ptyext_loc;
   attributes i ppf x.ptyext_attributes;
   let i = i+1 in
   line i ppf "ptyext_path = %a\n" fmt_longident_loc x.ptyext_path;
   line i ppf "ptyext_params =\n";
   list (i+1) type_parameter ppf x.ptyext_params;
   line i ppf "ptyext_constructors =\n";
   list (i+1) extension_constructor ppf x.ptyext_constructors;
   line i ppf "ptyext_private = %a\n" fmt_private_flag x.ptyext_private;
 
 and type_exception i ppf x =
-  line i ppf "type_exception\n";
+  line i ppf "type_exception %a\n" fmt_location x.ptyexn_loc;
   attributes i ppf x.ptyexn_attributes;
   let i = i+1 in
   line i ppf "ptyext_constructor =\n";
   let i = i+1 in
   extension_constructor i ppf x.ptyexn_constructor
 
 and extension_constructor i ppf x =
   line i ppf "extension_constructor %a\n" fmt_location x.pext_loc;
   attributes i ppf x.pext_attributes;
   let i = i + 1 in
-  line i ppf "pext_name = \"%s\"\n" x.pext_name.txt;
+  line i ppf "pext_name = %a\n" fmt_string_loc x.pext_name;
   line i ppf "pext_kind =\n";
   extension_constructor_kind (i + 1) ppf x.pext_kind;
 
 and extension_constructor_kind i ppf x =
   match x with
@@@@
       line i ppf "Pcty_arrow\n";
       arg_label i ppf l;
       core_type i ppf co;
       class_type i ppf cl;
   | Pcty_extension (s, arg) ->
-      line i ppf "Pcty_extension \"%s\"\n" s.txt;
+      line i ppf "Pcty_extension %a\n" fmt_string_loc s;
       payload i ppf arg
   | Pcty_open (o, e) ->
-      line i ppf "Pcty_open %a %a\n" fmt_override_flag o.popen_override
-        fmt_longident_loc o.popen_expr;
+      line i ppf "Pcty_open\n";
+      open_description i ppf o;
       class_type i ppf e
 
 and class_signature i ppf cs =
   line i ppf "class_signature\n";
   core_type (i+1) ppf cs.pcsig_self;
@@@@
   match x.pctf_desc with
   | Pctf_inherit (ct) ->
       line i ppf "Pctf_inherit\n";
       class_type i ppf ct;
   | Pctf_val (s, mf, vf, ct) ->
-      line i ppf "Pctf_val \"%s\" %a %a\n" s.txt fmt_mutable_flag mf
+      line i ppf "Pctf_val %a %a %a\n" fmt_string_loc s fmt_mutable_flag mf
            fmt_virtual_flag vf;
       core_type (i+1) ppf ct;
   | Pctf_method (s, pf, vf, ct) ->
-      line i ppf "Pctf_method \"%s\" %a %a\n" s.txt fmt_private_flag pf
+      line i ppf "Pctf_method %a %a %a\n" fmt_string_loc s fmt_private_flag pf
            fmt_virtual_flag vf;
       core_type (i+1) ppf ct;
   | Pctf_constraint (ct1, ct2) ->
       line i ppf "Pctf_constraint\n";
       core_type (i+1) ppf ct1;
       core_type (i+1) ppf ct2;
   | Pctf_attribute a ->
       attribute i ppf "Pctf_attribute" a
   | Pctf_extension (s, arg) ->
-      line i ppf "Pctf_extension \"%s\"\n" s.txt;
+      line i ppf "Pctf_extension %a\n" fmt_string_loc s;
      payload i ppf arg
 
 and class_description i ppf x =
   line i ppf "class_description %a\n" fmt_location x.pci_loc;
   attributes i ppf x.pci_attributes;
@@@@
   | Pcl_constraint (ce, ct) ->
       line i ppf "Pcl_constraint\n";
       class_expr i ppf ce;
       class_type i ppf ct;
   | Pcl_extension (s, arg) ->
-      line i ppf "Pcl_extension \"%s\"\n" s.txt;
+      line i ppf "Pcl_extension %a\n" fmt_string_loc s;
       payload i ppf arg
   | Pcl_open (o, e) ->
-      line i ppf "Pcl_open %a %a\n" fmt_override_flag o.popen_override
-        fmt_longident_loc o.popen_expr;
+      line i ppf "Pcl_open\n";
+      open_description i ppf o;
       class_expr i ppf e
 
 and class_structure i ppf { pcstr_self = p; pcstr_fields = l } =
   line i ppf "class_structure\n";
   pattern (i+1) ppf p;
@@@@
       line i ppf "Pcf_initializer\n";
       expression (i+1) ppf e;
   | Pcf_attribute a ->
       attribute i ppf "Pcf_attribute" a
   | Pcf_extension (s, arg) ->
-      line i ppf "Pcf_extension \"%s\"\n" s.txt;
+      line i ppf "Pcf_extension %a\n" fmt_string_loc s;
       payload i ppf arg
 
 and class_field_kind i ppf = function
   | Cfk_concrete (o, e) ->
       line i ppf "Concrete %a\n" fmt_override_flag o;
@@@@
       list i with_constraint ppf l;
   | Pmty_typeof m ->
       line i ppf "Pmty_typeof\n";
       module_expr i ppf m;
   | Pmty_extension (s, arg) ->
-      line i ppf "Pmod_extension \"%s\"\n" s.txt;
+      line i ppf "Pmod_extension %a\n" fmt_string_loc s;
       payload i ppf arg
 
 and signature i ppf x = list i signature_item ppf x
 
 and signature_item i ppf x =
   line i ppf "signature_item %a\n" fmt_location x.psig_loc;
   let i = i+1 in
   match x.psig_desc with
-  | Psig_value vd ->
+  | Psig_value (vd, ext) ->
       line i ppf "Psig_value\n";
+      sug_ext i ppf ext;
       value_description i ppf vd;
-  | Psig_type (rf, l) ->
+  | Psig_type (rf, l, ext) ->
       line i ppf "Psig_type %a\n" fmt_rec_flag rf;
+      sug_ext i ppf ext;
       list i type_declaration ppf l;
-  | Psig_typesubst l ->
+  | Psig_typesubst (l, ext) ->
       line i ppf "Psig_typesubst\n";
+      sug_ext i ppf ext;
       list i type_declaration ppf l;
-  | Psig_typext te ->
+  | Psig_typext (te, ext) ->
       line i ppf "Psig_typext\n";
+      sug_ext i ppf ext;
       type_extension i ppf te
-  | Psig_exception te ->
+  | Psig_exception (te, ext) ->
       line i ppf "Psig_exception\n";
+      sug_ext i ppf ext;
       type_exception i ppf te
-  | Psig_module pmd ->
-      line i ppf "Psig_module %a\n" fmt_str_opt_loc pmd.pmd_name;
-      attributes i ppf pmd.pmd_attributes;
-      module_type i ppf pmd.pmd_type
-  | Psig_modsubst pms ->
+  | Psig_module (pmd, ext) ->
+      line i ppf "Psig_module\n";
+      sug_ext i ppf ext;
+      module_declaration i ppf pmd
+  | Psig_modsubst (pms, ext) ->
       line i ppf "Psig_modsubst %a = %a\n"
         fmt_string_loc pms.pms_name
         fmt_longident_loc pms.pms_manifest;
+      fmt_location ppf pms.pms_loc;
+      sug_ext i ppf ext;
       attributes i ppf pms.pms_attributes;
-  | Psig_recmodule decls ->
+  | Psig_recmodule (decls, ext) ->
       line i ppf "Psig_recmodule\n";
+      sug_ext i ppf ext;
       list i module_declaration ppf decls;
-  | Psig_modtype x ->
-      line i ppf "Psig_modtype %a\n" fmt_string_loc x.pmtd_name;
-      attributes i ppf x.pmtd_attributes;
-      modtype_declaration i ppf x.pmtd_type
-  | Psig_modtypesubst x ->
-      line i ppf "Psig_modtypesubst %a\n" fmt_string_loc x.pmtd_name;
-      attributes i ppf x.pmtd_attributes;
-      modtype_declaration i ppf x.pmtd_type
-  | Psig_open od ->
-      line i ppf "Psig_open %a %a\n" fmt_override_flag od.popen_override
-        fmt_longident_loc od.popen_expr;
-      attributes i ppf od.popen_attributes
-  | Psig_include incl ->
+  | Psig_modtype (x, ext) ->
+      line i ppf "Psig_modtype\n";
+      sug_ext i ppf ext;
+      module_type_declaration i ppf x
+  | Psig_modtypesubst (x, ext) ->
+      line i ppf "Psig_modtypesubst\n";
+      sug_ext i ppf ext;
+      module_type_declaration i ppf x
+  | Psig_open (od, ext) ->
+      line i ppf "Psig_open\n";
+      sug_ext i ppf ext;
+      open_description i ppf od
+  | Psig_include (incl, ext) ->
       line i ppf "Psig_include\n";
-      module_type i ppf incl.pincl_mod;
-      attributes i ppf incl.pincl_attributes
-  | Psig_class (l) ->
+      sug_ext i ppf ext;
+      include_description i ppf incl
+  | Psig_class (l, ext) ->
       line i ppf "Psig_class\n";
+      sug_ext i ppf ext;
       list i class_description ppf l;
-  | Psig_class_type (l) ->
+  | Psig_class_type (l, ext) ->
       line i ppf "Psig_class_type\n";
+      sug_ext i ppf ext;
       list i class_type_declaration ppf l;
   | Psig_extension ((s, arg), attrs) ->
-      line i ppf "Psig_extension \"%s\"\n" s.txt;
+      line i ppf "Psig_extension %a\n" fmt_string_loc s;
       attributes i ppf attrs;
       payload i ppf arg
   | Psig_attribute a ->
       attribute i ppf "Psig_attribute" a
 
@@@@
       module_type i ppf mt;
   | Pmod_unpack (e) ->
       line i ppf "Pmod_unpack\n";
       expression i ppf e;
   | Pmod_extension (s, arg) ->
-      line i ppf "Pmod_extension \"%s\"\n" s.txt;
+      line i ppf "Pmod_extension %a\n" fmt_string_loc s;
       payload i ppf arg
   | Pmod_hole ->
       line i ppf "Pmod_hole"
 
 and structure i ppf x = list i structure_item ppf x
@@@@
   match x.pstr_desc with
   | Pstr_eval (e, attrs) ->
       line i ppf "Pstr_eval\n";
       attributes i ppf attrs;
       expression i ppf e;
-  | Pstr_value (rf, l) ->
+  | Pstr_value (rf, l, ext) ->
       line i ppf "Pstr_value %a\n" fmt_rec_flag rf;
+      sug_ext i ppf ext;
       list i value_binding ppf l;
-  | Pstr_primitive vd ->
+  | Pstr_primitive (vd, ext) ->
       line i ppf "Pstr_primitive\n";
+      sug_ext i ppf ext;
       value_description i ppf vd;
-  | Pstr_type (rf, l) ->
+  | Pstr_type (rf, l, ext) ->
       line i ppf "Pstr_type %a\n" fmt_rec_flag rf;
+      sug_ext i ppf ext;
       list i type_declaration ppf l;
-  | Pstr_typext te ->
+  | Pstr_typext (te, ext) ->
       line i ppf "Pstr_typext\n";
+      sug_ext i ppf ext;
       type_extension i ppf te
-  | Pstr_exception te ->
+  | Pstr_exception (te, ext) ->
       line i ppf "Pstr_exception\n";
+      sug_ext i ppf ext;
       type_exception i ppf te
-  | Pstr_module x ->
+  | Pstr_module (x, ext) ->
       line i ppf "Pstr_module\n";
+      sug_ext i ppf ext;
       module_binding i ppf x
-  | Pstr_recmodule bindings ->
+  | Pstr_recmodule (bindings, ext) ->
       line i ppf "Pstr_recmodule\n";
+      sug_ext i ppf ext;
       list i module_binding ppf bindings;
-  | Pstr_modtype x ->
-      line i ppf "Pstr_modtype %a\n" fmt_string_loc x.pmtd_name;
-      attributes i ppf x.pmtd_attributes;
-      modtype_declaration i ppf x.pmtd_type
-  | Pstr_open od ->
-      line i ppf "Pstr_open %a\n" fmt_override_flag od.popen_override;
-      module_expr i ppf od.popen_expr;
-      attributes i ppf od.popen_attributes
-  | Pstr_class (l) ->
+  | Pstr_modtype (x, ext) ->
+      line i ppf "Pstr_modtype\n";
+      sug_ext i ppf ext;
+      module_type_declaration i ppf x
+  | Pstr_open (od, ext) ->
+      line i ppf "Pstr_open\n";
+      sug_ext i ppf ext;
+      open_declaration i ppf od
+  | Pstr_class (l, ext) ->
       line i ppf "Pstr_class\n";
+      sug_ext i ppf ext;
       list i class_declaration ppf l;
-  | Pstr_class_type (l) ->
+  | Pstr_class_type (l, ext) ->
       line i ppf "Pstr_class_type\n";
+      sug_ext i ppf ext;
       list i class_type_declaration ppf l;
-  | Pstr_include incl ->
-      line i ppf "Pstr_include";
-      attributes i ppf incl.pincl_attributes;
-      module_expr i ppf incl.pincl_mod
+  | Pstr_include (incl, ext) ->
+      line i ppf "Pstr_include\n";
+      sug_ext i ppf ext;
+      include_declaration i ppf incl
   | Pstr_extension ((s, arg), attrs) ->
-      line i ppf "Pstr_extension \"%s\"\n" s.txt;
+      line i ppf "Pstr_extension %a\n" fmt_string_loc s;
       attributes i ppf attrs;
       payload i ppf arg
   | Pstr_attribute a ->
       attribute i ppf "Pstr_attribute" a
 
+and module_type_declaration i ppf x =
+  line i ppf "module_type_declaration %a %a\n" fmt_string_loc x.pmtd_name
+    fmt_location x.pmtd_loc;
+  attributes i ppf x.pmtd_attributes;
+  modtype_declaration (i+1) ppf x.pmtd_type
+
 and module_declaration i ppf pmd =
-  str_opt_loc i ppf pmd.pmd_name;
+  line i ppf "module_declaration %a %a\n" fmt_str_opt_loc pmd.pmd_name
+    fmt_location pmd.pmd_loc;
   attributes i ppf pmd.pmd_attributes;
   module_type (i+1) ppf pmd.pmd_type;
 
 and module_binding i ppf x =
-  str_opt_loc i ppf x.pmb_name;
+  line i ppf "module_binding %a %a\n" fmt_str_opt_loc x.pmb_name
+    fmt_location x.pmb_loc;
   attributes i ppf x.pmb_attributes;
   module_expr (i+1) ppf x.pmb_expr
 
 and core_type_x_core_type_x_location i ppf (ct1, ct2, l) =
   line i ppf "<constraint> %a\n" fmt_location l;
@@@@
   | None -> ()
   | Some g -> line (i+1) ppf "<when>\n"; expression (i + 2) ppf g
   end;
   expression (i+1) ppf pc_rhs;
 
+and open_description i ppf x =
+  line i ppf "open_description %a %a\n" fmt_override_flag x.popen_override
+    fmt_location x.popen_loc;
+  attributes i ppf x.popen_attributes;
+  fmt_longident_loc ppf x.popen_expr
+
+and open_declaration i ppf x =
+  line i ppf "open_declaration %a %a\n" fmt_override_flag x.popen_override
+    fmt_location x.popen_loc;
+  attributes i ppf x.popen_attributes;
+  let i = i+1 in
+  module_expr i ppf x.popen_expr
+
+and include_description i ppf x =
+  line i ppf "include_description %a\n" fmt_location x.pincl_loc;
+  attributes i ppf x.pincl_attributes;
+  let i = i+1 in
+  module_type i ppf x.pincl_mod
+
+and include_declaration i ppf x =
+  line i ppf "include_declaration %a\n" fmt_location x.pincl_loc;
+  attributes i ppf x.pincl_attributes;
+  let i = i+1 in
+  module_expr i ppf x.pincl_mod
+
 and value_binding i ppf x =
-  line i ppf "<def>\n";
+  line i ppf "<def> %a\n" fmt_location x.pvb_loc;
   attributes (i+1) ppf x.pvb_attributes;
   pattern (i+1) ppf x.pvb_pat;
   expression (i+1) ppf x.pvb_expr
 
 and binding_op i ppf x =
@@@@
 and label_x_expression i ppf (l,e) =
   line i ppf "<arg>\n";
   arg_label i ppf l;
   expression (i+1) ppf e;
 
-and label_x_bool_x_core_type_list i ppf x =
+and row_field i ppf x =
+  line i ppf "row_field %a\n" fmt_location x.prf_loc;
+  attributes i ppf x.prf_attributes;
+  let i = i+1 in
   match x.prf_desc with
-    Rtag (l, b, ctl) ->
-      line i ppf "Rtag \"%s\" %s\n" l.txt (string_of_bool b);
-      attributes (i+1) ppf x.prf_attributes;
-      list (i+1) core_type ppf ctl
+  | Rtag (l, b, ctl) ->
+      line i ppf "Rtag %a %s\n" fmt_string_loc l (string_of_bool b);
+      list i core_type ppf ctl
   | Rinherit (ct) ->
       line i ppf "Rinherit\n";
-      core_type (i+1) ppf ct
+      core_type i ppf ct
 
 let rec toplevel_phrase i ppf x =
   match x with
   | Ptop_def (s) ->
       line i ppf "Ptop_def\n";
       structure (i+1) ppf s;
-  | Ptop_dir {pdir_name; pdir_arg; _} ->
-      line i ppf "Ptop_dir \"%s\"\n" pdir_name.txt;
+  | Ptop_dir {pdir_name; pdir_arg; pdir_loc} ->
+      line i ppf "Ptop_dir %a %a\n" fmt_string_loc pdir_name
+        fmt_location pdir_loc;
       match pdir_arg with
       | None -> ()
       | Some da -> directive_argument i ppf da;
 
 and directive_argument i ppf x =
+  line i ppf "directive_argument %a\n" fmt_location x.pdira_loc;
+  let i = i+1 in
   match x.pdira_desc with
   | Pdir_string (s) -> line i ppf "Pdir_string \"%s\"\n" s
   | Pdir_int (n, None) -> line i ppf "Pdir_int %s\n" n
   | Pdir_int (n, Some m) -> line i ppf "Pdir_int %s%c\n" n m
   | Pdir_ident (li) -> line i ppf "Pdir_ident %a\n" fmt_longident li
   | Pdir_bool (b) -> line i ppf "Pdir_bool %s\n" (string_of_bool b)
 
+let repl_phrase i ppf x =
+  line i ppf "repl_phrase\n";
+  let i = i+1 in
+  toplevel_phrase i ppf x.prepl_phrase;
+  line i ppf "output %S\n" x.prepl_output
+
 let interface ppf x = list 0 signature_item ppf x
 
 let implementation ppf x = list 0 structure_item ppf x
 
 let top_phrase ppf x = toplevel_phrase 0 ppf x
+
+let repl_phrase ppf x = repl_phrase 0 ppf x
+
+let expression ppf x = expression 0 ppf x
+
+let payload ppf x = payload 0 ppf x
+
+let core_type ppf x = core_type 0 ppf x
+
+let module_type ppf x = module_type 0 ppf x
+
+let pattern ppf x = pattern 0 ppf x
+
+let type_declaration ppf x = type_declaration 0 ppf x
+
+let value_binding ppf x = value_binding 0 ppf x
+
+let class_expr ppf x = class_expr 0 ppf x
+
+let class_type ppf x = class_type 0 ppf x
+
+let class_field ppf x = class_field 0 ppf x
+
+let class_type_field ppf x = class_type_field 0 ppf x
+
+let module_expr ppf x = module_expr 0 ppf x
+
+let structure_item ppf x = structure_item 0 ppf x
+
+let signature_item ppf x = signature_item 0 ppf x
--- parser-standard/printast.mli
+++ parser-extended/printast.mli
@@@@
 open Format
 
 val interface : formatter -> signature_item list -> unit
 val implementation : formatter -> structure_item list -> unit
 val top_phrase : formatter -> toplevel_phrase -> unit
+val repl_phrase : formatter -> repl_phrase -> unit
 
-val expression: int -> formatter -> expression -> unit
+val expression: formatter -> expression -> unit
 val structure: int -> formatter -> structure -> unit
-val payload: int -> formatter -> payload -> unit
-val core_type: int -> formatter -> core_type -> unit
-val module_type: int -> formatter -> module_type -> unit
+val payload: formatter -> payload -> unit
+val core_type: formatter -> core_type -> unit
+val module_type: formatter -> module_type -> unit
+val pattern: formatter -> pattern -> unit
+val type_declaration: formatter -> type_declaration -> unit
+val value_binding: formatter -> value_binding -> unit
+val class_expr: formatter -> class_expr -> unit
+val class_type: formatter -> class_type -> unit
+val class_field: formatter -> class_field -> unit
+val class_type_field: formatter -> class_type_field -> unit
+val module_expr: formatter -> module_expr -> unit
+val structure_item: formatter -> structure_item -> unit
+val signature_item: formatter -> signature_item -> unit
+
+type cmts =
+  { before: Location.t -> string list option
+  ; within: Location.t -> string list option
+  ; after: Location.t -> string list option }
+
+val cmts : cmts option ref
