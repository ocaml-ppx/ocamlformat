--- parser-upstream/format.ml
+++ ocamlformat_support/format.ml
@@@@
   | Pp_tbegin of tbox          (* beginning of a tabulation box *)
   | Pp_tend                    (* end of a tabulation box *)
   | Pp_newline                 (* to force a newline inside a box *)
   | Pp_if_newline              (* to do something only if this very
                                   line has been broken *)
+  | Pp_string_if_newline of string
+                               (* print a string only if this very
+                                  line has been broken *)
+  | Pp_or_newline of int * int * string * string
+                               (* print a break and the first string if this
+                                  very line has not been broken, otherwise
+                                  print the second string *)
+  | Pp_fits_or_breaks of int * string * int * int * string
+                               (* print a string if the enclosing box fits,
+                                  otherwise print a break and a string *)
   | Pp_open_tag of stag         (* opening a tag name *)
   | Pp_close_tag               (* closing the most recently open tag *)
 
 and stag = ..
 
@@@@
 
   The main pretty printing functions.
 
 *)
 
+let format_pp_break state size fits breaks =
+  let before, off, _ = breaks in
+  begin match Stack.top_opt state.pp_format_stack with
+  | None -> () (* No open box. *)
+  | Some { box_type; width } ->
+    begin match box_type with
+    | Pp_hovbox ->
+      if size + String.length before > state.pp_space_left
+      then break_new_line state breaks width
+      else break_same_line state fits
+    | Pp_box ->
+      (* Have the line just been broken here ? *)
+      if state.pp_is_new_line then break_same_line state fits else
+      if size + String.length before > state.pp_space_left
+      then break_new_line state breaks width else
+      (* break the line here leads to new indentation ? *)
+      if state.pp_current_indent > state.pp_margin - width + off
+      then break_new_line state breaks width
+      else break_same_line state fits
+    | Pp_hvbox -> break_new_line state breaks width
+    | Pp_fits -> break_same_line state fits
+    | Pp_vbox -> break_new_line state breaks width
+    | Pp_hbox -> break_same_line state fits
+    end
+  end
+
+
 (* Formatting a token with a given size. *)
 let format_pp_token state size = function
 
   | Pp_text s ->
     format_pp_text state size s
@@@@
 
   | Pp_if_newline ->
     if state.pp_current_indent != state.pp_margin - state.pp_space_left
     then pp_skip_token state
 
+  | Pp_string_if_newline s ->
+    if state.pp_is_new_line
+    then format_string state s
+
   | Pp_break { fits; breaks } ->
-    let before, off, _ = breaks in
-    begin match Stack.top_opt state.pp_format_stack with
-    | None -> () (* No open box. *)
-    | Some { box_type; width } ->
-      begin match box_type with
-      | Pp_hovbox ->
-        if size + String.length before > state.pp_space_left
-        then break_new_line state breaks width
-        else break_same_line state fits
-      | Pp_box ->
-        (* Have the line just been broken here ? *)
-        if state.pp_is_new_line then break_same_line state fits else
-        if size + String.length before > state.pp_space_left
-          then break_new_line state breaks width else
-        (* break the line here leads to new indentation ? *)
-        if state.pp_current_indent > state.pp_margin - width + off
-        then break_new_line state breaks width
-        else break_same_line state fits
-      | Pp_hvbox -> break_new_line state breaks width
-      | Pp_fits -> break_same_line state fits
-      | Pp_vbox -> break_new_line state breaks width
-      | Pp_hbox -> break_same_line state fits
-      end
-    end
+    format_pp_break state size fits breaks
 
+
+  | Pp_or_newline (n, off, fits, breaks) ->
+    if state.pp_is_new_line
+    then format_string state breaks
+    else format_pp_break state size ("", n, fits) ("", off, breaks)
+
+  | Pp_fits_or_breaks (level, fits, n, off, breaks) ->
+     let check_level level { box_type= ty; width } =
+       if level < 0 then level
+       else if ty = Pp_fits then
+         begin
+           if level = 0 then format_string state fits ;
+           level - 1
+         end
+       else
+         begin
+           if off > min_int then
+             begin
+               if size + n + String.length breaks >= state.pp_space_left
+               then break_new_line state ("", off, "") width
+               else break_same_line state ("", n, "")
+             end;
+           format_string state breaks;
+           - 1
+         end
+     in
+     ignore (Stack.fold check_level level state.pp_format_stack)
+
    | Pp_open_tag tag_name ->
      let marker = state.pp_mark_open_tag tag_name in
      pp_output_string state marker;
      Stack.push tag_name state.pp_mark_stack
 
@@@@
     (* test if scan stack contains any data that is not obsolete. *)
     if left_total < state.pp_left_total then
       initialize_scan_stack state.pp_scan_stack
     else
       match queue_elem.token with
-      | Pp_break _ | Pp_tbreak (_, _) ->
+      | Pp_break _ | Pp_tbreak (_, _)
+      | Pp_or_newline _ | Pp_fits_or_breaks _ ->
         if ty then begin
           queue_elem.size <- Size.of_int (state.pp_right_total + size);
           Stack.pop_opt state.pp_scan_stack |> ignore
         end
       | Pp_begin (_, _) ->
         if not ty then begin
           queue_elem.size <- Size.of_int (state.pp_right_total + size);
           Stack.pop_opt state.pp_scan_stack |> ignore
         end
       | Pp_text _ | Pp_stab | Pp_tbegin _ | Pp_tend | Pp_end
-      | Pp_newline | Pp_if_newline | Pp_open_tag _ | Pp_close_tag ->
+      | Pp_newline | Pp_if_newline | Pp_string_if_newline _
+      | Pp_open_tag _ | Pp_close_tag ->
         () (* scan_push is only used for breaks and boxes. *)
 
 
 (* Push a token on pretty-printer scanning stack.
    If b is true set_size is called. *)
@@@@
     match Stack.pop_opt state.pp_tag_stack with
     | None -> () (* No more tag to close. *)
     | Some tag_name ->
       state.pp_print_close_tag tag_name
 
+let pp_open_tag state s = pp_open_stag state (String_tag s)
+let pp_close_tag state () = pp_close_stag state ()
+
 let pp_set_print_tags state b = state.pp_print_tags <- b
 let pp_set_mark_tags state b = state.pp_mark_tags <- b
 let pp_get_print_tags state () = state.pp_print_tags
 let pp_get_mark_tags state () = state.pp_mark_tags
 let pp_set_tags state b =
@@@@
   state.pp_curr_depth <- 0;
   state.pp_space_left <- state.pp_margin;
   pp_open_sys_box state
 
 let clear_tag_stack state =
-  Stack.iter (fun _ -> pp_close_stag state ()) state.pp_tag_stack
+  Stack.iter (fun _ -> pp_close_tag state ()) state.pp_tag_stack
 
 
 (* Flushing pretty-printer queue. *)
 let pp_flush_queue state b =
   clear_tag_stack state;
@@@@
     let token = Pp_break { fits; breaks } in
     let length = String.length before + width + String.length after in
     let elem = { size; token; length } in
     scan_push state true elem
 
+(* To format a string, only in case the line has just been broken. *)
+let pp_print_string_if_newline state s =
+  if state.pp_curr_depth < state.pp_max_boxes then
+    let length = String.length s in
+    let size = Size.zero in
+    let token = Pp_string_if_newline s in
+    enqueue_advance state { size; token; length }
+
+
 (* Printing break hints:
    A break hint indicates where a box may be broken.
    If line is broken then offset is added to the indentation of the current
    box else (the value of) width blanks are printed. *)
 let pp_print_break state width offset =
   pp_print_custom_break state
     ~fits:("", width, "") ~breaks:("", offset, "")
 
 
+(* To format a break and the first string, only in case the line has not just
+   been broken, or the second string, in case the line has just been broken. *)
+let pp_print_or_newline state width offset fits breaks =
+  if state.pp_curr_depth < state.pp_max_boxes then
+    let size = Size.of_int (- state.pp_right_total) in
+    let token = Pp_or_newline (width, offset, fits, breaks) in
+    let width = width + String.length fits in
+    scan_push state true { size; token; length= width }
+
+
+(* To format a string if the enclosing box fits, and otherwise to format a
+   break and a string. *)
+let pp_print_fits_or_breaks state ?(level = 0) fits nspaces offset breaks =
+  if state.pp_curr_depth < state.pp_max_boxes then
+    let size = Size.of_int (- state.pp_right_total) in
+    let token = Pp_fits_or_breaks (level, fits, nspaces, offset, breaks) in
+    let length = String.length fits in
+    scan_push state true { size; token; length }
+
+
 (* Print a space :
    a space is a break hint that prints a single space if the break does not
    split the line;
    a cut is a break hint that prints nothing if the break does not split the
    line. *)
@@@@
 
 (* The default function to output indentation of new lines. *)
 let display_indent = display_blanks
 
 (* Setting a formatter basic output functions as printing to a given
-   [Stdlib.out_channel] value. *)
+   [Pervasive.out_channel] value. *)
 let pp_set_formatter_out_channel state oc =
   state.pp_out_string <- output_substring oc;
   state.pp_out_flush <- (fun () -> flush oc);
   state.pp_out_newline <- display_newline state;
   state.pp_out_spaces <- display_blanks state;
@@@@
   ppf.pp_out_spaces <- display_blanks ppf;
   ppf.pp_out_indent <- display_indent ppf;
   ppf
 
 
-(* Make a formatter writing to a given [Stdlib.out_channel] value. *)
+(* Make a formatter writing to a given [Pervasive.out_channel] value. *)
 let formatter_of_out_channel oc =
   make_formatter (output_substring oc) (fun () -> flush oc)
 
 
 (* Make a formatter writing to a given [Buffer.t] value. *)
@@@@
    to [Stdlib.stdout], [Stdlib.stderr], and {!stdbuf}. *)
 let std_formatter = formatter_of_out_channel Stdlib.stdout
 and err_formatter = formatter_of_out_channel Stdlib.stderr
 and str_formatter = formatter_of_buffer stdbuf
 
-(* Initialise domain local state *)
-module DLS = Domain.DLS
 
-let stdbuf_key = DLS.new_key pp_make_buffer
-let _ = DLS.set stdbuf_key stdbuf
-
-let str_formatter_key = DLS.new_key (fun () ->
-  formatter_of_buffer (DLS.get stdbuf_key))
-let _ = DLS.set str_formatter_key str_formatter
-
-let buffered_out_string key str ofs len =
-  Buffer.add_substring (Domain.DLS.get key) str ofs len
-
-let buffered_out_flush oc key () =
-  let buf = Domain.DLS.get key in
-  let len = Buffer.length buf in
-  let str = Buffer.contents buf in
-  output_substring oc str 0 len ;
-  Stdlib.flush oc;
-  Buffer.clear buf
-
-let std_buf_key = Domain.DLS.new_key (fun () -> Buffer.create pp_buffer_size)
-let err_buf_key = Domain.DLS.new_key (fun () -> Buffer.create pp_buffer_size)
-
-let std_formatter_key = DLS.new_key (fun () ->
-  let ppf =
-    pp_make_formatter (buffered_out_string std_buf_key)
-      (buffered_out_flush Stdlib.stdout std_buf_key) ignore ignore ignore
-  in
-  ppf.pp_out_newline <- display_newline ppf;
-  ppf.pp_out_spaces <- display_blanks ppf;
-  ppf.pp_out_indent <- display_indent ppf;
-  Domain.at_exit (pp_print_flush ppf);
-  ppf)
-let _ = DLS.set std_formatter_key std_formatter
-
-let err_formatter_key = DLS.new_key (fun () ->
-  let ppf =
-    pp_make_formatter (buffered_out_string err_buf_key)
-      (buffered_out_flush Stdlib.stderr err_buf_key) ignore ignore ignore
-  in
-  ppf.pp_out_newline <- display_newline ppf;
-  ppf.pp_out_spaces <- display_blanks ppf;
-  ppf.pp_out_indent <- display_indent ppf;
-  Domain.at_exit (pp_print_flush ppf);
-  ppf)
-let _ = DLS.set err_formatter_key err_formatter
-
-let get_std_formatter () = DLS.get std_formatter_key
-let get_err_formatter () = DLS.get err_formatter_key
-let get_str_formatter () = DLS.get str_formatter_key
-let get_stdbuf () = DLS.get stdbuf_key
-
 (* [flush_buffer_formatter buf ppf] flushes formatter [ppf],
    then returns the contents of buffer [buf] that is reset.
    Formatter [ppf] is supposed to print to buffer [buf], otherwise this
    function is not really useful. *)
 let flush_buffer_formatter buf ppf =
   pp_flush_queue ppf false;
   let s = Buffer.contents buf in
   Buffer.reset buf;
   s
 
+
 (* Flush [str_formatter] and get the contents of [stdbuf]. *)
-let flush_str_formatter () =
-  let stdbuf = DLS.get stdbuf_key in
-  let str_formatter = DLS.get str_formatter_key in
-  flush_buffer_formatter stdbuf str_formatter
+let flush_str_formatter () = flush_buffer_formatter stdbuf str_formatter
 
-let make_synchronized_formatter output flush =
-  DLS.new_key (fun () ->
-    let buf = Buffer.create pp_buffer_size in
-    let output' = Buffer.add_substring buf in
-    let flush' () =
-      output (Buffer.contents buf) 0 (Buffer.length buf);
-      Buffer.clear buf;
-      flush ()
-    in
-    make_formatter output' flush')
-
-let synchronized_formatter_of_out_channel oc =
-  make_synchronized_formatter (output_substring oc) (fun () -> flush oc)
-
 (*
   Symbolic pretty-printing
 *)
 
 (*
@@@@
   Basic functions on the 'standard' formatter
   (the formatter that prints to [Stdlib.stdout]).
 
 *)
 
-let open_hbox v = pp_open_hbox (DLS.get std_formatter_key) v
-and open_vbox v = pp_open_vbox (DLS.get std_formatter_key) v
-and open_hvbox v = pp_open_hvbox (DLS.get std_formatter_key) v
-and open_hovbox v = pp_open_hovbox (DLS.get std_formatter_key) v
-and open_box v = pp_open_box (DLS.get std_formatter_key) v
-and close_box v = pp_close_box (DLS.get std_formatter_key) v
-and open_stag v = pp_open_stag (DLS.get std_formatter_key) v
-and close_stag v = pp_close_stag (DLS.get std_formatter_key) v
-and print_as v w = pp_print_as (DLS.get std_formatter_key) v w
-and print_string v = pp_print_string (DLS.get std_formatter_key) v
-and print_bytes v = pp_print_bytes (DLS.get std_formatter_key) v
-and print_int v = pp_print_int (DLS.get std_formatter_key) v
-and print_float v = pp_print_float (DLS.get std_formatter_key) v
-and print_char v = pp_print_char (DLS.get std_formatter_key) v
-and print_bool v = pp_print_bool (DLS.get std_formatter_key) v
-and print_break v w = pp_print_break (DLS.get std_formatter_key) v w
-and print_cut v = pp_print_cut (DLS.get std_formatter_key) v
-and print_space v = pp_print_space (DLS.get std_formatter_key) v
-and force_newline v = pp_force_newline (DLS.get std_formatter_key) v
-and print_flush v = pp_print_flush (DLS.get std_formatter_key) v
-and print_newline v = pp_print_newline (DLS.get std_formatter_key) v
-and print_if_newline v = pp_print_if_newline (DLS.get std_formatter_key) v
+let open_hbox = pp_open_hbox std_formatter
+and open_vbox = pp_open_vbox std_formatter
+and open_hvbox = pp_open_hvbox std_formatter
+and open_hovbox = pp_open_hovbox std_formatter
+and open_box = pp_open_box std_formatter
+and close_box = pp_close_box std_formatter
+and open_tag = pp_open_tag std_formatter
+and close_tag = pp_close_tag std_formatter
+and open_stag = pp_open_stag std_formatter
+and close_stag = pp_close_stag std_formatter
+and print_as = pp_print_as std_formatter
+and print_string = pp_print_string std_formatter
+and print_bytes = pp_print_bytes std_formatter
+and print_int = pp_print_int std_formatter
+and print_float = pp_print_float std_formatter
+and print_char = pp_print_char std_formatter
+and print_bool = pp_print_bool std_formatter
+and print_break = pp_print_break std_formatter
+and print_cut = pp_print_cut std_formatter
+and print_space = pp_print_space std_formatter
+and force_newline = pp_force_newline std_formatter
+and print_flush = pp_print_flush std_formatter
+and print_newline = pp_print_newline std_formatter
+and print_if_newline = pp_print_if_newline std_formatter
 
-and open_tbox v = pp_open_tbox (DLS.get std_formatter_key) v
-and close_tbox v = pp_close_tbox (DLS.get std_formatter_key) v
-and print_tbreak v w = pp_print_tbreak (DLS.get std_formatter_key) v w
+and open_tbox = pp_open_tbox std_formatter
+and close_tbox = pp_close_tbox std_formatter
+and print_tbreak = pp_print_tbreak std_formatter
 
-and set_tab v = pp_set_tab (DLS.get std_formatter_key) v
-and print_tab v = pp_print_tab (DLS.get std_formatter_key) v
+and set_tab = pp_set_tab std_formatter
+and print_tab = pp_print_tab std_formatter
 
-and set_margin v = pp_set_margin (DLS.get std_formatter_key) v
-and get_margin v = pp_get_margin (DLS.get std_formatter_key) v
+and set_margin = pp_set_margin std_formatter
+and get_margin = pp_get_margin std_formatter
 
-and set_max_indent v = pp_set_max_indent (DLS.get std_formatter_key) v
-and get_max_indent v = pp_get_max_indent (DLS.get std_formatter_key) v
+and set_max_indent = pp_set_max_indent std_formatter
+and get_max_indent = pp_get_max_indent std_formatter
 
-and set_geometry ~max_indent ~margin =
-  pp_set_geometry (DLS.get std_formatter_key) ~max_indent ~margin
-and safe_set_geometry ~max_indent ~margin =
-  pp_safe_set_geometry (DLS.get std_formatter_key) ~max_indent ~margin
-and get_geometry v = pp_get_geometry (DLS.get std_formatter_key) v
-and update_geometry v = pp_update_geometry (DLS.get std_formatter_key) v
+and set_geometry = pp_set_geometry std_formatter
+and safe_set_geometry = pp_safe_set_geometry std_formatter
+and get_geometry = pp_get_geometry std_formatter
+and update_geometry = pp_update_geometry std_formatter
 
-and set_max_boxes v = pp_set_max_boxes (DLS.get std_formatter_key) v
-and get_max_boxes v = pp_get_max_boxes (DLS.get std_formatter_key) v
-and over_max_boxes v = pp_over_max_boxes (DLS.get std_formatter_key) v
+and set_max_boxes = pp_set_max_boxes std_formatter
+and get_max_boxes = pp_get_max_boxes std_formatter
+and over_max_boxes = pp_over_max_boxes std_formatter
 
-and set_ellipsis_text v = pp_set_ellipsis_text (DLS.get std_formatter_key) v
-and get_ellipsis_text v = pp_get_ellipsis_text (DLS.get std_formatter_key) v
+and set_ellipsis_text = pp_set_ellipsis_text std_formatter
+and get_ellipsis_text = pp_get_ellipsis_text std_formatter
 
-and set_formatter_out_channel v =
-  pp_set_formatter_out_channel (DLS.get std_formatter_key) v
+and set_formatter_out_channel =
+  pp_set_formatter_out_channel std_formatter
 
-and set_formatter_out_functions v =
-  pp_set_formatter_out_functions (DLS.get std_formatter_key) v
-and get_formatter_out_functions v =
-  pp_get_formatter_out_functions (DLS.get std_formatter_key) v
+and set_formatter_out_functions =
+  pp_set_formatter_out_functions std_formatter
+and get_formatter_out_functions =
+  pp_get_formatter_out_functions std_formatter
 
-and set_formatter_output_functions v w =
-  pp_set_formatter_output_functions (DLS.get std_formatter_key) v w
-and get_formatter_output_functions v =
-  pp_get_formatter_output_functions (DLS.get std_formatter_key) v
+and set_formatter_output_functions =
+  pp_set_formatter_output_functions std_formatter
+and get_formatter_output_functions =
+  pp_get_formatter_output_functions std_formatter
 
-and set_formatter_stag_functions v =
-  pp_set_formatter_stag_functions (DLS.get std_formatter_key) v
-and get_formatter_stag_functions v =
-  pp_get_formatter_stag_functions (DLS.get std_formatter_key) v
-and set_print_tags v =
-  pp_set_print_tags (DLS.get std_formatter_key) v
-and get_print_tags v =
-  pp_get_print_tags (DLS.get std_formatter_key) v
-and set_mark_tags v =
-  pp_set_mark_tags (DLS.get std_formatter_key) v
-and get_mark_tags v =
-  pp_get_mark_tags (DLS.get std_formatter_key) v
-and set_tags v =
-  pp_set_tags (DLS.get std_formatter_key) v
+and set_formatter_stag_functions =
+  pp_set_formatter_stag_functions std_formatter
+and get_formatter_stag_functions =
+  pp_get_formatter_stag_functions std_formatter
+and set_print_tags =
+  pp_set_print_tags std_formatter
+and get_print_tags =
+  pp_get_print_tags std_formatter
+and set_mark_tags =
+  pp_set_mark_tags std_formatter
+and get_mark_tags =
+  pp_get_mark_tags std_formatter
+and set_tags =
+  pp_set_tags std_formatter
 
 
 (* Convenience functions *)
 
-let pp_print_iter ?(pp_sep = pp_print_cut) iter pp_v ppf v =
-  let is_first = ref true in
-  let pp_v v =
-    if !is_first then is_first := false else pp_sep ppf ();
-    pp_v ppf v
-  in
-  iter pp_v v
-
 (* To format a list *)
-let pp_print_list ?(pp_sep = pp_print_cut) pp_v ppf v =
-  pp_print_iter ~pp_sep List.iter pp_v ppf v
+let rec pp_print_list ?(pp_sep = pp_print_cut) pp_v ppf = function
+  | [] -> ()
+  | [v] -> pp_v ppf v
+  | v :: vs ->
+    pp_v ppf v;
+    pp_sep ppf ();
+    pp_print_list ~pp_sep pp_v ppf vs
 
-(* To format an array *)
-let pp_print_array ?(pp_sep = pp_print_cut) pp_v ppf v =
-  pp_print_iter ~pp_sep Array.iter pp_v ppf v
-
 (* To format a sequence *)
+let rec pp_print_seq_in ~pp_sep pp_v ppf seq =
+  match seq () with
+  | Seq.Nil -> ()
+  | Seq.Cons (v, seq) ->
+    pp_sep ppf ();
+    pp_v ppf v;
+    pp_print_seq_in ~pp_sep pp_v ppf seq
+
 let pp_print_seq ?(pp_sep = pp_print_cut) pp_v ppf seq =
-  pp_print_iter ~pp_sep Seq.iter pp_v ppf seq
+  match seq () with
+  | Seq.Nil -> ()
+  | Seq.Cons (v, seq) ->
+    pp_v ppf v;
+    pp_print_seq_in ~pp_sep pp_v ppf seq
 
 (* To format free-flowing text *)
 let pp_print_text ppf s =
   let len = String.length s in
   let left = ref 0 in
@@@@
 open CamlinternalFormat
 
 (* Interpret a formatting entity on a formatter. *)
 let output_formatting_lit ppf fmting_lit = match fmting_lit with
   | Close_box                 -> pp_close_box ppf ()
-  | Close_tag                 -> pp_close_stag ppf ()
+  | Close_tag                 -> pp_close_tag ppf ()
   | Break (_, width, offset)  -> pp_print_break ppf width offset
   | FFlush                    -> pp_print_flush ppf ()
   | Force_newline             -> pp_force_newline ppf ()
   | Flush_newline             -> pp_print_newline ppf ()
   | Magic_size (_, _)         -> ()
@@@@
 
 let ifprintf _ppf (Format (fmt, _)) =
   make_iprintf ignore () fmt
 
 let fprintf ppf = kfprintf ignore ppf
+let printf fmt = fprintf std_formatter fmt
+let eprintf fmt = fprintf err_formatter fmt
 
-let printf (Format (fmt, _)) =
-  make_printf
-    (fun acc -> output_acc (DLS.get std_formatter_key) acc)
-    End_of_acc fmt
-
-let eprintf (Format (fmt, _)) =
-  make_printf
-    (fun acc -> output_acc (DLS.get err_formatter_key) acc)
-    End_of_acc fmt
-
 let kdprintf k (Format (fmt, _)) =
   make_printf
     (fun acc -> k (fun ppf -> output_acc ppf acc))
     End_of_acc fmt
 
@@@@
 let asprintf fmt = kasprintf id fmt
 
 (* Flushing standard formatters at end of execution. *)
 
 let flush_standard_formatters () =
-  pp_print_flush (DLS.get std_formatter_key) ();
-  pp_print_flush (DLS.get err_formatter_key) ()
+  pp_print_flush std_formatter ();
+  pp_print_flush err_formatter ()
 
 let () = at_exit flush_standard_formatters
 
-let () = Domain.before_first_spawn (fun () ->
-  flush_standard_formatters ();
-  let fs = pp_get_formatter_out_functions std_formatter () in
-  pp_set_formatter_out_functions std_formatter
-    {fs with out_string = buffered_out_string std_buf_key;
-             out_flush = buffered_out_flush Stdlib.stdout std_buf_key};
+(*
 
-  let fs = pp_get_formatter_out_functions err_formatter () in
-  pp_set_formatter_out_functions err_formatter
-    {fs with out_string = buffered_out_string err_buf_key;
-             out_flush = buffered_out_flush Stdlib.stderr err_buf_key};
-)
+  Deprecated stuff.
+
+*)
+
+(* Deprecated : subsumed by pp_set_formatter_out_functions *)
+let pp_set_all_formatter_output_functions state
+    ~out:f ~flush:g ~newline:h ~spaces:i =
+  pp_set_formatter_output_functions state f g;
+  state.pp_out_newline <- h;
+  state.pp_out_spaces <- i
+
+(* Deprecated : subsumed by pp_get_formatter_out_functions *)
+let pp_get_all_formatter_output_functions state () =
+  (state.pp_out_string, state.pp_out_flush,
+   state.pp_out_newline, state.pp_out_spaces)
+
+
+(* Deprecated : subsumed by set_formatter_out_functions *)
+let set_all_formatter_output_functions =
+  pp_set_all_formatter_output_functions std_formatter
+
+
+(* Deprecated : subsumed by get_formatter_out_functions *)
+let get_all_formatter_output_functions =
+  pp_get_all_formatter_output_functions std_formatter
+
+
+(* Deprecated : error prone function, do not use it.
+   This function is neither compositional nor incremental, since it flushes
+   the pretty-printer queue at each call.
+   To get the same functionality, define a formatter of your own writing to
+   the buffer argument, as in
+   let ppf = formatter_of_buffer b
+   then use {!fprintf ppf} as usual. *)
+let bprintf b (Format (fmt, _) : ('a, formatter, unit) format) =
+  let ppf = formatter_of_buffer b in
+  let k acc = output_acc ppf acc; pp_flush_queue ppf false in
+  make_printf k End_of_acc fmt
+
+
+(* Deprecated : alias for ksprintf. *)
+let kprintf = ksprintf
+
+
+
+(* Deprecated tag functions *)
+
+type formatter_tag_functions = {
+  mark_open_tag : tag -> string;
+  mark_close_tag : tag -> string;
+  print_open_tag : tag -> unit;
+  print_close_tag : tag -> unit;
+}
+
+
+let pp_set_formatter_tag_functions state {
+     mark_open_tag = mot;
+     mark_close_tag = mct;
+     print_open_tag = pot;
+     print_close_tag = pct;
+   } =
+  let stringify f e = function String_tag s -> f s | _ -> e in
+  state.pp_mark_open_tag <- stringify mot "";
+  state.pp_mark_close_tag <- stringify mct "";
+  state.pp_print_open_tag <- stringify pot ();
+  state.pp_print_close_tag <- stringify pct ()
+
+let pp_get_formatter_tag_functions fmt () =
+  let funs = pp_get_formatter_stag_functions fmt () in
+  let mark_open_tag s = funs.mark_open_stag (String_tag s) in
+  let mark_close_tag s = funs.mark_close_stag (String_tag s) in
+  let print_open_tag s = funs.print_open_stag (String_tag s) in
+  let print_close_tag s = funs.print_close_stag (String_tag s) in
+  {mark_open_tag; mark_close_tag; print_open_tag; print_close_tag}
+
+let set_formatter_tag_functions =
+  pp_set_formatter_tag_functions std_formatter
+and get_formatter_tag_functions =
+  pp_get_formatter_tag_functions std_formatter
--- parser-upstream/format.mli
+++ ocamlformat_support/format.mli
@@@@
 (*                                                                        *)
 (**************************************************************************)
 
 (** Pretty-printing.
 
-   If you are new to this module, see the {{!examples} examples} below.
-
    This module implements a pretty-printing facility to format values
    within {{!boxes}'pretty-printing boxes'} and {{!tags}'semantic tags'}
    combined with a set of {{!fpp}printf-like functions}.
    The pretty-printer splits lines at specified {{!breaks}break hints},
    and indents lines according to the box structure.
@@@@
    functions.
    Some formatters are predefined, notably:
    - {!std_formatter} outputs to {{!Stdlib.stdout}stdout}
    - {!err_formatter} outputs to {{!Stdlib.stderr}stderr}
 
-   Most functions in the {!Format} module come in two variants: a short version
-   that operates on the current domain's standard formatter as obtained using
-   {!get_std_formatter} and the generic version prefixed by [pp_] that takes a
-   formatter as its first argument. For the version that operates on the
-   current domain's standard formatter, the call to {!get_std_formatter} is
-   delayed until the last argument is received.
+   Most functions in the {!Format} module come in two variants:
+   a short version that operates on {!std_formatter} and the
+   generic version prefixed by [pp_] that takes a formatter
+   as its first argument.
 
    More formatters can be created with {!formatter_of_out_channel},
-   {!formatter_of_buffer}, {!formatter_of_symbolic_output_buffer} or using
-   {{!section:formatter}custom formatters}.
+   {!formatter_of_buffer}, {!formatter_of_symbolic_output_buffer}
+   or using {{!section:formatter}custom formatters}.
 
-   {b Warning}: Since {{!section:formatter}formatters} contain
-   mutable state, it is not thread-safe to use the same formatter on multiple
-   domains in parallel without synchronization.
-
-   If multiple domains write to the same output channel using the
-   predefined formatters (as obtained by {!get_std_formatter} or
-   {!get_err_formatter}), the output from the domains will be interleaved with
-   each other at points where the formatters are flushed, such as with
-   {!print_flush}. This synchronization is not performed by formatters obtained
-   from {!formatter_of_out_channel} (on the standard out channels or others).
 *)
 
 (** {1 Introduction}
 
    You may consider this module as providing an extension to the
@@@@
 (** [pp_print_string ppf s] prints [s] in the current pretty-printing box. *)
 
 val pp_print_bytes : formatter -> bytes -> unit
 val print_bytes : bytes -> unit
 (** [pp_print_bytes ppf b] prints [b] in the current pretty-printing box.
-    @since 4.13
+    @since 4.13.0
 *)
 
 val pp_print_as : formatter -> int -> string -> unit
 val print_as : int -> string -> unit
 (** [pp_print_as ppf len s] prints [s] in the current pretty-printing box.
@@@@
    for a custom formatter that handles indentation distinctly, for example,
    outputs [<br/>] tags or [&nbsp;] entities.
 
    The custom break is useful if you want to change which visible
    (non-whitespace) characters are printed in case of break or no break. For
-   example, when printing a list [ [a; b; c] ], you might want to add a
+   example, when printing a list {[ [a; b; c] ]}, you might want to add a
    trailing semicolon when it is printed vertically:
 
    {[
 [
   a;
@@@@
    {[
 printf "@[<v 0>[@;<0 2>@[<v 0>a;@,b;@,c@]%t]@]@\n"
   (pp_print_custom_break ~fits:("", 0, "") ~breaks:(";", 0, ""))
    ]}
 
-  @since 4.08
+  @since 4.08.0
 *)
 
 val pp_force_newline : formatter -> unit -> unit
 val force_newline : unit -> unit
 (** Force a new line in the current pretty-printing box.
@@@@
 (** Execute the next formatting command if the preceding line
   has just been split. Otherwise, ignore the next formatting
   command.
 *)
 
+val pp_print_string_if_newline : formatter -> string -> unit
+(** Similar to [print_if_newline] followed by [print_string] except that the
+  length of the string does not contribute to the width of the enclosing
+  box. *)
+
+val pp_print_or_newline : formatter -> int -> int -> string -> string -> unit
+(** Print a full break hint and the first string if the preceding line has
+  not just been split. Otherwise, print the second string. *)
+
+val pp_print_fits_or_breaks :
+  formatter -> ?level:int -> string -> int -> int -> string -> unit
+(** [pp_print_fits_or_breaks fmt ?level fits nspaces offset breaks] prints
+  [fits] if the enclosing boxes fits on one line ([level] being the depth of
+  boxes that are checked in the stack). Otherwise, prints a break as per
+  [print_break nspaces offset] followed by [breaks]. *)
+
 (** {1 Pretty-printing termination} *)
 
 val pp_print_flush : formatter -> unit -> unit
 val print_flush : unit -> unit
 (** End of pretty-printing: resets the pretty-printer to initial state.
@@@@
 (** Return the maximum indentation limit (in characters). *)
 
 (** {1 Geometry }
 
 Geometric functions can be used to manipulate simultaneously the
-coupled variables, margin and maximum indentation limit.
+coupled variables, margin and maxixum indentation limit.
 
 *)
 
 type geometry = { max_indent:int; margin: int}
-(** @since 4.08 *)
 
 val check_geometry: geometry -> bool
-(** Check if the formatter geometry is valid: [1 < max_indent < margin]
-    @since 4.08 *)
+(** Check if the formatter geometry is valid: [1 < max_indent < margin] *)
 
 val pp_set_geometry : formatter -> max_indent:int -> margin:int -> unit
 val set_geometry : max_indent:int -> margin:int -> unit
 val pp_safe_set_geometry : formatter -> max_indent:int -> margin:int -> unit
 val safe_set_geometry : max_indent:int -> margin:int -> unit
@@@@
    [pp_set_max_indent ppf max_indent; pp_set_margin ppf margin];
 
    Outside of this domain, [pp_set_geometry] raises an invalid argument
    exception whereas [pp_safe_set_geometry] does nothing.
 
-   @since 4.08
+   @since 4.08.0
 *)
 
 (**
    [pp_update_geometry ppf (fun geo -> { geo with ... })] lets you
    update a formatter's geometry in a way that is robust to extension
    of the [geometry] record with new fields.
 
    Raises an invalid argument exception if the returned geometry
    does not satisfy {!check_geometry}.
 
-   @since 4.11
+   @since 4.11.0
 *)
 val pp_update_geometry : formatter -> (geometry -> geometry) -> unit
 val update_geometry : (geometry -> geometry) -> unit
 
 val pp_get_geometry: formatter -> unit -> geometry
 val get_geometry: unit -> geometry
 (** Return the current geometry of the formatter
 
-    @since 4.08
+    @since 4.08.0
 *)
 
 
 
 (** {1 Maximum formatting depth} *)
@@@@
 
   Semantic tag operations may be set on or off with {!set_tags}.
   Tag-marking operations may be set on or off with {!set_mark_tags}.
   Tag-printing operations may be set on or off with {!set_print_tags}.
 
-  @since 4.08
+  @since 4.08.0
 *)
 
 type tag = string
 type stag += String_tag of tag
 (** [String_tag s] is a string tag [s]. String tags can be inserted either
     by explicitly using the constructor [String_tag] or by using the dedicated
     format syntax ["@{<s> ... @}"].
 
-    @since 4.08
+    @since 4.08.0
 *)
 
 val pp_open_stag : formatter -> stag -> unit
 val open_stag : stag -> unit
 (** [pp_open_stag ppf t] opens the semantic tag named [t].
 
   The [print_open_stag] tag-printing function of the formatter is called with
   [t] as argument; then the opening tag marker for [t], as given by
   [mark_open_stag t], is written into the output device of the formatter.
 
-  @since 4.08
+  @since 4.08.0
 *)
 
 val pp_close_stag : formatter -> unit -> unit
 val close_stag : unit -> unit
 (** [pp_close_stag ppf ()] closes the most recently opened semantic tag [t].
 
   The closing tag marker, as given by [mark_close_stag t], is written into the
   output device of the formatter; then the [print_close_stag] tag-printing
   function of the formatter is called with [t] as argument.
 
-  @since 4.08
+  @since 4.08.0
 *)
 
 val pp_set_tags : formatter -> bool -> unit
 val set_tags : bool -> unit
 (** [pp_set_tags ppf b] turns on or off the treatment of semantic tags
@@@@
 type formatter_out_functions = {
   out_string : string -> int -> int -> unit;
   out_flush : unit -> unit;
   out_newline : unit -> unit;
   out_spaces : int -> unit;
-  out_indent : int -> unit;(** @since 4.06 *)
+  out_indent : int -> unit;(** @since 4.06.0 *)
 }
 (** The set of output functions specific to a formatter:
 - the [out_string] function performs all the pretty-printer string output.
   It is called with a string [s], a start position [p], and a number of
   characters [n]; it is supposed to output characters [p] to [p + n - 1] of
@@@@
    {!Stdlib.out_channel} device, or [Buffer.add_substring] and
    {!Stdlib.ignore} for a [Buffer.t] output device),
 - field [out_newline] is equivalent to [out_string "\n" 0 1];
 - fields [out_spaces] and [out_indent] are equivalent to
   [out_string (String.make n ' ') 0 n].
-  @since 4.01
+  @since 4.01.0
 *)
 
 val pp_set_formatter_out_functions :
   formatter -> formatter_out_functions -> unit
 val set_formatter_out_functions : formatter_out_functions -> unit
@@@@
   application at hand).
 
   Reasonable defaults for functions [out_spaces] and [out_newline] are
   respectively [out_funs.out_string (String.make n ' ') 0 n] and
   [out_funs.out_string "\n" 0 1].
-  @since 4.01
+  @since 4.01.0
 *)
 
 val pp_get_formatter_out_functions :
   formatter -> unit -> formatter_out_functions
 val get_formatter_out_functions : unit -> formatter_out_functions
 (** Return the current output functions of the pretty-printer,
   including line splitting and indentation functions. Useful to record the
   current setting and restore it afterwards.
-  @since 4.01
+  @since 4.01.0
 *)
 
 (** {1:tagsmeaning Redefining semantic tag operations} *)
 
 type formatter_stag_functions = {
@@@@
   marker to a tag in order for the pretty-printing engine to write
   those markers as 0 length tokens in the output device of the formatter.
   [print] versions are the 'tag-printing' functions that can perform
   regular printing when a tag is closed or opened.
 
-  @since 4.08
+  @since 4.08.0
 *)
 
 val pp_set_formatter_stag_functions :
   formatter -> formatter_stag_functions -> unit
 val set_formatter_stag_functions : formatter_stag_functions -> unit
@@@@
 
   The [print_] field of the record contains the tag-printing functions that
   are called at tag opening and tag closing time, to output regular material
   in the pretty-printer queue.
 
-  @since 4.08
+  @since 4.08.0
 *)
 
 val pp_get_formatter_stag_functions :
   formatter -> unit -> formatter_stag_functions
 val get_formatter_stag_functions : unit -> formatter_stag_functions
 (** Return the current semantic tag operation functions of the standard
     pretty-printer.
 
-    @since 4.08 *)
+    @since 4.08.0 *)
 
 (** {1:formatter Defining formatters}
 
   Defining new formatters permits unrelated output of material in
   parallel on several output devices.
@@@@
   formatter using those functions for output.
 *)
 
 val formatter_of_out_channel : out_channel -> formatter
 (** [formatter_of_out_channel oc] returns a new formatter writing
-    to the corresponding output channel [oc].
+  to the corresponding output channel [oc].
 *)
 
-val synchronized_formatter_of_out_channel :
-  out_channel -> formatter Domain.DLS.key
-[@@alert unstable][@@alert "-unstable"]
-(** [synchronized_formatter_of_out_channel oc] returns the key to the
-    domain-local state that holds the domain-local formatter for writing to the
-    corresponding output channel [oc].
-
-    When the formatter is used with multiple domains, the output from the
-    domains will be interleaved with each other at points where the formatter
-    is flushed, such as with {!print_flush}.
-*)
-
-
 val std_formatter : formatter
-(** The initial domain's standard formatter to write to standard output.
+(** The standard formatter to write to standard output.
 
   It is defined as {!formatter_of_out_channel} {!Stdlib.stdout}.
 *)
 
-val get_std_formatter : unit -> formatter
-(** [get_std_formatter ()] returns the current domain's standard formatter used
-    to write to standard output.
-    @since 5.0
-*)
-
 val err_formatter : formatter
-(** The initial domain's formatter to write to standard error.
+(** A formatter to write to standard error.
 
   It is defined as {!formatter_of_out_channel} {!Stdlib.stderr}.
 *)
 
-val get_err_formatter : unit -> formatter
-(** [get_err_formatter ()] returns the current domain's formatter used to write
-   to standard error.
-   @since 5.0
-*)
-
 val formatter_of_buffer : Buffer.t -> formatter
 (** [formatter_of_buffer b] returns a new formatter writing to
   buffer [b]. At the end of pretty-printing, the formatter must be flushed
   using {!pp_print_flush} or {!pp_print_newline}, to print all the
   pending material into the buffer.
 *)
 
 val stdbuf : Buffer.t
-(** The initial domain's string buffer in which [str_formatter] writes. *)
+(** The string buffer in which [str_formatter] writes. *)
 
-val get_stdbuf : unit -> Buffer.t
-(** [get_stdbuf ()] returns the current domain's string buffer in which the
-    current domain's string formatter writes.
-    @since 5.0 *)
-
 val str_formatter : formatter
-(** The initial domain's formatter to output to the {!stdbuf} string buffer.
+(** A formatter to output to the {!stdbuf} string buffer.
 
   [str_formatter] is defined as {!formatter_of_buffer} {!stdbuf}.
 *)
 
-val get_str_formatter : unit -> formatter
-(** The current domain's formatter to output to the current domains string
-    buffer.
-    @since 5.0
-*)
-
 val flush_str_formatter : unit -> string
-(** Returns the material printed with [str_formatter] of the current domain,
-    flushes the formatter and resets the corresponding buffer.
+(** Returns the material printed with [str_formatter], flushes
+  the formatter and resets the corresponding buffer.
 *)
 
 val make_formatter :
   (string -> int -> int -> unit) -> (unit -> unit) -> formatter
 (** [make_formatter out flush] returns a new formatter that outputs with
   function [out], and flushes with function [flush].
 
-  For instance,
-  {[
+  For instance, {[
     make_formatter
       (Stdlib.output oc)
-      (fun () -> Stdlib.flush oc)
-  ]}
+      (fun () -> Stdlib.flush oc) ]}
   returns a formatter to the {!Stdlib.out_channel} [oc].
 *)
 
-val make_synchronized_formatter :
-  (string -> int -> int -> unit) -> (unit -> unit) -> formatter Domain.DLS.key
-[@@alert unstable][@@alert "-unstable"]
-(** [make_synchronized_formatter out flush] returns the key to the domain-local
-    state that holds the domain-local formatter that outputs with function
-    [out], and flushes with function [flush].
-
-    When the formatter is used with multiple domains, the output from the
-    domains will be interleaved with each other at points where the formatter
-    is flushed, such as with {!print_flush}.
-    @since 5.0
-*)
-
 val formatter_of_out_functions :
   formatter_out_functions -> formatter
 (** [formatter_of_out_functions out_funs] returns a new formatter that writes
   with the set of output functions [out_funs].
 
   See definition of type {!formatter_out_functions} for the meaning of argument
   [out_funs].
 
-  @since 4.06
+  @since 4.06.0
 *)
 
-
-
 (** {2:symbolic Symbolic pretty-printing} *)
 
 (**
   Symbolic pretty-printing is pretty-printing using a symbolic formatter,
   i.e. a formatter that outputs symbolic pretty-printing items.
@@@@
   | Output_spaces of int
   (** [Output_spaces n]: symbolic command to output [n] spaces *)
   | Output_indent of int
   (** [Output_indent i]: symbolic indentation of size [i] *)
 (** Items produced by symbolic pretty-printers
-    @since 4.06
+    @since 4.06.0
 *)
 
 type symbolic_output_buffer
 (**
   The output buffer of a symbolic pretty-printer.
 
-  @since 4.06
+  @since 4.06.0
 *)
 
 val make_symbolic_output_buffer : unit -> symbolic_output_buffer
 (** [make_symbolic_output_buffer ()] returns a fresh buffer for
   symbolic output.
 
-  @since 4.06
+  @since 4.06.0
 *)
 
 val clear_symbolic_output_buffer : symbolic_output_buffer -> unit
 (** [clear_symbolic_output_buffer sob] resets buffer [sob].
 
-  @since 4.06
+  @since 4.06.0
 *)
 
 val get_symbolic_output_buffer :
   symbolic_output_buffer -> symbolic_output_item list
 (** [get_symbolic_output_buffer sob] returns the contents of buffer [sob].
 
-  @since 4.06
+  @since 4.06.0
 *)
 
 val flush_symbolic_output_buffer :
   symbolic_output_buffer -> symbolic_output_item list
 (** [flush_symbolic_output_buffer sob] returns the contents of buffer
   [sob] and resets buffer [sob].
   [flush_symbolic_output_buffer sob] is equivalent to
   [let items = get_symbolic_output_buffer sob in
    clear_symbolic_output_buffer sob; items]
 
-  @since 4.06
+  @since 4.06.0
 *)
 
 val add_symbolic_output_item :
   symbolic_output_buffer -> symbolic_output_item -> unit
 (** [add_symbolic_output_item sob itm] adds item [itm] to buffer [sob].
 
-  @since 4.06
+  @since 4.06.0
 *)
 
 val formatter_of_symbolic_output_buffer : symbolic_output_buffer -> formatter
 (** [formatter_of_symbolic_output_buffer sob] returns a symbolic formatter
   that outputs to [symbolic_output_buffer] [sob].
 
-  @since 4.06
+  @since 4.06.0
 *)
 
 (** {1 Convenience formatting functions.} *)
 
-val pp_print_iter :
-  ?pp_sep:(formatter -> unit -> unit) ->
-  (('a -> unit) -> 'b -> unit) ->
-  (formatter -> 'a -> unit) -> formatter -> 'b -> unit
-(** [pp_print_iter ~pp_sep iter pp_v ppf v] formats on [ppf] the iterations of
-  [iter] over a collection [v] of values using [pp_v]. Iterations are
-  separated by [pp_sep] (defaults to {!pp_print_cut}).
-
-  @since 5.1
-*)
-
 val pp_print_list:
   ?pp_sep:(formatter -> unit -> unit) ->
   (formatter -> 'a -> unit) -> (formatter -> 'a list -> unit)
 (** [pp_print_list ?pp_sep pp_v ppf l] prints items of list [l],
   using [pp_v] to print each item, and calling [pp_sep]
-  between items ([pp_sep] defaults to {!pp_print_cut}).
+  between items ([pp_sep] defaults to {!pp_print_cut}.
   Does nothing on empty lists.
 
-  @since 4.02
+  @since 4.02.0
 *)
 
-val pp_print_array:
-  ?pp_sep:(formatter -> unit -> unit) ->
-  (formatter -> 'a -> unit) -> (formatter -> 'a array -> unit)
-(** [pp_print_array ?pp_sep pp_v ppf a] prints items of array [a],
-  using [pp_v] to print each item, and calling [pp_sep]
-  between items ([pp_sep] defaults to {!pp_print_cut}).
-  Does nothing on empty arrays.
-
-  If [a] is mutated after [pp_print_array] is called, the printed values
-  may not be what is expected because [Format] can delay the printing.
-  This can be avoided by flushing [ppf].
-
-  @since 5.1
-*)
-
 val pp_print_seq:
   ?pp_sep:(formatter -> unit -> unit) ->
   (formatter -> 'a -> unit) -> (formatter -> 'a Seq.t -> unit)
 (** [pp_print_seq ?pp_sep pp_v ppf s] prints items of sequence [s],
   using [pp_v] to print each item, and calling [pp_sep]
@@@@
 
 val pp_print_text : formatter -> string -> unit
 (** [pp_print_text ppf s] prints [s] with spaces and newlines respectively
   printed using {!pp_print_space} and {!pp_force_newline}.
 
-  @since 4.02
+  @since 4.02.0
 *)
 
 val pp_print_option :
   ?none:(formatter -> unit -> unit) ->
   (formatter -> 'a -> unit) -> (formatter -> 'a option -> unit)
@@@@
   - [@;]: output a 'full' break hint as with [print_break]. The
     [nspaces] and [offset] parameters of the break hint may be
     optionally specified with the following syntax:
     the [<] character, followed by an integer [nspaces] value,
     then an integer [offset], and a closing [>] character.
-    If no parameters are provided, the full break defaults to a
+    If no parameters are provided, the good break defaults to a
     'space' break hint.
   - [@.]: flush the pretty-printer and split the line, as with
     [print_newline ()].
   - [@<n>]: print the following item as if it were of length [n].
     Hence, [printf "@<0>%s" arg] prints [arg] as a zero length string.
@@@@
   It prints [x = 1] within a pretty-printing 'horizontal-or-vertical' box.
 
 *)
 
 val printf : ('a, formatter, unit) format -> 'a
-(** Same as [fprintf] above, but output on [get_std_formatter ()].
+(** Same as [fprintf] above, but output on [std_formatter]. *)
 
-    It is defined similarly to [fun fmt -> fprintf (get_std_formatter ()) fmt]
-    but delays calling [get_std_formatter] until after the final argument
-    required by the [format] is received. When used with multiple domains, the
-    output from the domains will be interleaved with each other at points where
-    the formatter is flushed, such as with {!print_flush}.
-*)
-
 val eprintf : ('a, formatter, unit) format -> 'a
-(** Same as [fprintf] above, but output on [get_err_formatter ()].
+(** Same as [fprintf] above, but output on [err_formatter]. *)
 
-    It is defined similarly to [fun fmt -> fprintf (get_err_formatter ()) fmt]
-    but delays calling [get_err_formatter] until after the final argument
-    required by the [format] is received. When used with multiple domains, the
-    output from the domains will be interleaved with each other at points where
-    the formatter is flushed, such as with {!print_flush}.
-*)
-
 val sprintf : ('a, unit, string) format -> 'a
 (** Same as [printf] above, but instead of printing on a formatter,
   returns a string containing the result of formatting the arguments.
   Note that the pretty-printer queue is flushed at the end of {e each
   call} to [sprintf].
@@@@
 (** Same as [printf] above, but instead of printing on a formatter,
   returns a string containing the result of formatting the arguments.
   The type of [asprintf] is general enough to interact nicely with [%a]
   conversions.
 
-  @since 4.01
+  @since 4.01.0
 *)
 
 val dprintf :
   ('a, formatter, unit, formatter -> unit) format4 -> 'a
 (** Same as {!fprintf}, except the formatter is the last argument.
@@@@
   let t = Format.dprintf "%i@ %i@ %i" 1 2 3 in
   ...
   Format.printf "@[<v>%t@]" t
 ]}
 
-  @since 4.08
+  @since 4.08.0
 *)
 
 
 val ifprintf : formatter -> ('a, formatter, unit) format -> 'a
 (** Same as [fprintf] above, but does not print anything.
   Useful to ignore some material when conditionally printing.
 
-  @since 3.10
+  @since 3.10.0
 *)
 
 (** Formatted Pretty-Printing with continuations. *)
 
 val kfprintf :
@@@@
   ((formatter -> unit) -> 'a) ->
   ('b, formatter, unit, 'a) format4 -> 'b
 (** Same as {!dprintf} above, but instead of returning immediately,
   passes the suspended printer to its first argument at the end of printing.
 
-  @since 4.08
+  @since 4.08.0
 *)
 
 val ikfprintf :
   (formatter -> 'a) -> formatter ->
   ('b, formatter, unit, 'a) format4 -> 'b
 (** Same as [kfprintf] above, but does not print anything.
   Useful to ignore some material when conditionally printing.
 
-  @since 3.12
+  @since 3.12.0
 *)
 
 val ksprintf : (string -> 'a) -> ('b, unit, string, 'a) format4 -> 'b
 (** Same as [sprintf] above, but instead of returning the string,
   passes it to the first argument. *)
@@@@
   passes it to the first argument.
 
   @since 4.03
 *)
 
-(** {1:examples Examples}
+(** {1 Deprecated} *)
 
-  A few warmup examples to get an idea of how Format is used.
+val bprintf : Buffer.t -> ('a, formatter, unit) format -> 'a
+  [@@ocaml.deprecated]
+(** @deprecated This function is error prone. Do not use it.
+  This function is neither compositional nor incremental, since it flushes
+  the pretty-printer queue at each call.
 
-  We have a list [l] of pairs [(int * bool)], which the toplevel prints for us:
+  If you need to print to some buffer [b], you must first define a
+  formatter writing to [b], using [let to_b = formatter_of_buffer b]; then
+  use regular calls to [Format.fprintf] with formatter [to_b].
+*)
 
-  {[# let l = List.init 20 (fun n -> n, n mod 2 = 0)
-  val l : (int * bool) list =
-  [(0, true); (1, false); (2, true); (3, false); (4, true); (5, false);
-   (6, true); (7, false); (8, true); (9, false); (10, true); (11, false);
-   (12, true); (13, false); (14, true); (15, false); (16, true); (17, false);
-   (18, true); (19, false)]
- ]}
+val kprintf : (string -> 'a) -> ('b, unit, string, 'a) format4 -> 'b
+  [@@ocaml.deprecated "Use Format.ksprintf instead."]
+(** @deprecated An alias for [ksprintf]. *)
 
-  If we want to print it ourself without the toplevel magic, we can try this:
+val set_all_formatter_output_functions :
+  out:(string -> int -> int -> unit) ->
+  flush:(unit -> unit) ->
+  newline:(unit -> unit) ->
+  spaces:(int -> unit) ->
+  unit
+[@@ocaml.deprecated "Use Format.set_formatter_out_functions instead."]
+(** @deprecated Subsumed by [set_formatter_out_functions]. *)
 
-  {[
-  # let pp_pair out (x,y) = Format.fprintf out "(%d, %b)" x y
-  val pp_pair : Format.formatter -> int * bool -> unit = <fun>
-  # Format.printf "l: [@[<hov>%a@]]@."
-    Format.(pp_print_list ~pp_sep:(fun out () -> fprintf out ";@ ") pp_pair) l
-    l: [(0, true); (1, false); (2, true); (3, false); (4, true); (5, false);
-        (6, true); (7, false); (8, true); (9, false); (10, true); (11, false);
-        (12, true); (13, false); (14, true); (15, false); (16, true);
-        (17, false); (18, true); (19, false)]
+val get_all_formatter_output_functions :
+  unit ->
+  (string -> int -> int -> unit) *
+  (unit -> unit) *
+  (unit -> unit) *
+  (int -> unit)
+[@@ocaml.deprecated "Use Format.get_formatter_out_functions instead."]
+(** @deprecated Subsumed by [get_formatter_out_functions]. *)
 
-  ]}
+val pp_set_all_formatter_output_functions :
+  formatter -> out:(string -> int -> int -> unit) -> flush:(unit -> unit) ->
+  newline:(unit -> unit) -> spaces:(int -> unit) -> unit
+[@@ocaml.deprecated "Use Format.pp_set_formatter_out_functions instead."]
+(** @deprecated Subsumed by [pp_set_formatter_out_functions]. *)
 
+val pp_get_all_formatter_output_functions :
+  formatter -> unit ->
+  (string -> int -> int -> unit) * (unit -> unit) * (unit -> unit) *
+  (int -> unit)
+[@@ocaml.deprecated "Use Format.pp_get_formatter_out_functions instead."]
+(** @deprecated Subsumed by [pp_get_formatter_out_functions]. *)
 
-  What this does, briefly, is:
+(** {2 String tags} *)
 
-    - [pp_pair] prints a pair [bool*int] surrounded in "(" ")". It takes
-      a formatter (into which formatting happens), and the pair itself.
-      When printing is done it returns [()].
+val pp_open_tag : formatter -> tag -> unit
+[@@ocaml.deprecated "Use Format.pp_open_stag."]
+(** @deprecated Subsumed by {!pp_open_stag}. *)
 
-    - [Format.printf "l = [@[<hov>%a@]]@." ... l] is like [printf], but
-      with additional formatting instructions (denoted with "@"). The pair
-      "@[<hov>" and "@]" is a "horizontal-or-vertical box".
+val open_tag : tag -> unit
+[@@ocaml.deprecated "Use Format.open_stag."]
+(** @deprecated Subsumed by {!open_stag}. *)
 
-    - "@." ends formatting with a newline. It is similar to "\n" but is also
-      aware of the [Format.formatter]'s state. Do not use "\n" with [Format].
+val pp_close_tag : formatter -> unit -> unit
+[@@ocaml.deprecated "Use Format.pp_close_stag."]
+(** @deprecated Subsumed by {!pp_close_stag}. *)
 
-    - "%a" is a formatting instruction, like "%d" or "%s" for [printf].
-      However, where "%d" prints an integer and "%s" prints a string,
-      "%a" takes a printer (of type [Format.formatter -> 'a -> unit])
-      and a value (of type ['a]) and applies the printer to the value.
-      This is key to compositionality of printers.
+val close_tag : unit -> unit
+[@@ocaml.deprecated "Use Format.close_stag."]
+(** @deprecated Subsumed by {!close_stag}. *)
 
-    - We build a list printer using
-      [Format.pp_print_list ~pp_sep:(...) pp_pair].
-      [pp_print_list] takes an element printer and returns a list printer.
-      The [?pp_sep] optional argument, if provided, is called in between
-      each element to print a separator.
+type formatter_tag_functions = {
+  mark_open_tag : tag -> string;
+  mark_close_tag : tag -> string;
+  print_open_tag : tag -> unit;
+  print_close_tag : tag -> unit;
+}
+[@@ocaml.deprecated "Use formatter_stag_functions."]
+(** @deprecated Subsumed by {!formatter_stag_functions}. *)
 
-    - Here, for a separator, we use [(fun out () -> Format.fprintf out ";@ ")].
-      It prints ";", and then "@ " which is a breaking space
-      (either it prints " ", or it prints a newline if the box is about to
-      overflow).
-      This "@ " is responsible for the list printing splitting into several
-      lines.
+val pp_set_formatter_tag_functions :
+  formatter -> formatter_tag_functions -> unit
+[@@ocaml.deprecated
+  "This function will erase non-string tag formatting functions. \
+   Use Format.pp_set_formatter_stag_functions."]
+[@@warning "-3"]
+(** This function will erase non-string tag formatting functions.
+    @deprecated Subsumed by {!pp_set_formatter_stag_functions}. *)
 
-  If we omit "@ ", we get an ugly single-line print:
+val set_formatter_tag_functions : formatter_tag_functions -> unit
+[@@ocaml.deprecated "Use Format.set_formatter_stag_functions."]
+[@@warning "-3"]
+(** @deprecated Subsumed by {!set_formatter_stag_functions}. *)
 
-  {[# Format.printf "l: [@[<hov>%a@]]@."
-      Format.(pp_print_list ~pp_sep:(fun out () -> fprintf out "; ") pp_pair) l
-  l: [(0, true); (1, false); (2, true); (* ... *); (18, true); (19, false)]
-- : unit = ()
-    ]}
+val pp_get_formatter_tag_functions :
+  formatter -> unit -> formatter_tag_functions
+[@@ocaml.deprecated "Use Format.pp_get_formatter_stag_functions."]
+[@@warning "-3"]
+(** @deprecated Subsumed by {!pp_get_formatter_stag_functions}. *)
 
-  Generally, it is good practice to define custom printers for important types
-  in your program. If, for example, you were to define basic geometry
-  types like so:
-
-  {[
-  type point = {
-    x: float;
-    y: float;
-  }
-
-  type rectangle = {
-    ll: point; (* lower left *)
-    ur: point; (* upper right *)
-  }
-  ]}
-
-  For debugging purpose, or to display information in logs, or on the console,
-  it would be convenient to define printers for these types.
-  Here is an example of to do it.
-  Note that "%.3f" is a [float] printer up to 3 digits of precision
-  after the dot; "%f" would print as many digits as required, which is
-  somewhat verbose; "%h" is an hexadecimal float printer.
-
-  {[
-  let pp_point out (p:point) =
-    Format.fprintf out "{ @[x=%.3f;@ y=%.3f@] }" p.x p.y
-
-  let pp_rectangle out (r:rectangle) =
-    Format.fprintf out "{ @[ll=%a;@ ur=%a@] }"
-      pp_point r.ll pp_point r.ur
-  ]}
-
-  In the [.mli] file, we could have:
-
-  {[
-    val pp_point : Format.formatter -> point -> unit
-
-    val pp_rectangle : Format.formatter -> rectangle -> unit
-  ]}
-
-  These printers can now be used with "%a" inside other printers.
-
-  {[ # Format.printf "some rectangle: %a@."
-        (Format.pp_print_option pp_rectangle)
-        (Some {ll={x=1.; y=2.}; ur={x=42.; y=500.12345}})
-  some rectangle: { l={ x=1.000; y=2.000 }; ur={ x=42.000; y=500.123 } }
-
-  # Format.printf "no rectangle: %a@."
-        (Format.pp_option pp_rectangle)
-        None
-  no rectangle:
-  ]}
-
-  See how we combine [pp_print_option] (option printer) and our newly defined
-  rectangle printer, like we did with [pp_print_list] earlier.
-
-  For a more extensive tutorial, see
-  {{: https://caml.inria.fr/resources/doc/guides/format.en.html}
-    "Using the Format module"}.
-
-  A final note: the [Format] module is a starting point.
-  The OCaml ecosystem has libraries that makes formatting easier
-  and more expressive, with more combinators, more concise names, etc.
-  An example of such a library is {{: https://erratique.ch/software/fmt} Fmt}.
-
-  Automatic deriving of pretty-printers from type definitions is also possible,
-  using {{: ppx_deriving.show} https://github.com/ocaml-ppx/ppx_deriving}
-  or similar ppx derivers.
-*)
+val get_formatter_tag_functions : unit -> formatter_tag_functions
+[@@ocaml.deprecated "Use Format.get_formatter_stag_functions."]
+[@@warning "-3"]
+(** @deprecated Subsumed by {!get_formatter_stag_functions}. *)
