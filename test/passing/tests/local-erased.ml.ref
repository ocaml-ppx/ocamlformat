let f a b c = 1

let f a ~foo:b ?foo:(c = 1) ~d = ()

let f ~x ~(y : string) ?(z : string) = ()

let xs = [(fun a (type b) ~c -> 1)]

let xs = [(fun a (type b) ~c -> 1)]

let f () =
  let a = [1] in
  let r = 1 in
  let f : 'a. 'a -> 'a = fun x -> x in
  let g a b c : int = 1 in
  let () = g (fun () -> ()) in
  "asdfasdfasdfasdfasdfasdfasdf"

let f () =
  let a = [1] in
  let r = 1 in
  let f : 'a. 'a -> 'a = fun x -> x in
  let g a b c : int = 1 in
  let () = g (fun () -> ()) in
  "asdfasdfasdfasdfasdfasdfasdf"

type 'a r = {mutable a: 'a; b: 'a; c: 'a [@globalized]}

type 'a r =
  | Foo of ('a[@globalized])
  | Bar of 'a * ('a[@globalized])
  | Baz of (int[@globalized]) * string * ('a[@globalized])

type ('a, 'b) cfn = a:'a -> ?b:b -> 'a -> int -> 'b

let _ = ()

let _ = ()

let () = x

let () = x

let {b} = ()

let {b} = ()

let () = r

let () = r

let x : string = "hi"

let (x : string) = "hi"

let (x : string) = "hi"

let x = ("hi" : string)

let x = ("hi" : string)

let x : 'a. 'a -> 'a = "hi"

let x : 'a. 'a -> 'a = "hi"

let f : 'a. 'a -> 'a = "hi"

let foo () =
  if true then () ;
  ()

let[@ocaml.local] upstream_local_attr_long x = x

module type S = functor (_ : S) (_ : S) -> S

let[@ocaml.local never] upstream_local_attr_never_long x = x

let[@ocaml.local always] upstream_local_attr_always_long x = x

let[@ocaml.local maybe] upstream_local_attr_maybe_long x = x

let[@local] upstream_local_attr_short x = x

let[@local never] upstream_local_attr_never_short x = x

let[@local always] upstream_local_attr_always_short x = x

let[@local maybe] upstream_local_attr_maybe_short x = x

let f x =
  (* a *)
  (* b *)
  (* c *)
  (* d *)
  let y = 1 in
  x + y

let f x =
  (* a *)
  (* b *)
  (* c *)
  (* d *)
  let y = 1 in
  x + y

let x =
  (* a *)
  (* b *)
  (* c *)
  (* d *)
  let y = 1 in
  y

let x =
  (* a *)
  (* b *)
  (* c *)
  (* d *)
  let y = 1 in
  y

module type S = functor (_ : S) (_ : S) -> S
(* this is here to make sure we pass the AST equality checks even when the
   extended AST is different *)

let f
    (* a *)
    (* b *)
    (* c *)
    (* d *) a
    ~foo:
      (* e *)
      (* f *)
      (* g *)
      (* h *) b ?foo:(c = 1) ~d =
  ()

type 'a r =
  { mutable a: 'a
  ; b: 'a
  ; (* a *)
    (* b *)
    (* c *)
    (* d *) c: 'a [@globalized] }

type 'a r =
  | Foo of
      (* a *)
      (* b *)
      (* c *)
      (* d *)
      ('a[@globalized])
  | Bar of
      'a
      * (* e *)
        (* f *)
        (* g *)
        (* h *)
      ('a[@globalized])
  | Baz of
      (int[@globalized])
      * string
      * (* i *)
        (* j *)
        (* k *)
        (* l *)
      ('a[@globalized])

let () =
  let foo (_ : int) = 10 in
  let bar (Some x : _) = Some 10 in
  let baz (Some x) = Some 10 in
  ()

type t

let _ = x + y

let _ = x |> f

let _ = x + y

let _ = x |> f

let _ = x + y

let _ = x |> f

let _ = x + y

let _ = x |> f

let _ =
  (* 1 *)
  M.x (* 2 *) l (* 3 *)
    ~f:(* 4 *)
      (fun
        (* 5 *)
        (* 6 *) x (* 7 *)
      ->
      Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxx
        (* 7 *)
        ( module struct
          type nonrec t = M.t
        end ) )

let _ =
  List.iter l ~f:(fun xxxxx ->
      Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
        ( module struct
          type nonrec t = M.t
        end ) )

let _ =
  (* 1 *)
  M.x
    (* 2 *)
    l
    (* 3 *)
    (* 4 *) ~f:(function
      (* 5 *)
      (* 6 *) x (* 7 *) ->
      Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxx
        (* 8 *)
        ( module struct
          type nonrec t = M.t
        end ) )

let _ =
  List.iter l ~f:(function xxxxx ->
      Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
        ( module struct
          type nonrec t = M.t
        end ) )

let _ =
  (* 1 *)
  M.x
    (* 2 *)
    l
    (* 3 *)
    (* 4 *) ~f:(function
    (* 5 *)
    (* 6 *)
    | _ ->
        Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxx
          (* 8 *)
          ( module struct
            type nonrec t = M.t
          end )
    | _ ->
        Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxx
          (* 9 *)
          ( module struct
            type nonrec t = M.t
          end ) )

let _ =
  List.iter l ~f:(function
    | _ ->
        Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxx
          ( module struct
            type nonrec t = M.t
          end )
    | _ ->
        Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxx
          ( module struct
            type nonrec t = M.t
          end ) )

let _ =
  List.iter l (* 1 *)
    ~f:(fun
        (* 2 *)
        (* 3 *)
        (* 4 *) xxxxx
      ->
      (* 5 *)
      Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
        ( module struct
          type nonrec t = M.t
        end ) )
    ~g:x

let _ =
  List.iter l
    ~f:(fun xxxxx ->
      Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
        ( module struct
          type nonrec t = M.t
        end ) )
    ~g:x

let _ =
  List.iter l (* 1 *)
    ~f:(function
      (* 2 *)
      (* 3 *)
      (* 4 *)
      | xxxxx ->
          (* 5 *)
          Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
            ( module struct
              type nonrec t = M.t
            end ) )
    ~g:x

let _ =
  List.iter l
    ~f:(function
      | xxxxx ->
          Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
            ( module struct
              type nonrec t = M.t
            end ) )
    ~g:x

let _ =
  List.iter l (* 1 *)
    ~f:(function
      (* 2 *)
      (* 3 *)
      (* 4 *)
      | _ (* 5 *) -> Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx x
      | _ (* 6 *) -> Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx x )
    ~g:x

let _ =
  List.iter l
    ~f:(function
      | _ -> Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx x
      | _ -> Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx x )
    ~g:x

(* [exclave_] *)
let _ =
  List.iter l
    ~f:(function
      (* x *)
      | xxxxx (* y *) ->
          (* z *)
          (* w *)
          Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
            ( module struct
              type nonrec t = M.t
            end ) )
    ~g:x

let _ =
  List.iter l ~f:(fun (* x *) xxxxx (* y *) ->
      (* z *)
      (* w *)
      Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
        ( module struct
          type nonrec t = M.t
        end ) )

let _ =
  List.iter l
    ~f:(function
      | xxxxx ->
          Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
            ( module struct
              type nonrec t = M.t
            end ) )
    ~g:x

let _ =
  List.iter l ~f:(fun xxxxx ->
      Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
        ( module struct
          type nonrec t = M.t
        end ) )

(* Two funs breaks comments *)
let _ = M.f ~x:(fun _ -> x) ~y:(* c *) (fun _ -> y)

(* No [local_] (for reference) *)
let _ =
  List.iter l ~f:(fun xxxxx ->
      Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
        ( module struct
          type nonrec t = M.t
        end ) )

let _ =
  List.iter l
    ~f:(fun xxxxx ->
      Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
        ( module struct
          type nonrec t = M.t
        end ) )
    ~g:x

let _ =
  List.iter l
    ~f:(function
      | xxxxx ->
          Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
            ( module struct
              type nonrec t = M.t
            end ) )
    ~g:x

(* Two arguments *)
let xxxxxxxxxxxxxxxxx xxxxxxx ~xxx =
  xxxxxxx
    (fun () ->
      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ;
      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx )
    (fun () ->
      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ;
      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx )

(* Comment shouldn't split [local_ fun] *)
let x =
  xxxxxxx
    ~xxxxxxxxxxxxxxxxxxxxxxxxxxx:(fun _ -> x)
    ~xxxxxxxxxxxxxxxxxxxxxxxxxxx:(* xxxxxxxxxxxxxxxxxxxxxxxxxx *) (fun _ _ ->
      xxxxxxxxxxxxxxxxxxxxxx )
