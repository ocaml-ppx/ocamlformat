(* These tests from the campiler test suite *)

let f = ref (stack_ fun x -> x)

let f = ref (stack_ (2, 3))

let f = ignore_local (stack_ (2, 3))

let f = ref (stack_ Foo)

let f = ref (stack_ Bar 42)

let f = ignore_local (stack_ Bar 42)

let f = ref (stack_ `Foo)

let f = ref (stack_ (`Bar 42))

let f = ignore_local (stack_ (`Bar 42))

let f = ref (stack_ {x= "hello"})

let f = ref (stack_ {x= "hello"})

let f = ignore_local (stack_ {x= "hello"})

let f (r : r) = ref (stack_ r.x)

let f (r : r) = ref (stack_ r.x)

let f (r : r) = ignore_local (stack_ r.x) [@nontail]

let f = ref (stack_ [|42; 56|])

let f = ignore_local (stack_ [|42; 56|])

let f () = stack_ (3, 5)

let f () = exclave_ stack_ (3, 5)

let f () =
  let g = stack_ fun x -> x in
  g 42

let f () = (stack_ fun x -> x) 42

let f () = List.length (stack_ [1; 2; 3])

let f () = stack_ [i for i = 0 to 9]

let f () = stack_ [|i for i = 0 to 9|]

let f () = stack_ new cla

class foo cla =
  object
    method bar = stack_ {<>}
  end

let f () = stack_ object end

let f () = stack_ (lazy "hello")

module M = struct end

module type S = sig end

let f () = stack_ (module M : S)

let f () =
  let r = ref "hello" in
  let _ = stack_ (r.contents, r.contents) in
  r.contents

let f () =
  let r = "hello" in
  let _ = stack_ (r, r) in
  r

let mk () =
  let r = stack_ {x= [1; 2; 3]; y= [4; 5; 6]} in
  r.y

let mk () =
  let r = stack_ {x= [1; 2; 3]; y= [4; 5; 6]} in
  r.x

(* More tests *)

let f = ref (stack_ function x -> x)

let f = ref (stack_ function x -> x | y -> y)

let f =
  (* 1 *)
  ref
      ((* 2 *)
       (* 3 *)
       (* 4 *) stack_ function
      (* 5 *)
      (* 6 *) x -> x )

let x = stack_ (stack_ (2, stack_ "hello"), ~x:(stack_ Foo x))

let x =
  (* 1 *)
  stack_
    (* 2 *)
    ( (* 3 *)
      stack_ (* 4 *) ((* 5 *) 1 (* 6 *), stack_ (* 7 *) "hello" (* 8 *))
      (* 9 *)
    , (* 10 *)
    ~x:( stack_
         (* 11 *)
         (* 12 *)
         Foo x ) )

(* Constructor precedence *)

let x = Foo (stack_ ((), ()))

let x = stack_ (() :: [])

(* Tuples *)

let x = stack_ (1, 2)

let x = stack_ #(1, 2)

let x = stack_ (~x:1, ~y:2)

(* Expressions rejected by the typechecker *)

let x = stack_ (x + y)

let x = stack_ (-x)

let x = stack_ (-42)

let x = stack_ (+x)

let x = stack_ 42

let x = stack_ (- (-x))

let x = stack_ 42

let x = stack_ (stack_ Foo x)

let x =
  stack_
    (let y = 1 in
     Some y )

let x = stack_ c#x

let x = stack_ (r.x <- x)

let x = stack_ (if x then y else z)

let _ = (stack_ X foo) [@bar]

let _ = stack_ X (foo [@bar])

let _ = stack_ (X foo [@bar])

let _ = stack_ fun x -> x [@bar]

let _ = stack_ fun x -> x [@bar]

let _ = stack_ (fun [@bar] x -> x)

let _ = (stack_ fun x -> x) [@bar]

(* Test labelled argument and long func *)

let _ =
  (* 1 *)
  M.x (* 2 *) l (* 3 *)
    ~f:((* 4 *)
        (* 5 *)
        (* 6 *)
      stack_ fun
        x (* 7 *) ->
      Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxx
        (* 8 *)
        ( module struct
          type nonrec t = M.t
        end ) )

let _ =
  List.iter l ~f:(stack_ fun xxxxx ->
      Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
        ( module struct
          type nonrec t = M.t
        end ) )

let _ =
  (* 1 *)
  x (* 2 *) l (* 3 *)
      ~f:((* 4 *)
          (* 5 *)
          (* 6 *) stack_ function x (* 7 *) ->
      Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxx
        (* 8 *)
        ( module struct
          type nonrec t = M.t
        end ) )

let _ =
  List.iter l ~f:(stack_ function xxxxx ->
      Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
        ( module struct
          type nonrec t = M.t
        end ) )

let _ =
  (* 1 *)
  M.x (* 2 *) l (* 3 *)
    ~f:((* 4 *)
        (* 5 *)
        (* 6 *) stack_ function
    | _ ->
        Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxx
          (* 8 *)
          ( module struct
            type nonrec t = M.t
          end )
    | _ ->
        Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxx
          (* 9 *)
          ( module struct
            type nonrec t = M.t
          end ) )

let _ =
  List.iter l ~f:(stack_ function
    | _ ->
        Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxx
          ( module struct
            type nonrec t = M.t
          end )
    | _ ->
        Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxx
          ( module struct
            type nonrec t = M.t
          end ) )

let _ =
  List.iter l (* 1 *)
    ~f:((* 2 *)
        (* 3 *)
        (* 4 *)
      stack_ fun
        (* 5 *) xxxxx ->
      (* 6 *)
      Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
        ( module struct
          type nonrec t = M.t
        end ) )
    ~g:x

let _ =
  List.iter l
    ~f:(stack_ fun xxxxx ->
      Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
        ( module struct
          type nonrec t = M.t
        end ) )
    ~g:x

let _ =
  List.iter l (* 1 *)
    ~f:((* 2 *)
        (* 3 *)
        (* 4 *) stack_ function
      (* 5 *)
      | xxxxx ->
          (* 6 *)
          Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
            ( module struct
              type nonrec t = M.t
            end ) )
    ~g:x

let _ =
  List.iter l
    ~f:(stack_ function
      | xxxxx ->
          Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
            ( module struct
              type nonrec t = M.t
            end ) )
    ~g:x

let _ =
  List.iter l (* 1 *)
    ~f:((* 2 *)
        (* 3 *)
        (* 4 *) stack_ function
      (* 5 *)
      | _ (* 6 *) -> Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx x
      | _ (* 7 *) -> Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx x )
    ~g:x

let _ =
  List.iter l
    ~f:(stack_ function
      | _ -> Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx x
      | _ -> Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx x )
    ~g:x

(* [exclave_] *)
let _ =
  List.iter l
    ~f:(stack_ function
      (* x *)
      | xxxxx (* y *) ->
          (* z *)
          exclave_
          (* w *)
          Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
            ( module struct
              type nonrec t = M.t
            end ) )
    ~g:x

let _ =
  List.iter l ~f:(stack_ fun (* x *) xxxxx (* y *) ->
      (* z *)
      exclave_
      (* w *)
      Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
        ( module struct
          type nonrec t = M.t
        end ) )

let _ =
  List.iter l
    ~f:(stack_ function
      | xxxxx ->
          exclave_
          Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
            ( module struct
              type nonrec t = M.t
            end ) )
    ~g:x

let _ =
  List.iter l ~f:(stack_ fun xxxxx ->
      exclave_
      Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
        ( module struct
          type nonrec t = M.t
        end ) )

(* Two funs breaks comments *)
let _ = M.f ~x:(fun _ -> x) ~y:((* c *) stack_ fun _ -> y)

(* No [stack_] (for reference) *)
let _ =
  List.iter l ~f:(fun xxxxx ->
      Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
        ( module struct
          type nonrec t = M.t
        end ) )

let _ =
  List.iter l
    ~f:(fun xxxxx ->
      Xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxx
        ( module struct
          type nonrec t = M.t
        end ) )
    ~g:x

(* Two arguments *)
let xxxxxxxxxxxxxxxxx xxxxxxx ~xxx =
  xxxxxxx
    ( stack_ fun () ->
      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ;
      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx )
    ( stack_ fun () ->
      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ;
      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx )

(* Comment shouldn't split [stack_ fun] *)
let x =
  xxxxxxx
    ~xxxxxxxxxxxxxxxxxxxxxxxxxxx:(fun _ -> x)
    ~xxxxxxxxxxxxxxxxxxxxxxxxxxx:((* xxxxxxxxxxxxxxxxxxxxxxxxxx *)
      stack_ fun
        _ _ -> xxxxxxxxxxxxxxxxxxxxxx )
